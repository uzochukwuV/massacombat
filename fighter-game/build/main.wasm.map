{"version":3,"sources":["~lib/rt/common.ts","~lib/rt/tlsf.ts","~lib/shared/typeinfo.ts","~lib/rt/itcms.ts","~lib/util/number.ts","~lib/util/math.ts","~lib/util/string.ts","~lib/@massalabs/as-types/assembly/argument.ts","~lib/shared/runtime.ts","~lib/rt.ts","~lib/util/error.ts","~lib/util/sort.ts","~lib/staticarray.ts","~lib/builtins.ts","~lib/@massalabs/massa-as-sdk/assembly/std/constant.ts","~lib/@massalabs/massa-as-sdk/assembly/collections/persistentMap.ts","~lib/@massalabs/massa-as-sdk/assembly/helpers/liquidityManager.ts","assembly/contracts/types.ts","assembly/contracts/storage.ts","assembly/contracts/character.ts","assembly/contracts/randomness.ts","assembly/contracts/leaderboard.ts","assembly/contracts/treasury.ts","~lib/@massalabs/as-types/assembly/serialization/strings.ts","~lib/string.ts","~lib/@massalabs/massa-as-sdk/assembly/std/storage.ts","~lib/arraybuffer.ts","assembly/contracts/main.ts","~lib/@massalabs/as-types/assembly/serialization/numbers.ts","~lib/@massalabs/as-types/assembly/result.ts","~lib/@massalabs/massa-as-sdk/assembly/std/utils/events.ts","~lib/@massalabs/massa-as-sdk/assembly/std/context.ts","~lib/@massalabs/massa-as-sdk/assembly/std/utils/address.ts","~lib/array.ts","~lib/@massalabs/massa-as-sdk/assembly/std/address.ts","~lib/@massalabs/massa-as-sdk/assembly/std/coins/transfer.ts","~lib/number.ts","assembly/contracts/equipment.ts","assembly/contracts/skills.ts","assembly/contracts/battle.ts","~lib/@massalabs/as-types/assembly/serialization/bool.ts","assembly/contracts/status.ts","assembly/contracts/tournament.ts","assembly/contracts/achievements.ts","~lib/@massalabs/massa-as-sdk/assembly/std/coins/balance.ts","~lib/function.ts"],"names":[],"mappings":"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AA6C,EAApB,G,WAAP,E,EACO,E,KAAN,E,WAAZ,E,2KX8SD,GAAe,EAAf,C,IAAsB,E,OAAA,G,KAAtB,E,EKvSgD,EAA7C,ILuSH,CAAJ,E,QAEI,E,GADK,E,OAKoB,E,KAAiB,EAAjB,E,kCqBjJT,E,KApIf,G,WCnEqD,EtByVnD,E,4FWvQI,E,OACT,E,ONxCkD,EAA7C,IMwCL,CAAJ,E,EACsB,E,OXtEsC,EWsE/C,E,OACE,E,OAAA,E,OACX,E,KWnEM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXmET,E,EACO,E,KWpCA,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,QAAA,E,eAAA,E,cAGT,E,KAyBE,E,KAAA,G,qEjB4EO,E,KAjHoC,EAA7C,IAiHP,E,EACe,EAlHW,G,EAA0B,EAA7C,IAkHP,EADA,EAEa,CAAb,EACkB,MAAd,CAAJ,EACkB,G,cAGR,E,KA2BkB,EAA+B,EAAnD,E,KACS,EAEC,EA/BD,EA+Cb,IACuB,EAAX,GAlBG,EAkBgC,EAA/C,I,OAKG,Q,6BL8hBL,E,KAAkB,E,OAAA,G,8BqBxsBU,EAApB,G,KACH,EAAwB,EAAjC,G,kBrBusBsB,E,4FAntBb,E,KAAA,G,8DWHS,E,KAAN,E,WAAY,E,OAAxB,E,gEA4Da,E,OACb,E,KAAS,E,YACc,E,KAAA,E,cAAvB,E,mDiB9FkB,E,KAAA,E,WAAe,EAAjC,E,uKvB6DyB,E,GAAnB,E,EAjBgD,EAA7C,IAiBH,CAAJ,EAAyD,G,YACrC,EAA2B,EAA3B,CAAR,G,iELudR,E,KAAA,GAAe,EAAf,C,IAA8B,E,OAAA,G,KAA9B,E,EKzegD,EAA7C,ILyeH,CAAJ,E,QAEI,E,GADK,E,WAAP,E,EAMgB,E,OAAA,G,OAAgB,E,KAAA,E,OAAA,G,YAAhB,EsB3hBwC,EtB2hBnD,E,uDiBvdA,E,KAAY,E,OAAZ,E,+DNqCc,E,QAAhB,E,sLDXc,E,YACT,E,YACF,E,YAGA,G,YACG,G,YACG,E,YACA,E,YACC,E,YACC,E,YACJ,E,4GAQG,E,YACA,E,YACA,E,YACI,E,YAGJ,E,YACE,E,YACR,G,YACK,E,YACC,E,KAQf,E,KAAU,E,2BACG,E,2BACD,E,2BACU,EAAtB,G,sDEtHM,E,GAAR,c,EAAQ,G,WAGJ,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,GACA,G,EAIA,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,GACA,G,EAIA,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,GACA,G,EAIA,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,GACA,G,EAIA,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,GACA,G,EAIA,E,KAAkB,GAAlB,G,EACA,E,KAAe,GAAf,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAsB,EAAtB,G,EACA,E,KAAuB,EAAvB,G,EACA,E,KAAwB,EAAxB,G,EACA,E,KAAoB,EAApB,I,0CZmqBA,E,KAAkB,E,OAAA,G,8BqBtsBU,EAApB,G,KACH,EAAwB,EAAjC,G,kBrBqsBsB,E,iGAdmB,E,OAAlB,E,OACnB,E,KAAc,E,OK3rBoC,EAA7C,I,IL4rBL,E,KAAkB,E,OAAA,G,OAAuB,E,OAAvB,E,+BAqEb,K,yCKjuBgB,E,KAhC6B,EAA7C,IAgCH,CAAJ,EAAyD,G,cACzD,E,GAIS,EAJU,EAInB,G,wDL+pBE,E,KAAkB,E,OAAA,G,OqBxuBU,EAApB,G,OACZ,E,KrBuuB0D,EqBvuB1D,E,WrBuuBsB,E,kEAElB,E,KAAkB,E,OAAA,G,8BqBpsBU,EAApB,G,KACH,EAAwB,EAAjC,G,kBrBmsBsB,E,0GUvmBP,E,OACb,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACF,E,KAAA,E,gECvDa,E,OAAA,G,OAAb,E,WAA4B,E,KAAA,E,aAArC,E,2DA+LyB,E,QAAlB,E,8CCxMA,E,IAAkB,EAAlB,CAAP,EAA0C,G,4CDwBf,E,KAAb,E,WAAP,E,WCrBP,EAA6B,G,cAGtB,E,KKzE+C,EAA7C,IAAuE,EAAvE,CLyEF,E,EAAmB,EKzEE,G,EAA0B,EAA7C,IAAuE,EAAvE,CLyEgC,EAAf,E,IAA1B,EAA6C,G,gBAE9B,E,aAAA,I,GYiCR,EZhCP,E,EAGgC,E,KAAI,E,KAAQ,E,WAAM,EAAhC,E,cACA,EAAlB,G,EACA,E,KAAe,EAAf,G,EACA,E,KAAgB,GAAhB,G,EACA,E,KAAsB,EAAtB,G,EAGqB,E,KAArB,E,EAGc,E,KAAd,E,EAGoB,E,KAAQ,E,mCDmLF,E,OAAd,E,OACU,E,OAAV,E,cMhR0C,EAA7C,IAAuE,EAAvE,CNiRT,E,EACE,E,4BAEF,E,KAAS,E,kBACC,E,KAAK,E,OAAf,E,SCrLuB,E,KAAM,E,KAAU,E,GiBDvB,CAAP,G,OjBC2D,E,kBPjDzD,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,gCO+CtB,E,OAIO,E,0DQ9BC,EAAR,EAAoB,G,YAgFpB,E,8BInDO,ETvFP,EACsB,MAAf,CAAP,EAA8C,G,WJoDlC,EIlDE,MJkDF,CAAZ,EI/Ce,EAAc,MAAd,CAAf,EACa,EAAT,CAAJ,EACgB,E,WAAkB,EAAhC,G,QAGsC,Q,cAA1B,E,WAAd,E,SKoIsB,E,OpB7KsC,EoB6K/C,E,WACF,E,OAAA,E,eE3JL,E,KAdI,E,KAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,UAC2B,E,OAAA,G,YAAA,E,mBjB8ClB,GAA0D,GAAnE,GAES,GAAyB,GAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,kBiB5Cb,E,KA2CE,E,OAAA,GF4GA,E,KACK,E,OAAA,E,eE5JV,E,KAdI,E,KAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,UAC2B,E,OAAA,G,YAAA,E,mBjB8ClB,GAA0D,GAAnE,GAES,GAAyB,GAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,kBiB5Cb,E,KA2CE,E,KAAA,GF6GX,E,MACa,E,OAAA,E,eE7JP,E,KAdI,E,KAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,EACmB,G,KAAQ,E,OAAA,G,YAAA,E,mBjB8ClB,GAA0D,GAAnE,GAES,GAAyB,GAA0B,EADxC,E,eADX,GAA0D,EAAnE,GAES,GAAyB,EAA0B,EADxC,E,kBiB5Cb,E,KA2CE,E,OAAA,GF8GE,E,KAEsB,E,KAAa,E,OAAT,E,EAArB,E,KA7EA,EAAlB,E,EAgFO,E,KAAA,E,oVpBgPD,GAAe,EAAf,C,IAAsB,E,OAAA,G,KAAtB,E,EKxYgD,EAA7C,ILwYH,CAAJ,E,QAEI,E,GADK,E,OAMoB,E,KAAiB,EAAjB,E,kCqBjWT,E,KAtBf,G,WCnEqD,EtB2bnD,E,0EAlaA,E,KAAA,G,8DU+Ie,E,OAAM,EAAf,E,gBAEI,E,OACb,E,KYxJI,E,cAVA,G,aAAD,EAUA,CZwJP,EAA2C,G,sBACjC,E,KYzHL,E,cA1CG,G,SAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ8FW,E,OAChB,E,KY5JI,E,cAVA,G,OAAD,EAUA,CZ4JP,EAA8C,G,sBACjC,E,KY7HR,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZkGU,E,OACf,E,KYhKI,E,cAVA,G,OAAD,EAUA,CZgKP,EAA6C,G,sBACjC,E,KYjIP,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZsGW,E,OAChB,E,KYpKI,E,cAVA,G,OAAD,EAUA,CZoKP,EAA8C,G,sBACxB,E,KYrIjB,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,eAyBE,GZwGT,G,WAEoB,E,QAChB,E,MYxKI,E,eAVA,G,OAAD,EAUA,CZwKP,EAA8C,G,sBACjC,E,MYzIR,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4GT,G,WAEiB,E,QACb,E,MY5KI,E,eAVA,G,OAAD,EAUA,CZ4KP,EAA2C,G,sBACjC,E,MY7IL,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgHT,G,WAEiB,E,QACb,E,MYhLI,E,eAVA,G,OAAD,EAUA,CZgLP,EAA2C,G,sBACjC,E,MYjJL,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoHT,G,WAEoB,E,QAChB,E,MYpLI,E,eAVA,G,OAAD,EAUA,CZoLP,EAA8C,G,sBACjC,E,MYrJR,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwHT,G,WAEqB,E,QACjB,E,MYxLI,E,eAVA,G,OAAD,EAUA,CZwLP,EAA+C,G,sBAC9B,E,MYzJZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4HT,G,WAEqB,E,QACjB,E,MY5LI,E,eAVA,G,OAAD,EAUA,CZ4LP,EAA+C,G,sBAC9B,E,MY7JZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgIT,G,WAEmB,E,QACf,E,MYhMI,E,eAVA,G,OAAD,EAUA,CZgMP,EAA6C,G,sBAC3B,E,MYjKb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoIT,G,WAEoB,E,QAChB,E,MYpMI,E,eAVA,G,OAAD,EAUA,CZoMP,EAA8C,G,sBAC3B,E,MYrKd,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwIT,G,WAEkB,E,QACd,E,MYxMI,E,eAVA,G,OAAD,EAUA,CZwMP,EAA4C,I,uBAC7B,E,MYzKV,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4IT,G,WAEqB,E,QACjB,E,MY5MI,E,eAVA,G,OAAD,EAUA,CZ4MP,EAA+C,I,uBAC/B,E,MY7KX,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZkJW,E,QAChB,E,MYhNI,E,eAVA,G,OAAD,EAUA,CZgNP,EAA8C,I,uBAC/B,E,MYjLV,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZsJS,E,QACd,E,MYpNI,E,eAVA,G,OAAD,EAUA,CZoNP,EAA4C,I,uBACzB,E,MYrLd,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZ0JW,E,QAChB,E,MYxNI,E,eAVA,G,OAAD,EAUA,CZwNP,EAA8C,I,uBAC5B,E,MYzLb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4JT,G,WAEoB,E,QAChB,E,MY5NI,E,eAVA,G,OAAD,EAUA,CZ4NP,EAA8C,I,uBAC5B,E,MY7Lb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgKT,G,WAEoB,E,QAChB,E,MYhOI,E,eAVA,G,OAAD,EAUA,CZgOP,EAA8C,I,uBAC5B,E,MYjMb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoKT,G,WAEsB,E,QAClB,E,MYpOI,E,eAVA,G,OAAD,EAUA,CZoOP,EAAgD,I,uBAC3B,E,MYrMhB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwKT,G,WAEmB,E,QACf,E,MYxOI,E,eAVA,G,OAAD,EAUA,CZwOP,EAA6C,I,uBAC5B,E,MYzMZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4KT,G,WAEqB,E,QACjB,E,MY5OI,E,eAVA,G,OAAD,EAUA,CZ4OP,EAA+C,I,uBAC5B,E,MY7Md,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgLT,G,WAEkB,E,QACd,E,MYhPI,E,eAVA,G,OAAD,EAUA,CZgPP,EAA4C,I,uBACjC,E,MYjNN,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoLT,G,WAEqB,E,QACjB,E,MYpPI,E,eAVA,G,OAAD,EAUA,CZoPP,EAA+C,I,uBAC9B,E,MYrNZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwLT,G,WAEsB,E,QAClB,E,MYxPI,E,eAVA,G,OAAD,EAUA,CZwPP,EAAgD,I,uBAC/B,E,MYzNZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4LT,G,SAEkB,EY9QwC,EZ8QnD,E,oBAnGiC,E,EAAX,E,KYvHb,E,uEX6DO,E,OAAb,E,OACA,E,OAAP,EAAD,CAAJ,E,EACsB,E,OAAT,E,OACT,E,KNzEkD,EAA7C,IMyEL,CAAJ,E,UDWkB,G,KACD,G,cACM,ECZL,E,OACH,E,KAAsB,E,SAAtB,E,OACX,E,KWpGM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXoGT,E,OACO,E,8CSmFe,E,OpB7LsC,EoB6L/C,E,WACF,E,OAAA,E,eE3KL,E,KAdI,E,KAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,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CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,eAyBE,GZwQT,G,WAEc,E,QACV,E,MYxUI,E,eAVA,G,OAAD,EAUA,CZwUP,EAAwC,I,uBACzB,E,MYzSV,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4QT,G,WAEkB,E,QACd,E,MY5UI,E,eAVA,G,OAAD,EAUA,CZ4UP,EAA4C,I,uBACtB,E,MY7SjB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgRT,G,WAEkB,E,QACd,E,MYhVI,E,eAVA,G,OAAD,EAUA,CZgVP,EAA4C,I,uBACtB,E,MYjTjB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoRT,G,WAEgB,E,QACZ,E,MYpVI,E,eAVA,G,OAAD,EAUA,CZoVP,EAA0C,I,uBACzB,E,MYrTZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwRT,G,WAEiB,E,QACb,E,MYxVI,E,eAVA,G,OAAD,EAUA,CZwVP,EAA2C,I,uBACzB,E,MYzTb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4RT,G,WAEe,E,QACX,E,MY5VI,E,eAVA,G,OAAD,EAUA,CZ4VP,EAAyC,I,uBACvB,E,MY7Tb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgST,G,WAEkB,E,QACd,E,MYhWI,E,eAVA,G,OAAD,EAUA,CZgWP,EAA4C,I,uBACvB,E,MYjUhB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoST,G,WAEoB,E,QAChB,E,MYpWI,E,eAVA,G,OAAD,EAUA,CZoWP,EAA8C,I,uBAC5B,E,MYrUb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZ0SU,E,QACf,E,MYxWI,E,eAVA,G,OAAD,EAUA,CZwWP,EAA6C,I,uBAC5B,E,MYzUZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4ST,G,SAEkB,EY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AyBE,E,OAAA,G,sBZ6XK,E,OAAA,E,OACV,E,KY3bI,E,KAVA,E,OAAA,G,OAAD,EAUA,CZ2bP,E,SACiB,E,KY5ZZ,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,eAGT,E,KAyBE,E,OAAA,GZ+XT,G,EAEiB,E,OAAA,E,OACb,E,KY/bI,E,KAVA,E,OAAA,G,OAAD,EAUA,CZ+bP,E,SACa,E,KYhaR,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,eAGT,E,KAyBE,E,OAAA,GZmYT,G,EAEkB,E,OAAA,E,OACd,E,KYncI,E,KAVA,E,OAAA,G,OAAD,EAUA,CZmcP,E,SACc,E,KYpaT,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,eAGT,E,MAyBE,E,OAAA,GZuYT,G,EAEkB,E,OAAA,E,QACd,E,MYvcI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZucP,E,SACqB,E,MYxahB,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ2YT,G,EAEkB,E,OAAA,E,QACd,E,MY3cI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ2cP,E,SACmB,E,MY5ad,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ+YT,G,EAEgB,E,OAAA,E,QACZ,E,MY/cI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ+cP,E,SACiB,E,MYhbZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZmZT,G,EAEkB,E,OAAA,E,QACd,E,MYndI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZmdP,E,SACmB,E,MYpbd,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZuZT,G,EAEgB,E,OAAA,E,QACZ,E,MYvdI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZudP,E,SACiB,E,MYxbZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ2ZT,G,EAEgB,E,OAAA,E,QACZ,E,MY3dI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ2dP,E,SACiB,E,MY5bZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ+ZT,G,EAEiB,E,OAAA,E,QACb,E,MY/dI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ+dP,E,SACkB,E,MYhcb,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZmaT,G,EAEgB,E,OAAA,G,QACZ,E,MYneI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZmeP,E,SACsB,E,MYpcjB,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZuaT,G,EAEsB,E,OAAA,E,QAClB,E,MYveI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZueP,E,SACkB,E,MYxcb,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ2aT,G,EAEsB,E,OAAA,E,QAClB,E,MY3eI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ2eP,E,SACuB,E,MY5clB,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ+aT,G,EAEY,E,OAAA,E,QACR,E,MY/eI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ+eP,E,SACiB,E,MYhdZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZmbT,G,EAEY,E,OAAA,E,QACR,E,MYnfI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZmfP,E,SACiB,E,MYpdZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZubT,G,EAEY,E,OAAA,E,QACR,E,MYvfI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZufP,E,SACiB,E,MYxdZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ2bT,G,EAEY,E,OAAA,E,QACR,E,MY3fI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ2fP,E,SACiB,E,MY5dZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ+bT,G,EAEY,E,OAAA,E,QACR,E,MY/fI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ+fP,E,SACiB,E,MYheZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZmcT,G,EAEY,E,OAAA,E,QACR,E,MYngBI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZmgBP,E,SACiB,E,MYpeZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZucT,G,EAEY,E,OAAA,E,QACR,E,MYvgBI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZugBP,E,SACiB,E,MYxeZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ2cT,G,EAEY,E,OAAA,E,QACR,E,MY3gBI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ2gBP,E,SACiB,E,MY5eZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZ+cT,G,EAEY,E,OAAA,E,QACR,E,MY/gBI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZ+gBP,E,SACiB,E,MYhfZ,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZmdT,G,EAEa,E,OAAA,E,QACT,E,MYnhBI,E,MAVA,E,OAAA,G,OAAD,EAUA,CZmhBP,E,SACkB,E,MYpfb,E,MA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,gBAGT,E,MAyBE,E,OAAA,GZudT,G,EAEkB,E,KAAA,EYziBwC,EZyiBnD,E,sCA/FgC,E,IAAX,E,cYtZZ,E,2MZ+W8B,EAAgB,EV+J/C,G,OACA,E,KAAmB,E,OAAA,G,OAAiB,E,WAAA,GAApC,G,OACX,E,KsBjjBI,E,KAVA,E,OAAA,G,OAAD,EAUA,CtBijBP,E,EACoB,E,6BAAQ,E,aAAnB,G,WAAP,E,SAEa,E,KsBphBV,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,QAAA,E,eAAA,E,cAGT,E,KAyBE,E,OAAA,GtBufT,G,EACkB,E,KsBxkBwC,EtBwkBnD,G,8DUwBe,E,OAAM,EAAf,E,gBAEC,E,OACV,E,KYhlBI,E,cAVA,G,aAAD,EAUA,CZglBP,E,SACU,E,KYjjBL,E,cA1CG,G,SAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZshBK,G,OACV,E,KYplBI,E,cAVA,G,OAAD,EAUA,CZolBP,E,SACe,E,KYrjBV,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ0hBK,G,OACV,E,KYxlBI,E,cAVA,G,OAAD,EAUA,CZwlBP,E,SACe,E,KYzjBV,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ8hBO,E,OACZ,E,KY5lBI,E,cAVA,G,OAAD,EAUA,CZ4lBP,E,SACmB,E,KY7jBd,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,eAyBE,GZgiBT,G,WAEmB,E,QACf,E,MYhmBI,E,eAVA,G,OAAD,EAUA,CZgmBP,E,SACkB,E,MYjkBb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZoiBT,G,WAEiB,E,QACb,E,MYpmBI,E,eAVA,G,OAAD,EAUA,CZomBP,E,SACa,E,MYrkBR,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwiBT,G,WAEkB,E,QACd,E,MYxmBI,E,eAVA,G,OAAD,EAUA,CZwmBP,E,SACgB,E,MYzkBX,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZ8iBQ,E,QACb,E,MY5mBI,E,eAVA,G,OAAD,EAUA,CZ4mBP,E,SACsB,E,MY7kBjB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgjBT,G,WAEgB,E,QACZ,E,MYhnBI,E,eAVA,G,OAAD,EAUA,CZgnBP,E,SAC2B,E,MYjlBtB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZojBT,G,WAEoB,G,QAChB,E,MYpnBI,E,eAVA,G,OAAD,EAUA,CZonBP,E,SACsB,E,MYrlBjB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwjBT,G,WAEkB,E,QACd,E,MYxnBI,E,eAVA,G,OAAD,EAUA,CZwnBP,E,SACoB,E,MYzlBf,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4jBT,G,WAEkB,E,QACd,E,MY5nBI,E,eAVA,G,OAAD,EAUA,CZ4nBP,E,SACwB,E,MY7lBnB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZgkBT,G,WAEiB,E,QACb,E,MYhoBI,E,eAVA,G,OAAD,EAUA,CZgoBP,E,SAC+B,E,MYjmB1B,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZokBT,G,WAEiB,E,QACb,E,MYpoBI,E,eAVA,G,OAAD,EAUA,CZooBP,E,SAC+B,E,MYrmB1B,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZwkBT,G,WAEgB,E,QACZ,E,MYxoBI,E,eAVA,G,OAAD,EAUA,CZwoBP,E,SACkB,E,MYzmBb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ4kBT,G,SAEkB,EY9pBwC,EZ8pBnD,E,6BA3D8B,E,IAAX,E,KY/iBV,E,uEX2HI,E,OAAV,G,OACA,E,OAAP,EAAD,CAAJ,E,EACsB,E,OAAT,E,OACT,E,KNvIkD,EAA7C,IMuIL,CAAJ,E,aACe,G,OACA,E,KAAmB,E,SAAnB,G,OACX,E,KWlKM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXkKT,E,OACO,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E,OAAA,G,SAAA,G,SAAjC,I,EACS,E,OAAA,G,OAAA,G,IAA2B,E,OAAA,G,KAA3B,E,EAA2B,GAA3B,CAAJ,E,EACoB,E,KAAQ,E,OAAA,G,QAGR,E,KAAQ,E,OAAA,G,UAHA,G,SAAjC,I,kEZzdM,EAAR,EAAoB,G,cA4UE,E,OpBpasC,EoBoa/C,E,WACI,E,OAAA,E,gBElZX,E,KAdI,E,KAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,EACmB,I,KAAQ,E,OAAA,G,YAAA,E,gBAAA,E,qBjB8ClB,IAA0D,IAAnE,GAES,IAAyB,IAA0B,EADxC,E,gBADX,IAA0D,EAAnE,GAES,IAAyB,EAA0B,EADxC,E,oCiB5Cb,E,KA2CE,E,OAAA,GFmWM,E,KACA,E,4BYsJQ,E,OAAV,G,OAER,E,KAAA,GAAgB,EAAhB,CAAP,EAA8C,I,aR/bvC,E,IQiciB,KRjcjB,E,EQiciB,GAAtB,CADF,EAEE,I,eAIE,E,KAAA,GAAkC,GAAlC,CAAJ,E,EACE,E,KAAiC,EAAjC,I,EAEE,E,KAAA,GAAkC,GAAlC,CAAJ,E,EACE,E,KAAiC,EAAjC,I,EAGc,E,KAAhB,G,mFpB7NgC,E,OAAd,E,KACX,GAAP,EAA0B,I,cAE1B,E,MAAA,E,wBAAiB,EAAjB,G,EACc,E,MAAA,E,wBAAd,E,iJF+ZW,E,YACC,E,YACE,E,KAGZ,E,KAAmB,E,2BACC,E,2BACT,EAAX,G,6EClkBK,E,8DAmBe,G,aAAT,I,KACT,E,ON9MkD,EAA7C,IM8ML,CAAJ,E,EACsB,E,OX5OsC,EW4O/C,E,OACE,E,OAAA,E,OACX,E,KWzOM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXyOT,E,EACO,E,KW1MA,E,KA1CG,E,OAAA,G,OAAD,EA0CH,CAAJ,E,EACgB,E,OAAA,G,QAAA,E,eAAA,E,cAGT,E,KAyBE,E,KAAA,G,wEXiJc,EkBvDhB,G,clBuDF,E,8DDolBiB,E,OAAM,EAAf,E,gBAEG,E,OACZ,E,KYryBI,E,cAVA,G,aAAD,EAUA,CZqyBP,E,SACmB,E,KYtwBd,E,cA1CG,G,SAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ2uBQ,E,OACb,E,KYzyBI,E,cAVA,G,OAAD,EAUA,CZyyBP,E,SACoB,E,KY1wBf,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ+uBM,E,OACX,E,KY7yBI,E,cAVA,G,OAAD,EAUA,CZ6yBP,E,SACW,E,KY9wBN,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,GZivBT,G,WAEgB,E,OACZ,E,KYjzBI,E,cAVA,G,OAAD,EAUA,CZizBP,E,SACY,E,KYlxBP,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,eAyBE,GZqvBT,G,WAEkB,E,QACd,E,MYrzBI,E,eAVA,G,OAAD,EAUA,CZqzBP,E,SACc,E,MYtxBT,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZyvBT,G,SAEkB,EY30BwC,EZ20BnD,E,6BAnBgC,E,IAAX,E,KYpwBZ,E,uEXyLS,EAAf,G,OACA,E,OAAP,EAAD,CAAJ,E,EACsB,E,OAAT,E,OACT,E,KNrMkD,EAA7C,IMqML,CAAJ,E,UDojB6D,G,WAAe,ECnjB9D,G,OACC,E,KAAkB,E,SAAlB,G,OACX,E,KWhOM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXgOT,E,OACO,E,qEDujBQ,E,OACb,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,IACF,E,KAAA,E,4DCxkBe,EAAf,G,WAAsB,E,KAAA,G,aAA/B,E,gEAwBa,E,OACb,E,KAAS,E,EACA,G,WAAuB,E,KAAA,E,aAAhC,E,0DGlIgC,E,OAAA,G,SAAd,E,KACd,GAAJ,E,OAAuB,E,EAGrB,E,OAAA,G,OACA,E,OAAA,G,OACA,E,WAAA,GAHY,G,OAKd,E,KAAa,E,OAAA,GAAb,G,EACA,E,KAAe,E,OAAA,GAAf,GAGY,GAAZ,EACA,E,EAGqB,EAAI,EAAJ,C,IACmB,EAArB,G,KACb,E,IAGA,E,OAAA,G,OAAwB,E,OAAA,G,SAAxB,EAAJ,EAEoB,EAAb,E,EAAgB,EAAI,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,E,KAdI,E,MAVA,E,OAAA,G,OAAD,EAUA,CAcP,E,EACmB,I,MAAQ,E,OAAA,G,aAAA,E,sBjB8ClB,IAA0D,IAAnE,GAES,IAAyB,IAA0B,EADxC,E,gBADX,IAA0D,EAAnE,GAES,IAAyB,EAA0B,EADxC,E,oBiB5Cb,E,MA2CE,E,KAAA,GFgZX,E,EAEqC,E,KAAc,E,SAAM,EAAU,EAAhD,G,QACZ,E,KAAA,G,qGVmPiB,E,OAAM,EAAf,E,gBAEC,E,OACV,E,KYtsBI,E,cAVA,G,aAAD,EAUA,CZssBP,E,SACU,E,KYvqBL,E,cA1CG,G,SAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ4oBO,E,OACZ,E,KY1sBI,E,cAVA,G,OAAD,EAUA,CZ0sBP,E,SACY,E,KY3qBP,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZgpBM,E,OACX,E,KY9sBI,E,cAVA,G,OAAD,EAUA,CZ8sBP,E,SACgB,E,KY/qBX,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,GZkpBT,G,WAEiB,E,OACb,E,KYltBI,E,cAVA,G,OAAD,EAUA,CZktBP,E,SACiB,E,KYnrBZ,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,eAyBE,GZspBT,G,WAEe,E,QACX,E,MYttBI,E,eAVA,G,OAAD,EAUA,CZstBP,E,SACuB,E,MYvrBlB,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ0pBT,G,WAEiB,E,QACb,E,MY1tBI,E,eAVA,G,OAAD,EAUA,CZ0tBP,E,SACoB,E,MY3rBf,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ8pBT,G,WAEiB,E,QACb,E,MY9tBI,E,eAVA,G,OAAD,EAUA,CZ8tBP,E,SACa,E,MY/rBR,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZkqBT,G,WAEgB,E,QACZ,E,MYluBI,E,eAVA,G,OAAD,EAUA,CZkuBP,E,SACoB,E,MYnsBf,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZwqBU,E,QACf,E,MYtuBI,E,eAVA,G,OAAD,EAUA,CZsuBP,E,SACe,E,MYvsBV,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZ4qBM,E,QACX,E,MY1uBI,E,eAVA,G,OAAD,EAUA,CZ0uBP,E,SACgB,E,MY3sBX,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZgrBS,E,QACd,E,MY9uBI,E,eAVA,G,OAAD,EAUA,CZ8uBP,E,SACkB,E,MY/sBb,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZorBQ,E,QACb,E,MYlvBI,E,eAVA,G,OAAD,EAUA,CZkvBP,E,SACoB,E,MYntBf,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,G,+BZwrBU,E,QACf,E,MYtvBI,E,eAVA,G,OAAD,EAUA,CZsvBP,E,SACiB,E,MYvtBZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ0rBT,G,WAEmB,E,QACf,E,MY1vBI,E,eAVA,G,OAAD,EAUA,CZ0vBP,E,SACiB,E,MY3tBZ,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZ8rBT,G,WAEiB,E,QACb,E,MY9vBI,E,eAVA,G,OAAD,EAUA,CZ8vBP,E,SACe,E,MY/tBV,E,eA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,gBAGT,E,eAyBE,GZksBT,G,SAEkB,EYpxBwC,EZoxBnD,E,6BA3D8B,E,IAAX,E,KYrqBV,E,uEX0JQ,E,OAAd,G,OACA,E,OAAP,EAAD,CAAJ,E,EACsB,E,OAAT,E,OACT,E,KNtKkD,EAA7C,IMsKL,CAAJ,E,aACmB,G,OACJ,E,KAAuB,E,SAAvB,G,OACX,E,KWjMM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXiMT,E,OACO,E,iEwBkHH,E,OAAA,G,OlBtSkD,EAA7C,IAAuE,EAAvE,CkBsSL,CAAJ,E,UACS,G,WAAP,E,EAEK,E,OAAA,G,sBAAA,E,4DA3M2B,E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AApB,EAAO,GAAP,C,GACmB,IAAnB,EAAO,GAAP,C,GACG,KMiTM,E,SACE,E,OACf,E,KAAW,E,YACJ,E,KAAA,E,+DT1TmB,E,QAAnB,E,qHD2kBqB,E,4CAIN,E,8EAYE,E,OAAM,EAAf,E,gBAEI,E,OACb,E,KYt1BI,E,cAVA,G,aAAD,EAUA,CZs1BP,E,SACoB,E,KYvzBf,E,cA1CG,G,SAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,+BZ4xBM,E,OACX,E,KY11BI,E,cAVA,G,OAAD,EAUA,CZ01BP,E,SAC4B,E,KY3zBvB,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,GZ8xBT,G,WAEc,E,OACV,E,KY91BI,E,cAVA,G,OAAD,EAUA,CZ81BP,E,SACkB,E,KY/zBb,E,cA1CG,G,OAAD,EA0CH,CAAJ,E,WACgB,G,eAGT,E,cAyBE,G,6BZoyBS,EYp3BwC,EZo3BnD,E,6BAXiC,E,IAAX,E,KYrzBb,E,2DX0Oa,E,gCAXJ,E,OAAf,G,OACA,E,GAUE,E,EAVT,EAAD,CAAJ,E,OAAyB,E,OACH,E,OAAT,E,OACT,E,KN3OkD,EAA7C,IM2OL,CAAJ,E,OAA6B,E,kBACb,G,OACD,E,KAAoB,E,SAApB,G,OACX,E,KWtQM,E,KAVA,E,OAAA,G,OAAD,EAUA,CXsQT,E,OAA2B,E,oBAMvB,GAAJ,E,EACmC,E,OAAvB,G,aAEL,E,2ED4jBQ,E,OACb,E,KAAS,E,OAAA,G,cACT,E,KAAS,E,OAAA,G,IACT,E,KAAS,E,OAAA,G,cACF,E,KAAA,E,4E0Bz0BD,E,KAAA,GADS,EAAW,EAAgB,E,GAAhB,CAAX,CACT,CAAuC,EAAxC,C,WAUP,E,OACS,EAAP,E,EAIF,E,KAAA,E,OAAA,GADiB,EAAW,EAAgB,E,GAAhB,CAAX,C,CACjB,G,EZqGO,EYlGW,E,OACd,E,OAAA,G,OnBXkD,EAA7C,IAAuE,EAAvE,CmBWT,E,EACE,E,KAAA,E,OAAA,G,+CAEF,E,KAAA,E,OAAA,G,OAAyB,E,GPiFT,GAAP,G,OOjF4C,E,mB/BiC1C,IAA0D,EAAnE,GAES,IAAyB,EAA0B,EADx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","sourceRoot":"./main","sourcesContent":["// Alignment guarantees\n\n// @ts-ignore: decorator\n@inline export const AL_BITS: u32 = 4; // 16 bytes to fit up to v128\n// @ts-ignore: decorator\n@inline export const AL_SIZE: usize = 1 << <usize>AL_BITS;\n// @ts-ignore: decorator\n@inline export const AL_MASK: usize = AL_SIZE - 1;\n\n// Extra debugging\n\n// @ts-ignore: decorator\n@inline export const DEBUG = true;\n// @ts-ignore: decorator\n@inline export const TRACE = false;\n// @ts-ignore: decorator\n@inline export const RTRACE = isDefined(ASC_RTRACE);\n// @ts-ignore: decorator\n@inline export const PROFILE = isDefined(ASC_PROFILE);\n\n// Memory manager\n\n//  Memory manager block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                            MM info                              -4\n// >ptr\n//                               ...                              \n@unmanaged export class BLOCK {\n  /** Memory manager info. */\n  mmInfo: usize;\n}\n\n/** Overhead of a memory manager block. */\n// @ts-ignore: decorator\n@inline export const BLOCK_OVERHEAD: usize = offsetof<BLOCK>();\n\n/** Maximum size of a memory manager block's payload. */\n// @ts-ignore: decorator\n@inline export const BLOCK_MAXSIZE: usize = (1 << 30) - BLOCK_OVERHEAD;\n\n// Garbage collector\n\n//  Garbage collector object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                      Memory manager block                       -20\n// \n//                             GC info                             -16\n// \n//                             GC info                             -12\n// \n//                             RT id                               -8\n// \n//                             RT size                             -4\n// >ptr\n//                               ...                              \n@unmanaged export class OBJECT extends BLOCK {\n  /** Garbage collector info. */\n  gcInfo: u32;\n  /** Garbage collector info. */\n  gcInfo2: u32;\n  /** Runtime class id. */\n  rtId: u32;\n  /** Runtime object size. */\n  rtSize: u32;\n}\n\n/** Overhead of a garbage collector object. Excludes memory manager block overhead. */\n// @ts-ignore: decorator\n@inline export const OBJECT_OVERHEAD: usize = (offsetof<OBJECT>() - BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK;\n\n/** Maximum size of a garbage collector object's payload. */\n// @ts-ignore: decorator\n@inline export const OBJECT_MAXSIZE: usize = BLOCK_MAXSIZE - OBJECT_OVERHEAD;\n\n/** Total of memory manager and garbage collector overhead. */\n// @ts-ignore: decorator\n@inline export const TOTAL_OVERHEAD: usize = BLOCK_OVERHEAD + OBJECT_OVERHEAD;\n","import { AL_BITS, AL_SIZE, AL_MASK, DEBUG, BLOCK, BLOCK_OVERHEAD, BLOCK_MAXSIZE } from \"./common\";\nimport { oninit, onalloc, onresize, onmove, onfree } from \"./rtrace\";\nimport { E_ALLOCATION_TOO_LARGE } from \"../util/error\";\n\n// === The TLSF (Two-Level Segregate Fit) memory allocator ===\n// see: http://www.gii.upv.es/tlsf/\n\n// - `ffs(x)` is equivalent to `ctz(x)` with x != 0\n// - `fls(x)` is equivalent to `sizeof(x) * 8 - clz(x) - 1`\n\n//  Block size interpretation (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//  |                    FL                        SB = SL + AL    usize\n// \n// FL: first level, SL: second level, AL: alignment, SB: small block\n\n// @ts-ignore: decorator\n@inline const SL_BITS: u32 = 4;\n// @ts-ignore: decorator\n@inline const SL_SIZE: u32 = 1 << SL_BITS;\n\n// @ts-ignore: decorator\n@inline const SB_BITS: u32 = SL_BITS + AL_BITS;\n// @ts-ignore: decorator\n@inline const SB_SIZE: u32 = 1 << SB_BITS;\n\n// @ts-ignore: decorator\n@inline const FL_BITS: u32 = 31 - SB_BITS;\n\n// [00]: < 256B (SB)  [12]: < 1M\n// [01]: < 512B       [13]: < 2M\n// [02]: < 1K         [14]: < 4M\n// [03]: < 2K         [15]: < 8M\n// [04]: < 4K         [16]: < 16M\n// [05]: < 8K         [17]: < 32M\n// [06]: < 16K        [18]: < 64M\n// [07]: < 32K        [19]: < 128M\n// [08]: < 64K        [20]: < 256M\n// [09]: < 128K       [21]: < 512M\n// [10]: < 256K       [22]: <= 1G - OVERHEAD\n// [11]: < 512K\n// VMs limit to 2GB total (currently), making one 1G block max (or three 512M etc.) due to block overhead\n\n// Tags stored in otherwise unused alignment bits\n\n// @ts-ignore: decorator\n@inline const FREE: usize = 1 << 0;\n// @ts-ignore: decorator\n@inline const LEFTFREE: usize = 1 << 1;\n// @ts-ignore: decorator\n@inline const TAGS_MASK: usize = FREE | LEFTFREE; // <= AL_MASK\n\n//  Block layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//             \n//                           size                             LF  info   overhead\n// >ptr           \n//                         if free:  prev                          usize\n//    \n//                         if free: next                          \n//    \n//                              ...                                   >= 0\n//    \n//                         if free: back                          \n//  >= MIN SIZE\n// F: FREE, L: LEFTFREE\n@unmanaged export class Block extends BLOCK {\n\n  /** Previous free block, if any. Only valid if free, otherwise part of payload. */\n  prev: Block | null;\n  /** Next free block, if any. Only valid if free, otherwise part of payload. */\n  next: Block | null;\n\n  // If the block is free, there is a 'back'reference at its end pointing at its start.\n}\n\n// Block constants. A block must have a minimum size of three pointers so it can hold `prev`,\n// `next` and `back` if free.\n\n// @ts-ignore: decorator\n@inline const BLOCK_MINSIZE: usize = ((3 * sizeof<usize>() + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD; // prev + next + back\n// @ts-ignore: decorator\n// @inline const BLOCK_MAXSIZE: usize = 1 << (FL_BITS + SB_BITS - 1); // exclusive, lives in common.ts\n\n/** Gets the left block of a block. Only valid if the left block is free. */\n// @ts-ignore: decorator\n@inline function GETFREELEFT(block: Block): Block {\n  return load<Block>(changetype<usize>(block) - sizeof<usize>());\n}\n\n/** Gets the right block of a block by advancing to the right by its size. */\n// @ts-ignore: decorator\n@inline function GETRIGHT(block: Block): Block {\n  return changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + (block.mmInfo & ~TAGS_MASK));\n}\n\n//  Root layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//           \n//         0        |           flMap                            S \n//       \n//                            slMap[0] S                             \n//      \n//                            slMap[1]                               \n//   u32 \n//                            slMap[22]                              \n//     usize\n//                             head[0]                             \n//       \n//                               ...                               \n//       \n//                            head[367]                            \n//       \n//                              tail                               \n//    SIZE   \n// S: Small blocks map\n@unmanaged class Root {\n  /** First level bitmap. */\n  flMap: usize;\n}\n\n// Root constants. Where stuff is stored inside of the root structure.\n\n// @ts-ignore: decorator\n@inline const SL_START: usize = sizeof<usize>();\n// @ts-ignore: decorator\n@inline const SL_END: usize = SL_START + (FL_BITS << alignof<u32>());\n// @ts-ignore: decorator\n@inline const HL_START: usize = (SL_END + AL_MASK) & ~AL_MASK;\n// @ts-ignore: decorator\n@inline const HL_END: usize = HL_START + FL_BITS * SL_SIZE * sizeof<usize>();\n// @ts-ignore: decorator\n@inline const ROOT_SIZE: usize = HL_END + sizeof<usize>();\n\n// @ts-ignore: decorator\n@lazy export let ROOT: Root = changetype<Root>(0); // unsafe initializion below\n\n/** Gets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function GETSL(root: Root, fl: usize): u32 {\n  return load<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    SL_START\n  );\n}\n\n/** Sets the second level map of the specified first level. */\n// @ts-ignore: decorator\n@inline function SETSL(root: Root, fl: usize, slMap: u32): void {\n  store<u32>(\n    changetype<usize>(root) + (fl << alignof<u32>()),\n    slMap,\n    SL_START\n  );\n}\n\n/** Gets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function GETHEAD(root: Root, fl: usize, sl: u32): Block | null {\n  return load<Block>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    HL_START\n  );\n}\n\n/** Sets the head of the free list for the specified combination of first and second level. */\n// @ts-ignore: decorator\n@inline function SETHEAD(root: Root, fl: usize, sl: u32, head: Block | null): void {\n  store<Block | null>(\n    changetype<usize>(root) + (((fl << SL_BITS) + <usize>sl) << alignof<usize>()),\n    head,\n    HL_START\n  );\n}\n\n/** Gets the tail block.. */\n// @ts-ignore: decorator\n@inline function GETTAIL(root: Root): Block {\n  return load<Block>(\n    changetype<usize>(root),\n    HL_END\n  );\n}\n\n/** Sets the tail block. */\n// @ts-ignore: decorator\n@inline function SETTAIL(root: Root, tail: Block): void {\n  store<Block>(\n    changetype<usize>(root),\n    tail,\n    HL_END\n  );\n}\n\n/** Inserts a previously used block back into the free list. */\nfunction insertBlock(root: Root, block: Block): void {\n  if (DEBUG) assert(block); // cannot be null\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n\n  // merge with right block if also free\n  if (rightInfo & FREE) {\n    removeBlock(root, right);\n    block.mmInfo = blockInfo = blockInfo + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK); // keep block tags\n    right = GETRIGHT(block);\n    rightInfo = right.mmInfo;\n    // 'back' is set below\n  }\n\n  // merge with left block if also free\n  if (blockInfo & LEFTFREE) {\n    let left = GETFREELEFT(block);\n    let leftInfo = left.mmInfo;\n    if (DEBUG) assert(leftInfo & FREE); // must be free according to right tags\n    removeBlock(root, left);\n    block = left;\n    block.mmInfo = blockInfo = leftInfo + BLOCK_OVERHEAD + (blockInfo & ~TAGS_MASK); // keep left tags\n    // 'back' is set below\n  }\n\n  right.mmInfo = rightInfo | LEFTFREE;\n  // reference to right is no longer used now, hence rightInfo is not synced\n\n  // we now know the size of the block\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be a valid size\n  if (DEBUG) assert(changetype<usize>(block) + BLOCK_OVERHEAD + size == changetype<usize>(right)); // must match\n\n  // set 'back' to itself at the end of block\n  store<Block>(changetype<usize>(right) - sizeof<usize>(), block);\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // perform insertion\n  let head = GETHEAD(root, fl, sl);\n  block.prev = null;\n  block.next = head;\n  if (head) head.prev = block;\n  SETHEAD(root, fl, sl, block);\n\n  // update first and second level maps\n  root.flMap |= (1 << fl);\n  SETSL(root, fl, GETSL(root, fl) | (1 << sl));\n}\n\n/** Removes a free block from internal lists. */\nfunction removeBlock(root: Root, block: Block): void {\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(blockInfo & FREE); // must be free\n  let size = blockInfo & ~TAGS_MASK;\n  if (DEBUG) assert(size >= BLOCK_MINSIZE); // must be valid\n\n  // mapping_insert\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const inv: usize = sizeof<usize>() * 8 - 1;\n    let boundedSize = min(size, BLOCK_MAXSIZE);\n    fl = inv - clz<usize>(boundedSize);\n    sl = <u32>((boundedSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // link previous and next free block\n  let prev = block.prev;\n  let next = block.next;\n  if (prev) prev.next = next;\n  if (next) next.prev = prev;\n\n  // update head if we are removing it\n  if (block == GETHEAD(root, fl, sl)) {\n    SETHEAD(root, fl, sl, next);\n\n    // clear second level map if head is empty now\n    if (!next) {\n      let slMap = GETSL(root, fl);\n      SETSL(root, fl, slMap &= ~(1 << sl));\n\n      // clear first level map if second level is empty now\n      if (!slMap) root.flMap &= ~(1 << fl);\n    }\n  }\n  // note: does not alter left/back because it is likely that splitting\n  // is performed afterwards, invalidating those changes. so, the caller\n  // must perform those updates.\n}\n\nfunction roundSize(size: usize): usize {\n  const halfMaxSize = BLOCK_MAXSIZE >> 1; // don't round last fl\n  const inv: usize = sizeof<usize>() * 8 - 1;\n  const invRound = inv - SL_BITS;\n  return size < halfMaxSize\n    ? size + (1 << (invRound - clz<usize>(size))) - 1\n    : size;\n}\n\n/** Searches for a free block of at least the specified size. */\nfunction searchBlock(root: Root, size: usize): Block | null {\n  // size was already asserted by caller\n\n  // mapping_search\n  let fl: usize, sl: u32;\n  if (size < SB_SIZE) {\n    fl = 0;\n    sl = <u32>(size >> AL_BITS);\n  } else {\n    const requestSize = roundSize(size);\n    fl = sizeof<usize>() * 8 - 1 - clz<usize>(requestSize);\n    sl = <u32>((requestSize >> (fl - SL_BITS)) ^ (1 << SL_BITS));\n    fl -= SB_BITS - 1;\n  }\n  if (DEBUG) assert(fl < FL_BITS && sl < SL_SIZE); // fl/sl out of range\n\n  // search second level\n  let slMap = GETSL(root, fl) & (~0 << sl);\n  let head: Block | null = null;\n  if (!slMap) {\n    // search next larger first level\n    let flMap = root.flMap & (~0 << (fl + 1));\n    if (!flMap) {\n      head = null;\n    } else {\n      fl = ctz<usize>(flMap);\n      slMap = GETSL(root, fl);\n      if (DEBUG) assert(slMap);  // can't be zero if fl points here\n      head = GETHEAD(root, fl, ctz<u32>(slMap));\n    }\n  } else {\n    head = GETHEAD(root, fl, ctz<u32>(slMap));\n  }\n  return head;\n}\n\n/** Prepares the specified block before (re-)use, possibly splitting it. */\nfunction prepareBlock(root: Root, block: Block, size: usize): void {\n  // size was already asserted by caller\n\n  let blockInfo = block.mmInfo;\n  if (DEBUG) assert(!((size + BLOCK_OVERHEAD) & AL_MASK)); // size must be aligned so the new block is\n\n  // split if the block can hold another MINSIZE block incl. overhead\n  let remaining = (blockInfo & ~TAGS_MASK) - size;\n  if (remaining >= BLOCK_OVERHEAD + BLOCK_MINSIZE) {\n    block.mmInfo = size | (blockInfo & LEFTFREE); // also discards FREE\n\n    let spare = changetype<Block>(changetype<usize>(block) + BLOCK_OVERHEAD + size);\n    spare.mmInfo = (remaining - BLOCK_OVERHEAD) | FREE; // not LEFTFREE\n    insertBlock(root, spare); // also sets 'back'\n\n  // otherwise tag block as no longer FREE and right as no longer LEFTFREE\n  } else {\n    block.mmInfo = blockInfo & ~FREE;\n    GETRIGHT(block).mmInfo &= ~LEFTFREE;\n  }\n}\n\n/** Adds more memory to the pool. */\nfunction addMemory(root: Root, start: usize, endU64: u64): bool {\n  let end = <usize>endU64;\n  if (DEBUG) assert(<u64>start <= endU64); // must be valid\n  start = ((start + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n  end &= ~AL_MASK;\n\n  let tail = GETTAIL(root);\n  let tailInfo: usize = 0;\n  if (tail) { // more memory\n    if (DEBUG) assert(start >= changetype<usize>(tail) + BLOCK_OVERHEAD);\n\n    // merge with current tail if adjacent\n    const offsetToTail = AL_SIZE;\n    if (start - offsetToTail == changetype<usize>(tail)) {\n      start -= offsetToTail;\n      tailInfo = tail.mmInfo;\n    } else {\n      // We don't do this, but a user might `memory.grow` manually\n      // leading to non-adjacent pages managed by TLSF.\n    }\n\n  } else if (DEBUG) { // first memory\n    assert(start >= changetype<usize>(root) + ROOT_SIZE); // starts after root\n  }\n\n  // check if size is large enough for a free block and the tail block\n  let size = end - start;\n  if (size < BLOCK_OVERHEAD + BLOCK_MINSIZE + BLOCK_OVERHEAD) {\n    return false;\n  }\n\n  // left size is total minus its own and the zero-length tail's header\n  let leftSize = size - 2 * BLOCK_OVERHEAD;\n  let left = changetype<Block>(start);\n  left.mmInfo = leftSize | FREE | (tailInfo & LEFTFREE);\n  left.prev = null;\n  left.next = null;\n\n  // tail is a zero-length used block\n  tail = changetype<Block>(start + BLOCK_OVERHEAD + leftSize);\n  tail.mmInfo = 0 | LEFTFREE;\n  SETTAIL(root, tail);\n\n  insertBlock(root, left); // also merges with free left before tail / sets 'back'\n\n  return true;\n}\n\n/** Grows memory to fit at least another block of the specified size. */\nfunction growMemory(root: Root, size: usize): void {\n  if (ASC_LOW_MEMORY_LIMIT) {\n    unreachable();\n    return;\n  }\n  // Here, both rounding performed in searchBlock ...\n  if (size >= SB_SIZE) {\n    size = roundSize(size);\n  }\n  // and additional BLOCK_OVERHEAD must be taken into account. If we are going\n  // to merge with the tail block, that's one time, otherwise it's two times.\n  let pagesBefore = memory.size();\n  size += BLOCK_OVERHEAD << usize((<usize>pagesBefore << 16) - BLOCK_OVERHEAD != changetype<usize>(GETTAIL(root)));\n  let pagesNeeded = <i32>(((size + 0xffff) & ~0xffff) >>> 16);\n  let pagesWanted = max(pagesBefore, pagesNeeded); // double memory\n  if (memory.grow(pagesWanted) < 0) {\n    if (memory.grow(pagesNeeded) < 0) unreachable();\n  }\n  let pagesAfter = memory.size();\n  addMemory(root, <usize>pagesBefore << 16, <u64>pagesAfter << 16);\n}\n\n/** Computes the size (excl. header) of a block. */\nfunction computeSize(size: usize): usize {\n  // Size must be large enough and aligned minus preceeding overhead\n  return size <= BLOCK_MINSIZE\n    ? BLOCK_MINSIZE\n    : ((size + BLOCK_OVERHEAD + AL_MASK) & ~AL_MASK) - BLOCK_OVERHEAD;\n}\n\n/** Prepares and checks an allocation size. */\nfunction prepareSize(size: usize): usize {\n  if (size > BLOCK_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  return computeSize(size);\n}\n\n/** Initializes the root structure. */\nfunction initialize(): void {\n  if (isDefined(ASC_RTRACE)) oninit(__heap_base);\n  let rootOffset = (__heap_base + AL_MASK) & ~AL_MASK;\n  let pagesBefore = memory.size();\n  let pagesNeeded = <i32>((((rootOffset + ROOT_SIZE) + 0xffff) & ~0xffff) >>> 16);\n  if (pagesNeeded > pagesBefore && memory.grow(pagesNeeded - pagesBefore) < 0) unreachable();\n  let root = changetype<Root>(rootOffset);\n  root.flMap = 0;\n  SETTAIL(root, changetype<Block>(0));\n  for (let fl: usize = 0; fl < FL_BITS; ++fl) {\n    SETSL(root, fl, 0);\n    for (let sl: u32 = 0; sl < SL_SIZE; ++sl) {\n      SETHEAD(root, fl, sl, null);\n    }\n  }\n  let memStart = rootOffset + ROOT_SIZE;\n  if (ASC_LOW_MEMORY_LIMIT) {\n    const memEnd = <u64>ASC_LOW_MEMORY_LIMIT & ~AL_MASK;\n    if (memStart <= memEnd) addMemory(root, memStart, memEnd);\n    else unreachable(); // low memory limit already exceeded\n  } else {\n    addMemory(root, memStart, <u64>memory.size() << 16);\n  }\n  ROOT = root;\n}\n\n/** Allocates a block of the specified size. */\nexport function allocateBlock(root: Root, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let block = searchBlock(root, payloadSize);\n  if (!block) {\n    growMemory(root, payloadSize);\n    block = changetype<Block>(searchBlock(root, payloadSize));\n    if (DEBUG) assert(block); // must be found now\n  }\n  if (DEBUG) assert((block.mmInfo & ~TAGS_MASK) >= payloadSize); // must fit\n  removeBlock(root, block);\n  prepareBlock(root, block, payloadSize);\n  if (isDefined(ASC_RTRACE)) onalloc(block);\n  return block;\n}\n\n/** Reallocates a block to the specified size. */\nexport function reallocateBlock(root: Root, block: Block, size: usize): Block {\n  let payloadSize = prepareSize(size);\n  let blockInfo = block.mmInfo;\n  let blockSize = blockInfo & ~TAGS_MASK;\n\n  // possibly split and update runtime size if it still fits\n  if (payloadSize <= blockSize) {\n    prepareBlock(root, block, payloadSize);\n    if (isDefined(ASC_RTRACE)) {\n      if (payloadSize != blockSize) onresize(block, BLOCK_OVERHEAD + blockSize);\n    }\n    return block;\n  }\n\n  // merge with right free block if merger is large enough\n  let right = GETRIGHT(block);\n  let rightInfo = right.mmInfo;\n  if (rightInfo & FREE) {\n    let mergeSize = blockSize + BLOCK_OVERHEAD + (rightInfo & ~TAGS_MASK);\n    if (mergeSize >= payloadSize) {\n      removeBlock(root, right);\n      block.mmInfo = (blockInfo & TAGS_MASK) | mergeSize;\n      prepareBlock(root, block, payloadSize);\n      if (isDefined(ASC_RTRACE)) onresize(block, BLOCK_OVERHEAD + blockSize);\n      return block;\n    }\n  }\n\n  // otherwise move the block\n  return moveBlock(root, block, size);\n}\n\n/** Moves a block to a new one of the specified size. */\nfunction moveBlock(root: Root, block: Block, newSize: usize): Block {\n  let newBlock = allocateBlock(root, newSize);\n  memory.copy(changetype<usize>(newBlock) + BLOCK_OVERHEAD, changetype<usize>(block) + BLOCK_OVERHEAD, block.mmInfo & ~TAGS_MASK);\n  if (changetype<usize>(block) >= __heap_base) {\n    if (isDefined(ASC_RTRACE)) onmove(block, newBlock);\n    freeBlock(root, block);\n  }\n  return newBlock;\n}\n\n/** Frees a block. */\nexport function freeBlock(root: Root, block: Block): void {\n  if (isDefined(ASC_RTRACE)) onfree(block);\n  block.mmInfo = block.mmInfo | FREE;\n  insertBlock(root, block);\n}\n\n/** Checks that a used block is valid to be freed or reallocated. */\nfunction checkUsedBlock(ptr: usize): Block {\n  let block = changetype<Block>(ptr - BLOCK_OVERHEAD);\n  assert(\n    ptr != 0 && !(ptr & AL_MASK) &&  // must exist and be aligned\n    !(block.mmInfo & FREE)           // must be used\n  );\n  return block;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __alloc(size: usize): usize {\n  if (!ROOT) initialize();\n  return changetype<usize>(allocateBlock(ROOT, size)) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __realloc(ptr: usize, size: usize): usize {\n  if (!ROOT) initialize();\n  return (ptr < __heap_base\n    ? changetype<usize>(moveBlock(ROOT, checkUsedBlock(ptr), size))\n    : changetype<usize>(reallocateBlock(ROOT, checkUsedBlock(ptr), size))\n  ) + BLOCK_OVERHEAD;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __free(ptr: usize): void {\n  if (ptr < __heap_base) return;\n  if (!ROOT) initialize();\n  freeBlock(ROOT, checkUsedBlock(ptr));\n}\n","// This file is shared with the compiler and must remain portable\n\n//  Typeinfo interpretation \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n//   __rtti_base\n//                              count                             \n//  \n//                       Typeinfo#flags [id=0]                     id < count\n// \n//                               ...                              \n\n/** Runtime type information data structure. */\n@unmanaged\nexport class Typeinfo {\n  /** Flags describing the shape of this class type. */\n  flags: TypeinfoFlags = TypeinfoFlags.NONE;\n}\n\n/** Runtime type information flags. */\nexport const enum TypeinfoFlags {\n  /** No specific flags. */\n  NONE = 0,\n  /** Type is an `ArrayBufferView`. */\n  ARRAYBUFFERVIEW = 1 << 0,\n  /** Type is an `Array`. */\n  ARRAY = 1 << 1,\n  /** Type is a `StaticArray`. */\n  STATICARRAY = 1 << 2,\n  /** Type is a `Set`. */\n  SET = 1 << 3,\n  /** Type is a `Map`. */\n  MAP = 1 << 4,\n  /** Type has no outgoing pointers. */\n  POINTERFREE = 1 << 5,\n  /** Value alignment of 1 byte. */\n  VALUE_ALIGN_0 = 1 << 6,\n  /** Value alignment of 2 bytes. */\n  VALUE_ALIGN_1 = 1 << 7,\n  /** Value alignment of 4 bytes. */\n  VALUE_ALIGN_2 = 1 << 8,\n  /** Value alignment of 8 bytes. */\n  VALUE_ALIGN_3 = 1 << 9,\n  /** Value alignment of 16 bytes. */\n  VALUE_ALIGN_4 = 1 << 10,\n  /** Value is a signed type. */\n  VALUE_SIGNED = 1 << 11,\n  /** Value is a float type. */\n  VALUE_FLOAT = 1 << 12,\n  /** Value type is nullable. */\n  VALUE_NULLABLE = 1 << 13,\n  /** Value type is managed. */\n  VALUE_MANAGED = 1 << 14,\n  /** Key alignment of 1 byte. */\n  KEY_ALIGN_0 = 1 << 15,\n  /** Key alignment of 2 bytes. */\n  KEY_ALIGN_1 = 1 << 16,\n  /** Key alignment of 4 bytes. */\n  KEY_ALIGN_2 = 1 << 17,\n  /** Key alignment of 8 bytes. */\n  KEY_ALIGN_3 = 1 << 18,\n  /** Key alignment of 16 bytes. */\n  KEY_ALIGN_4 = 1 << 19,\n  /** Key is a signed type. */\n  KEY_SIGNED = 1 << 20,\n  /** Key is a float type. */\n  KEY_FLOAT = 1 << 21,\n  /** Key type is nullable. */\n  KEY_NULLABLE = 1 << 22,\n  /** Key type is managed. */\n  KEY_MANAGED = 1 << 23\n}\n","import { BLOCK, BLOCK_OVERHEAD, OBJECT_OVERHEAD, OBJECT_MAXSIZE, TOTAL_OVERHEAD, DEBUG, TRACE, RTRACE, PROFILE } from \"./common\";\nimport { onvisit, oncollect, oninterrupt, onyield } from \"./rtrace\";\nimport { TypeinfoFlags } from \"../shared/typeinfo\";\nimport { E_ALLOCATION_TOO_LARGE, E_ALREADY_PINNED, E_NOT_PINNED } from \"../util/error\";\n\n// === ITCMS: An incremental Tri-Color Mark & Sweep garbage collector ===\n// Adapted from Bach Le's gc, see: https://github.com/bullno1/ugc\n\n//  Colors \n//  Color        Meaning                                         \n// \n//  WHITE*       Unprocessed                                     \n//  BLACK*       Processed                                       \n//  GRAY         Processed with unprocessed children             \n//  TRANSPARENT  Manually pinned (always reachable)              \n// \n// * flipped between cycles\n\n// @ts-ignore: decorator\n@lazy let white = 0;\n// @ts-ignore: decorator\n@inline const gray = 2;\n// @ts-ignore: decorator\n@inline const transparent = 3;\n// @ts-ignore: decorator\n@inline const COLOR_MASK = 3;\n\n/** Size in memory of all objects currently managed by the GC. */\n// @ts-ignore: decorator\n@lazy let total: usize = 0;\n\n/** Currently transitioning from SWEEP to MARK state. */\n// @ts-ignore: decorator\n@inline const STATE_IDLE = 0;\n/** Currently marking reachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_MARK = 1;\n/** Currently sweeping unreachable objects. */\n// @ts-ignore: decorator\n@inline const STATE_SWEEP = 2;\n/** Current collector state. */\n// @ts-ignore: decorator\n@lazy let state = STATE_IDLE;\n\n// @ts-ignore: decorator\n@lazy let fromSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let toSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let pinSpace = initLazy(changetype<Object>(memory.data(offsetof<Object>())));\n// @ts-ignore: decorator\n@lazy let iter: Object = changetype<Object>(0); // unsafe initializion below\n\nfunction initLazy(space: Object): Object {\n  space.nextWithColor = changetype<usize>(space);\n  space.prev = space;\n  return space;\n}\n\n/** Visit cookie indicating scanning of an object. */\n// @ts-ignore: decorator\n@inline const VISIT_SCAN = 0;\n\n//  Managed object layout (32-bit) \n//    3                   2                   1\n//  1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0 9 8 7 6 5 4 3 2 1 0  bits\n// \n//                       Memory manager block                     \n// \n//                               next                          C  = nextWithColor\n// \n//                               prev                             \n// \n//                               rtId                             \n// \n//                               rtSize                           \n// >ptr\n//                                ...                             \n// C: color\n\n/** Represents a managed object in memory, consisting of a header followed by the object's data. */\n@unmanaged class Object extends BLOCK {\n  /** Pointer to the next object with color flags stored in the alignment bits. */\n  nextWithColor: usize; // *u32\n  /** Pointer to the previous object. */\n  prev: Object; // *u32\n  /** Runtime id. */\n  rtId: u32;\n  /** Runtime size. */\n  rtSize: u32;\n\n  /** Gets the pointer to the next object. */\n  get next(): Object {\n    return changetype<Object>(this.nextWithColor & ~COLOR_MASK);\n  }\n\n  /** Sets the pointer to the next object. */\n  set next(obj: Object) {\n    this.nextWithColor = changetype<usize>(obj) | (this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Gets this object's color. */\n  get color(): i32 {\n    return i32(this.nextWithColor & COLOR_MASK);\n  }\n\n  /** Sets this object's color. */\n  set color(color: i32) {\n    this.nextWithColor = (this.nextWithColor & ~COLOR_MASK) | color;\n  }\n\n  /** Gets the size of this object in memory. */\n  get size(): usize {\n    return BLOCK_OVERHEAD + (this.mmInfo & ~3);\n  }\n\n  /** Tests if this object is pointerfree. */\n  get isPointerfree(): bool {\n    let rtId = this.rtId;\n    // 0: Object, 1: ArrayBuffer, 2: String\n    return rtId <= idof<string>() || (__typeinfo(rtId) & TypeinfoFlags.POINTERFREE) != 0;\n  }\n\n  /** Unlinks this object from its list. */\n  unlink(): void {\n    let next = this.next;\n    if (next == null) {\n      if (DEBUG) assert(this.prev == null && changetype<usize>(this) < __heap_base);\n      return; // static data not yet linked\n    }\n    let prev = this.prev;\n    if (DEBUG) assert(prev);\n    next.prev = prev;\n    prev.next = next;\n  }\n\n  /** Links this object to the specified list, with the given color. */\n  linkTo(list: Object, withColor: i32): void {\n    let prev = list.prev;\n    this.nextWithColor = changetype<usize>(list) | withColor;\n    this.prev = prev;\n    prev.next = this;\n    list.prev = this;\n  }\n\n  /** Marks this object as gray, that is reachable with unscanned children. */\n  makeGray(): void {\n    if (this == iter) iter = assert(this.prev);\n    this.unlink();\n    this.linkTo(toSpace, this.isPointerfree ? i32(!white) : gray);\n  }\n}\n\n/** Visits all objects considered to be program roots. */\nfunction visitRoots(cookie: u32): void {\n  __visit_globals(cookie);\n  let pn = pinSpace;\n  let iter = pn.next;\n  while (iter != pn) {\n    if (DEBUG) assert(iter.color == transparent);\n    __visit_members(changetype<usize>(iter) + TOTAL_OVERHEAD, cookie);\n    iter = iter.next;\n  }\n}\n\n/** Visits all objects on the stack. */\nfunction visitStack(cookie: u32): void {\n  let ptr = __stack_pointer;\n  while (ptr < __heap_base) {\n    __visit(load<usize>(ptr), cookie);\n    ptr += sizeof<usize>();\n  }\n}\n\n/** Performs a single step according to the current state. */\nfunction step(): usize {\n  // Magic constants responsible for pause times. Obtained experimentally\n  // using the compiler compiling itself. 2048 budget pro run by default.\n  const MARKCOST = isDefined(ASC_GC_MARKCOST) ? ASC_GC_MARKCOST : 1;\n  const SWEEPCOST = isDefined(ASC_GC_SWEEPCOST) ? ASC_GC_SWEEPCOST : 10;\n  let obj: Object;\n  switch (state) {\n    case STATE_IDLE: {\n      state = STATE_MARK;\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      iter = toSpace;\n      return visitCount * MARKCOST;\n    }\n    case STATE_MARK: {\n      let black = i32(!white);\n      obj = iter.next;\n      while (obj != toSpace) {\n        iter = obj;\n        if (obj.color != black) { // skip already-blacks (pointerfree)\n          obj.color = black;\n          visitCount = 0;\n          __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          return visitCount * MARKCOST;\n        }\n        obj = obj.next;\n      }\n      visitCount = 0;\n      visitRoots(VISIT_SCAN);\n      obj = iter.next;\n      if (obj == toSpace) {\n        visitStack(VISIT_SCAN);\n        obj = iter.next;\n        while (obj != toSpace) {\n          if (obj.color != black) {\n            obj.color = black;\n            __visit_members(changetype<usize>(obj) + TOTAL_OVERHEAD, VISIT_SCAN);\n          }\n          obj = obj.next;\n        }\n        let from = fromSpace;\n        fromSpace = toSpace;\n        toSpace = from;\n        white = black;\n        iter = from.next;\n        state = STATE_SWEEP;\n      }\n      return visitCount * MARKCOST;\n    }\n    case STATE_SWEEP: {\n      obj = iter;\n      if (obj != toSpace) {\n        iter = obj.next;\n        if (DEBUG) assert(obj.color == i32(!white)); // old white\n        free(obj);\n        return SWEEPCOST;\n      }\n      toSpace.nextWithColor = changetype<usize>(toSpace);\n      toSpace.prev = toSpace;\n      state = STATE_IDLE;\n      break;\n    }\n  }\n  return 0;\n}\n\n/** Frees an object. */\nfunction free(obj: Object): void {\n  if (changetype<usize>(obj) < __heap_base) {\n    obj.nextWithColor = 0; // may become linked again\n    obj.prev = changetype<Object>(0);\n  } else {\n    total -= obj.size;\n    if (isDefined(__finalize)) {\n      __finalize(changetype<usize>(obj) + TOTAL_OVERHEAD);\n    }\n    __free(changetype<usize>(obj) + BLOCK_OVERHEAD);\n  }\n}\n\n// Garbage collector interface\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __new(size: usize, id: i32): usize {\n  if (size >= OBJECT_MAXSIZE) throw new Error(E_ALLOCATION_TOO_LARGE);\n  if (total >= threshold) interrupt();\n  let obj = changetype<Object>(__alloc(OBJECT_OVERHEAD + size) - BLOCK_OVERHEAD);\n  obj.rtId = id;\n  obj.rtSize = <u32>size;\n  obj.linkTo(fromSpace, white); // inits next/prev\n  total += obj.size;\n  let ptr = changetype<usize>(obj) + TOTAL_OVERHEAD;\n  // may be visited before being fully initialized, so must fill\n  memory.fill(ptr, 0, size);\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __renew(oldPtr: usize, size: usize): usize {\n  let oldObj = changetype<Object>(oldPtr - TOTAL_OVERHEAD);\n  // Update object size if its block is large enough\n  if (size <= (oldObj.mmInfo & ~3) - OBJECT_OVERHEAD) {\n    oldObj.rtSize = <u32>size;\n    return oldPtr;\n  }\n  // If not the same object anymore, we have to move it move it due to the\n  // shadow stack potentially still referencing the old object\n  let newPtr = __new(size, oldObj.rtId);\n  memory.copy(newPtr, oldPtr, min(size, oldObj.rtSize));\n  return newPtr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void {\n  // Write barrier is unnecessary if non-incremental\n  if (!childPtr) return;\n  if (DEBUG) assert(parentPtr);\n  let child = changetype<Object>(childPtr - TOTAL_OVERHEAD);\n  if (child.color == white) {\n    let parent = changetype<Object>(parentPtr - TOTAL_OVERHEAD);\n    let parentColor = parent.color;\n    if (parentColor == i32(!white)) {\n      // Maintain the invariant that no black object may point to a white object.\n      if (expectMultiple) {\n        // Move the barrier \"backward\". Suitable for containers receiving multiple stores.\n        // Avoids a barrier for subsequent objects stored into the same container.\n        parent.makeGray();\n      } else {\n        // Move the barrier \"forward\". Suitable for objects receiving isolated stores.\n        child.makeGray();\n      }\n    } else if (parentColor == transparent && state == STATE_MARK) {\n      // Pinned objects are considered 'black' during the mark phase.\n      child.makeGray();\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@lazy let visitCount = 0;\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __visit(ptr: usize, cookie: i32): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (RTRACE) if (!onvisit(obj)) return;\n  if (obj.color == white) {\n    obj.makeGray();\n    ++visitCount;\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __pin(ptr: usize): usize {\n  if (ptr) {\n    let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n    if (obj.color == transparent) {\n      throw new Error(E_ALREADY_PINNED);\n    }\n    obj.unlink(); // from fromSpace\n    obj.linkTo(pinSpace, transparent);\n  }\n  return ptr;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __unpin(ptr: usize): void {\n  if (!ptr) return;\n  let obj = changetype<Object>(ptr - TOTAL_OVERHEAD);\n  if (obj.color != transparent) {\n    throw new Error(E_NOT_PINNED);\n  }\n  if (state == STATE_MARK) {\n    // We may be right at the point after marking roots for the second time and\n    // entering the sweep phase, in which case the object would be missed if it\n    // is not only pinned but also a root. Make sure it isn't missed.\n    obj.makeGray();\n  } else {\n    obj.unlink();\n    obj.linkTo(fromSpace, white);\n  }\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nexport function __collect(): void {\n  if (TRACE) trace(\"GC (full) at\", 1, total);\n  if (state > STATE_IDLE) {\n    // finish current cycle\n    while (state != STATE_IDLE) step();\n  }\n  // perform a full cycle\n  step();\n  while (state != STATE_IDLE) step();\n  threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n  if (TRACE) trace(\"GC (full) done at cur/max\", 2, total, memory.size() << 16);\n  if (RTRACE || PROFILE) oncollect(total);\n}\n\n// Garbage collector automation\n\n/** How often to interrupt. The default of 1024 means \"interrupt each 1024 bytes allocated\". */\n// @ts-ignore: decorator\n@inline const GRANULARITY: usize = isDefined(ASC_GC_GRANULARITY) ? ASC_GC_GRANULARITY : 1024;\n/** How long to interrupt. The default of 200% means \"run at double the speed of allocations\". */\n// @ts-ignore: decorator\n@inline const STEPFACTOR: usize = isDefined(ASC_GC_SWEEPFACTOR) ? ASC_GC_SWEEPFACTOR : 200;\n/** How long to idle. The default of 200% means \"wait for memory to double before kicking in again\". */\n// @ts-ignore: decorator\n@inline const IDLEFACTOR: usize = isDefined(ASC_GC_IDLEFACTOR) ? ASC_GC_IDLEFACTOR : 200;\n\n/** Threshold of memory used by objects to exceed before interrupting again. */\n// @ts-ignore: decorator\n@lazy let threshold: usize = ((<usize>memory.size() << 16) - __heap_base) >> 1;\n\n/** Performs a reasonable amount of incremental GC steps. */\nfunction interrupt(): void {\n  if (PROFILE) oninterrupt(total);\n  if (TRACE) trace(\"GC (auto) at\", 1, total);\n  let budget: isize = GRANULARITY * STEPFACTOR / 100;\n  do {\n    budget -= step();\n    if (state == STATE_IDLE) {\n      if (TRACE) trace(\" GC (auto) done at cur/max\", 2, total, memory.size() << 16);\n      threshold = <usize>(<u64>total * IDLEFACTOR / 100) + GRANULARITY;\n      if (PROFILE) onyield(total);\n      return;\n    }\n  } while (budget > 0);\n  if (TRACE) trace(\" GC (auto) ongoing at\", 1, total);\n  threshold = total + GRANULARITY * usize(total - threshold < GRANULARITY);\n  if (PROFILE) onyield(total);\n}\n","/// <reference path=\"../rt/index.d.ts\" />\n\nimport { idof } from \"../builtins\";\nimport { CharCode } from \"./string\";\n\n// @ts-ignore: decorator\n@inline\nexport const MAX_DOUBLE_LENGTH = 28;\n\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<u32>([\n  1,\n  10,\n  100,\n  1000,\n  10000,\n  100000,\n  1000000,\n  10000000,\n  100000000,\n  1000000000\n]);\n\n/*\n  Lookup table for pairwise char codes in range [0-99]\n\n  \"00\", \"01\", \"02\", \"03\", \"04\", \"05\", \"06\", \"07\", \"08\", \"09\",\n  \"10\", \"11\", \"12\", \"13\", \"14\", \"15\", \"16\", \"17\", \"18\", \"19\",\n  \"20\", \"21\", \"22\", \"23\", \"24\", \"25\", \"26\", \"27\", \"28\", \"29\",\n  \"30\", \"31\", \"32\", \"33\", \"34\", \"35\", \"36\", \"37\", \"38\", \"39\",\n  \"40\", \"41\", \"42\", \"43\", \"44\", \"45\", \"46\", \"47\", \"48\", \"49\",\n  \"50\", \"51\", \"52\", \"53\", \"54\", \"55\", \"56\", \"57\", \"58\", \"59\",\n  \"60\", \"61\", \"62\", \"63\", \"64\", \"65\", \"66\", \"67\", \"68\", \"69\",\n  \"70\", \"71\", \"72\", \"73\", \"74\", \"75\", \"76\", \"77\", \"78\", \"79\",\n  \"80\", \"81\", \"82\", \"83\", \"84\", \"85\", \"86\", \"87\", \"88\", \"89\",\n  \"90\", \"91\", \"92\", \"93\", \"94\", \"95\", \"96\", \"97\", \"98\", \"99\"\n*/\n// @ts-ignore: decorator\n@lazy @inline const DIGITS = memory.data<u32>([\n  0x00300030, 0x00310030, 0x00320030, 0x00330030, 0x00340030,\n  0x00350030, 0x00360030, 0x00370030, 0x00380030, 0x00390030,\n  0x00300031, 0x00310031, 0x00320031, 0x00330031, 0x00340031,\n  0x00350031, 0x00360031, 0x00370031, 0x00380031, 0x00390031,\n  0x00300032, 0x00310032, 0x00320032, 0x00330032, 0x00340032,\n  0x00350032, 0x00360032, 0x00370032, 0x00380032, 0x00390032,\n  0x00300033, 0x00310033, 0x00320033, 0x00330033, 0x00340033,\n  0x00350033, 0x00360033, 0x00370033, 0x00380033, 0x00390033,\n  0x00300034, 0x00310034, 0x00320034, 0x00330034, 0x00340034,\n  0x00350034, 0x00360034, 0x00370034, 0x00380034, 0x00390034,\n  0x00300035, 0x00310035, 0x00320035, 0x00330035, 0x00340035,\n  0x00350035, 0x00360035, 0x00370035, 0x00380035, 0x00390035,\n  0x00300036, 0x00310036, 0x00320036, 0x00330036, 0x00340036,\n  0x00350036, 0x00360036, 0x00370036, 0x00380036, 0x00390036,\n  0x00300037, 0x00310037, 0x00320037, 0x00330037, 0x00340037,\n  0x00350037, 0x00360037, 0x00370037, 0x00380037, 0x00390037,\n  0x00300038, 0x00310038, 0x00320038, 0x00330038, 0x00340038,\n  0x00350038, 0x00360038, 0x00370038, 0x00380038, 0x00390038,\n  0x00300039, 0x00310039, 0x00320039, 0x00330039, 0x00340039,\n  0x00350039, 0x00360039, 0x00370039, 0x00380039, 0x00390039\n]);\n\n// Lookup table for pairwise char codes in range [0x00-0xFF]\n// @ts-ignore: decorator\n@lazy @inline const HEX_DIGITS =\n\"000102030405060708090a0b0c0d0e0f\\\n101112131415161718191a1b1c1d1e1f\\\n202122232425262728292a2b2c2d2e2f\\\n303132333435363738393a3b3c3d3e3f\\\n404142434445464748494a4b4c4d4e4f\\\n505152535455565758595a5b5c5d5e5f\\\n606162636465666768696a6b6c6d6e6f\\\n707172737475767778797a7b7c7d7e7f\\\n808182838485868788898a8b8c8d8e8f\\\n909192939495969798999a9b9c9d9e9f\\\na0a1a2a3a4a5a6a7a8a9aaabacadaeaf\\\nb0b1b2b3b4b5b6b7b8b9babbbcbdbebf\\\nc0c1c2c3c4c5c6c7c8c9cacbcccdcecf\\\nd0d1d2d3d4d5d6d7d8d9dadbdcdddedf\\\ne0e1e2e3e4e5e6e7e8e9eaebecedeeef\\\nf0f1f2f3f4f5f6f7f8f9fafbfcfdfeff\";\n\n// @ts-ignore: decorator\n@lazy @inline const ANY_DIGITS = \"0123456789abcdefghijklmnopqrstuvwxyz\";\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_POWERS = memory.data<i16>([/* eslint-disable indent */\n  -1220, -1193, -1166, -1140, -1113, -1087, -1060, -1034, -1007,  -980,\n   -954,  -927,  -901,  -874,  -847,  -821,  -794,  -768,  -741,  -715,\n   -688,  -661,  -635,  -608,  -582,  -555,  -529,  -502,  -475,  -449,\n   -422,  -396,  -369,  -343,  -316,  -289,  -263,  -236,  -210,  -183,\n   -157,  -130,  -103,   -77,   -50,   -24,     3,    30,    56,    83,\n    109,   136,   162,   189,   216,   242,   269,   295,   322,   348,\n    375,   402,   428,   455,   481,   508,   534,   561,   588,   614,\n    641,   667,   694,   720,   747,   774,   800,   827,   853,   880,\n    907,   933,   960,   986,  1013,  1039,  1066\n/* eslint-enable indent */]);\n\n// 1e-348, 1e-340, ..., 1e340\n// @ts-ignore: decorator\n@lazy @inline const FRC_POWERS = memory.data<u64>([\n  0xFA8FD5A0081C0288, 0xBAAEE17FA23EBF76, 0x8B16FB203055AC76, 0xCF42894A5DCE35EA,\n  0x9A6BB0AA55653B2D, 0xE61ACF033D1A45DF, 0xAB70FE17C79AC6CA, 0xFF77B1FCBEBCDC4F,\n  0xBE5691EF416BD60C, 0x8DD01FAD907FFC3C, 0xD3515C2831559A83, 0x9D71AC8FADA6C9B5,\n  0xEA9C227723EE8BCB, 0xAECC49914078536D, 0x823C12795DB6CE57, 0xC21094364DFB5637,\n  0x9096EA6F3848984F, 0xD77485CB25823AC7, 0xA086CFCD97BF97F4, 0xEF340A98172AACE5,\n  0xB23867FB2A35B28E, 0x84C8D4DFD2C63F3B, 0xC5DD44271AD3CDBA, 0x936B9FCEBB25C996,\n  0xDBAC6C247D62A584, 0xA3AB66580D5FDAF6, 0xF3E2F893DEC3F126, 0xB5B5ADA8AAFF80B8,\n  0x87625F056C7C4A8B, 0xC9BCFF6034C13053, 0x964E858C91BA2655, 0xDFF9772470297EBD,\n  0xA6DFBD9FB8E5B88F, 0xF8A95FCF88747D94, 0xB94470938FA89BCF, 0x8A08F0F8BF0F156B,\n  0xCDB02555653131B6, 0x993FE2C6D07B7FAC, 0xE45C10C42A2B3B06, 0xAA242499697392D3,\n  0xFD87B5F28300CA0E, 0xBCE5086492111AEB, 0x8CBCCC096F5088CC, 0xD1B71758E219652C,\n  0x9C40000000000000, 0xE8D4A51000000000, 0xAD78EBC5AC620000, 0x813F3978F8940984,\n  0xC097CE7BC90715B3, 0x8F7E32CE7BEA5C70, 0xD5D238A4ABE98068, 0x9F4F2726179A2245,\n  0xED63A231D4C4FB27, 0xB0DE65388CC8ADA8, 0x83C7088E1AAB65DB, 0xC45D1DF942711D9A,\n  0x924D692CA61BE758, 0xDA01EE641A708DEA, 0xA26DA3999AEF774A, 0xF209787BB47D6B85,\n  0xB454E4A179DD1877, 0x865B86925B9BC5C2, 0xC83553C5C8965D3D, 0x952AB45CFA97A0B3,\n  0xDE469FBD99A05FE3, 0xA59BC234DB398C25, 0xF6C69A72A3989F5C, 0xB7DCBF5354E9BECE,\n  0x88FCF317F22241E2, 0xCC20CE9BD35C78A5, 0x98165AF37B2153DF, 0xE2A0B5DC971F303A,\n  0xA8D9D1535CE3B396, 0xFB9B7CD9A4A7443C, 0xBB764C4CA7A44410, 0x8BAB8EEFB6409C1A,\n  0xD01FEF10A657842C, 0x9B10A4E5E9913129, 0xE7109BFBA19C0C9D, 0xAC2820D9623BF429,\n  0x80444B5E7AA7CF85, 0xBF21E44003ACDD2D, 0x8E679C2F5E44FF8F, 0xD433179D9C8CB841,\n  0x9E19DB92B4E31BA9, 0xEB96BF6EBADF77D9, 0xAF87023B9BF0EE6B\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function isPowerOf2<T extends number>(value: T): bool {\n  return popcnt<T>(value) == 1;\n}\n\n// Count number of decimals for u32 values\n// In our case input value always non-zero so we can simplify some parts\nexport function decimalCount32(value: u32): u32 {\n  if (value < 100000) {\n    if (value < 100) {\n      return 1 + u32(value >= 10);\n    } else {\n      return 3 + u32(value >= 10000) + u32(value >= 1000);\n    }\n  } else {\n    if (value < 10000000) {\n      return 6 + u32(value >= 1000000);\n    } else {\n      return 8 + u32(value >= 1000000000) + u32(value >= 100000000);\n    }\n  }\n}\n\n// Count number of decimals for u64 values\n// In our case input value always greater than 2^32-1 so we can skip some parts\nexport function decimalCount64High(value: u64): u32 {\n  if (value < 1000000000000000) {\n    if (value < 1000000000000) {\n      return 10 + u32(value >= 100000000000) + u32(value >= 10000000000);\n    } else {\n      return 13 + u32(value >= 100000000000000) + u32(value >= 10000000000000);\n    }\n  } else {\n    if (value < 100000000000000000) {\n      return 16 + u32(value >= 10000000000000000);\n    } else {\n      return 18 + u32(value >= 10000000000000000000) + u32(value >= 1000000000000000000);\n    }\n  }\n}\n\nfunction ulog_base(num: u64, base: i32): u32 {\n  if (isPowerOf2(base)) {\n    return (63 - <u32>clz(num)) / (31 - <u32>clz(base)) + 1;\n  }\n  let b64 = u64(base), b = b64, e: u32 = 1;\n  while (num >= b) {\n    num /= b;\n    b *= b;\n    e <<= 1;\n  }\n  while (num >= 1) {\n    num /= b64;\n    e++;\n  }\n  return e - 1;\n}\n\nfunction utoa32_dec_lut(buffer: usize, num: u32, offset: usize): void {\n  while (num >= 10000) {\n    // in most VMs i32/u32 div and modulo by constant can be shared and simplificate\n    let t = num / 10000;\n    let r = num % 10000;\n    num = t;\n\n    let d1 = r / 100;\n    let d2 = r % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>d2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  if (num >= 100) {\n    let t  = num / 100;\n    let d1 = num % 100;\n    num = t;\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>d1 << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  }\n\n  if (num >= 10) {\n    offset -= 2;\n    let digits = load<u32>(DIGITS + (<usize>num << alignof<u32>()));\n    store<u32>(buffer + (offset << 1), digits);\n  } else {\n    offset -= 1;\n    let digit = CharCode._0 + num;\n    store<u16>(buffer + (offset << 1), digit);\n  }\n}\n\nfunction utoa64_dec_lut(buffer: usize, num: u64, offset: usize): void {\n  while (num >= 100000000) {\n    let t = num / 100000000;\n    let r = <usize>(num - t * 100000000);\n    num = t;\n\n    let b = r / 10000;\n    let c = r % 10000;\n\n    let b1 = b / 100;\n    let b2 = b % 100;\n    let c1 = c / 100;\n    let c2 = c % 100;\n\n    let digits1 = <u64>load<u32>(DIGITS + (<usize>c1 << alignof<u32>()));\n    let digits2 = <u64>load<u32>(DIGITS + (<usize>c2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n\n    digits1 = <u64>load<u32>(DIGITS + (<usize>b1 << alignof<u32>()));\n    digits2 = <u64>load<u32>(DIGITS + (<usize>b2 << alignof<u32>()));\n\n    offset -= 4;\n    store<u64>(buffer + (offset << 1), digits1 | (digits2 << 32));\n  }\n\n  utoa32_dec_lut(buffer, <u32>num, offset);\n}\n\nfunction utoa_hex_lut(buffer: usize, num: u64, offset: usize): void {\n  const lut = changetype<usize>(HEX_DIGITS);\n  while (offset >= 2) {\n    offset -= 2;\n    store<u32>(\n      buffer + (offset << 1),\n      load<u32>(lut + ((<usize>num & 0xFF) << alignof<u32>()))\n    );\n    num >>= 8;\n  }\n  if (offset & 1) {\n    store<u16>(buffer, load<u16>(lut + (<usize>num << 6)));\n  }\n}\n\nfunction utoa_dec_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let t = num / 10;\n    let r = <u32>(num % 10);\n    num = changetype<T>(t);\n    offset--;\n    store<u16>(buffer + (offset << 1), CharCode._0 + r);\n  } while (num);\n}\n\nfunction utoa_hex_simple<T extends number>(buffer: usize, num: T, offset: usize): void {\n  do {\n    let d = num & 0x0F | CharCode._0;\n    d += select<T>(<T>0x27, <T>0, d > <T>CharCode._9);\n    offset--;\n    store<u16>(buffer + (offset << 1), d);\n    // @ts-ignore: type\n    num >>= 4;\n  } while (num);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function utoa32_dec_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u32>(buffer, num, offset);\n  } else {\n    utoa32_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa32_hex_core(buffer: usize, num: u32, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u32>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_dec_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_dec_simple<u64>(buffer, num, offset);\n  } else {\n    utoa64_dec_lut(buffer, num, offset);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction utoa64_hex_core(buffer: usize, num: u64, offset: usize): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    utoa_hex_simple<u64>(buffer, num, offset);\n  } else {\n    utoa_hex_lut(buffer, num, offset);\n  }\n}\n\nfunction utoa64_any_core(buffer: usize, num: u64, offset: usize, radix: i32): void {\n  const lut = changetype<usize>(ANY_DIGITS);\n  let base = u64(radix);\n  if ((radix & (radix - 1)) == 0) { // for radix which pow of two\n    let shift = u64(ctz(radix) & 7);\n    let mask = base - 1;\n    do {\n      offset--;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num & mask) << 1)));\n      num >>= shift;\n    } while (num);\n  } else {\n    do {\n      offset--;\n      let q = num / base;\n      store<u16>(buffer + (offset << 1), load<u16>(lut + (usize(num - q * base) << 1)));\n      num = q;\n    } while (num);\n  }\n}\n\nexport function utoa32(value: u32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out), value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa32(value: i32, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = (value >>> 31) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    let decimals = decimalCount32(value);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_dec_core(changetype<usize>(out) + sign, value, decimals);\n  } else if (radix == 16) {\n    let decimals = (31 - clz(value) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa32_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let val32 = u32(value);\n    let decimals = ulog_base(val32, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, val32, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\nexport function utoa64(value: u64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n  let out: String;\n\n  if (radix == 10) {\n    if (value <= u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out), val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new(decimals << 1, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out), value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out), value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new(decimals << 1, idof<String>()));\n    utoa64_any_core(changetype<usize>(out), value, decimals, radix);\n  }\n  return out;\n}\n\nexport function itoa64(value: i64, radix: i32): String {\n  if (radix < 2 || radix > 36) {\n    throw new RangeError(\"toString() radix argument must be between 2 and 36\");\n  }\n  if (!value) return \"0\";\n\n  let sign = u32(value >>> 63) << 1;\n  if (sign) value = -value;\n  let out: String;\n\n  if (radix == 10) {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32    = <u32>value;\n      let decimals = decimalCount32(val32);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa32_dec_core(changetype<usize>(out) + sign, val32, decimals);\n    } else {\n      let decimals = decimalCount64High(value);\n      out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n      utoa64_dec_core(changetype<usize>(out) + sign, value, decimals);\n    }\n  } else if (radix == 16) {\n    let decimals = (63 - u32(clz(value)) >> 2) + 1;\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_hex_core(changetype<usize>(out) + sign, value, decimals);\n  } else {\n    let decimals = ulog_base(value, radix);\n    out = changetype<String>(__new((decimals << 1) + sign, idof<String>()));\n    utoa64_any_core(changetype<usize>(out) + sign, value, decimals, radix);\n  }\n  if (sign) store<u16>(changetype<usize>(out), CharCode.MINUS);\n  return out;\n}\n\n// @ts-ignore: decorator\n@lazy let _K: i32 = 0;\n\n// // @ts-ignore: decorator\n// @lazy\n// let _frc: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp: i32 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_minus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_plus: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _frc_pow: u64 = 0;\n\n// @ts-ignore: decorator\n@lazy let _exp_pow: i32 = 0;\n\n// @ts-ignore: decorator\n@inline\nfunction umul64f(u: u64, v: u64): u64 {\n  let u0 = u & 0xFFFFFFFF;\n  let v0 = v & 0xFFFFFFFF;\n\n  let u1 = u >> 32;\n  let v1 = v >> 32;\n\n  let l = u0 * v0;\n  let t = u1 * v0 + (l >> 32);\n  let w = u0 * v1 + (t & 0xFFFFFFFF);\n\n  w += 0x7FFFFFFF; // rounding\n\n  t >>= 32;\n  w >>= 32;\n\n  return u1 * v1 + t + w;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction umul64e(e1: i32, e2: i32): i32 {\n  return e1 + e2 + 64; // where 64 is significand size\n}\n\n// @ts-ignore: decorator\n@inline\nfunction normalizedBoundaries(f: u64, e: i32, isSingle: bool): void {\n  let frc = (f << 1) + 1;\n  let exp = e - 1;\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let m = 1 + i32(f == (isSingle ? 0x00800000 : 0x0010000000000000));\n\n  _frc_plus  = frc;\n  _frc_minus = ((f << m) - 1) << e - m - exp;\n  _exp = exp;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisuRound(buffer: usize, len: i32, delta: u64, rest: u64, ten_kappa: u64, wp_w: u64): void {\n  let lastp = buffer + ((len - 1) << 1);\n  let digit = load<u16>(lastp);\n  while (\n    rest < wp_w &&\n    delta - rest >= ten_kappa && (\n      rest + ten_kappa < wp_w ||\n      wp_w - rest > rest + ten_kappa - wp_w\n    )\n  ) {\n    --digit;\n    rest += ten_kappa;\n  }\n  store<u16>(lastp, digit);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction getCachedPower(minExp: i32): void {\n  const c = reinterpret<f64>(0x3FD34413509F79FE); // 1 / lg(10) = 0.30102999566398114\n  let dk = (-61 - minExp) * c + 347;\t            // dk must be positive, so can do ceiling in positive\n  let k = <i32>dk;\n  k += i32(k != dk); // conversion with ceil\n\n  let index = (k >> 3) + 1;\n  _K = 348 - (index << 3);\t// decimal exponent no need lookup table\n  _frc_pow = load<u64>(FRC_POWERS + (<usize>index << alignof<u64>()));\n  _exp_pow = load<i16>(EXP_POWERS + (<usize>index << alignof<i16>()));\n}\n\n// @ts-ignore: decorator\n@inline\nfunction grisu2(value: f64, buffer: usize, sign: i32, isSingle: bool): i32 {\n  let frc: u64;\n  let exp: i32;\n\n  // frexp routine\n  if (isSingle) {\n    let uv = reinterpret<u32>(<f32>value);\n    exp = (uv & 0x7F800000) >>> 23;\n    let sid = uv & 0x007FFFFF;\n    frc = (u64(exp != 0) << 23) + sid;\n    exp = (exp || 1) - (0x7F + 23);\n  } else {\n    let uv = reinterpret<u64>(value);\n    exp = i32((uv & 0x7FF0000000000000) >>> 52);\n    let sid = uv & 0x000FFFFFFFFFFFFF;\n    frc = (u64(exp != 0) << 52) + sid;\n    exp = (exp || 1) - (0x3FF + 52);\n  }\n\n  normalizedBoundaries(frc, exp, isSingle);\n  getCachedPower(_exp);\n\n  // normalize\n  let off = <i32>clz<u64>(frc);\n  frc <<= off;\n  exp  -= off;\n\n  let frc_pow = _frc_pow;\n  let exp_pow = _exp_pow;\n\n  let w_frc = umul64f(frc, frc_pow);\n  let w_exp = umul64e(exp, exp_pow);\n\n  let wp_frc = umul64f(_frc_plus, frc_pow) - 1;\n  let wp_exp = umul64e(_exp, exp_pow);\n\n  let wm_frc = umul64f(_frc_minus, frc_pow) + 1;\n  let delta  = wp_frc - wm_frc;\n\n  return genDigits(buffer, w_frc, w_exp, wp_frc, wp_exp, delta, sign);\n}\n\nfunction genDigits(buffer: usize, w_frc: u64, w_exp: i32, mp_frc: u64, mp_exp: i32, delta: u64, sign: i32): i32 {\n  let one_exp = -mp_exp;\n  let one_frc = (<u64>1) << one_exp;\n  let mask    = one_frc - 1;\n\n  let wp_w_frc = mp_frc - w_frc;\n\n  let p1 = u32(mp_frc >> one_exp);\n  let p2 = mp_frc & mask;\n\n  let kappa = <i32>decimalCount32(p1);\n  let len = sign;\n\n  while (kappa > 0) {\n    let d: u32;\n    switch (kappa) {\n      case 10: { d = p1 / 1000000000; p1 %= 1000000000; break; }\n      case  9: { d = p1 /  100000000; p1 %=  100000000; break; }\n      case  8: { d = p1 /   10000000; p1 %=   10000000; break; }\n      case  7: { d = p1 /    1000000; p1 %=    1000000; break; }\n      case  6: { d = p1 /     100000; p1 %=     100000; break; }\n      case  5: { d = p1 /      10000; p1 %=      10000; break; }\n      case  4: { d = p1 /       1000; p1 %=       1000; break; }\n      case  3: { d = p1 /        100; p1 %=        100; break; }\n      case  2: { d = p1 /         10; p1 %=         10; break; }\n      case  1: { d = p1;              p1 =           0; break; }\n      default: { d = 0; break; }\n    }\n\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    --kappa;\n    let tmp = ((<u64>p1) << one_exp) + p2;\n    if (tmp <= delta) {\n      _K += kappa;\n      grisuRound(buffer, len, delta, tmp, <u64>load<u32>(POWERS10 + (<usize>kappa << alignof<u32>())) << one_exp, wp_w_frc);\n      return len;\n    }\n  }\n\n  while (true) {\n    p2    *= 10;\n    delta *= 10;\n\n    let d = p2 >> one_exp;\n    if (d | len) store<u16>(buffer + (len++ << 1), CharCode._0 + <u16>d);\n\n    p2 &= mask;\n    --kappa;\n    if (p2 < delta) {\n      _K += kappa;\n      wp_w_frc *= <u64>load<u32>(POWERS10 + (<usize>-kappa << alignof<u32>()));\n      grisuRound(buffer, len, delta, p2, one_frc, wp_w_frc);\n      return len;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nfunction genExponent(buffer: usize, k: i32): i32 {\n  let sign = k < 0;\n  if (sign) k = -k;\n  let decimals = decimalCount32(k) + 1;\n  utoa32_dec_core(buffer, k, decimals);\n  store<u16>(buffer, <u16>select<u32>(CharCode.MINUS, CharCode.PLUS, sign));\n  return decimals;\n}\n\nfunction prettify(buffer: usize, length: i32, k: i32): i32 {\n  if (!k) {\n    store<u32>(buffer + (length << 1), CharCode.DOT | (CharCode._0 << 16));\n    return length + 2;\n  }\n\n  let kk = length + k;\n  if (length <= kk && kk <= 21) {\n    // 1234e7 -> 12340000000\n    for (let i = length; i < kk; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    store<u32>(buffer + (kk << 1), CharCode.DOT | (CharCode._0 << 16));\n    return kk + 2;\n  } else if (kk > 0 && kk <= 21) {\n    // 1234e-2 -> 12.34\n    let ptr = buffer + (kk << 1);\n    memory.copy(\n      ptr + 2,\n      ptr,\n      -k << 1\n    );\n    store<u16>(buffer + (kk << 1), CharCode.DOT);\n    return length + 1;\n  } else if (-6 < kk && kk <= 0) {\n    // 1234e-6 -> 0.001234\n    let offset = 2 - kk;\n    memory.copy(\n      buffer + (offset << 1),\n      buffer,\n      length << 1\n    );\n    store<u32>(buffer, CharCode._0 | (CharCode.DOT << 16));\n    for (let i = 2; i < offset; ++i) {\n      store<u16>(buffer + (i << 1), CharCode._0);\n    }\n    return length + offset;\n  } else if (length == 1) {\n    // 1e30\n    store<u16>(buffer, CharCode.e, 2);\n    length = genExponent(buffer + 4, kk - 1);\n    return length + 2;\n  } else {\n    let len = length << 1;\n    memory.copy(\n      buffer + 4,\n      buffer + 2,\n      len - 2\n    );\n    store<u16>(buffer,       CharCode.DOT, 2);\n    store<u16>(buffer + len, CharCode.e,   2);\n    length += genExponent(buffer + len + 4, kk - 1);\n    return length + 2;\n  }\n}\n\nfunction dtoa_core(buffer: usize, value: f64, isSingle: bool): i32 {\n  let sign = i32(value < 0);\n  if (sign) {\n    value = -value;\n    store<u16>(buffer, CharCode.MINUS);\n  }\n  // assert(value > 0 && value <= (isSingle ? f32.MAX_VALUE : f64.MAX_VALUE));\n  let len = grisu2(value, buffer, sign, isSingle);\n  len = prettify(buffer + (sign << 1), len - sign, _K);\n  return len + sign;\n}\n\n// @ts-ignore: decorator\n@lazy @inline const dtoa_buf = memory.data(MAX_DOUBLE_LENGTH << 1);\n\nexport function dtoa<T extends number>(value: T): String {\n  const isSingle = isFloat<T>() && sizeof<T>() == 4;\n  return dtoa_impl(value, isSingle);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction dtoa_impl(value: f64, isSingle: bool): String {\n  if (value == 0) return \"0.0\";\n  if (!isFinite(value)) {\n    if (isNaN(value)) return \"NaN\";\n    return select<String>(\"-Infinity\", \"Infinity\", value < 0);\n  }\n  let size = dtoa_core(dtoa_buf, value, isSingle) << 1;\n  let result = changetype<String>(__new(size, idof<String>()));\n  memory.copy(changetype<usize>(result), dtoa_buf, size);\n  return result;\n}\n\nexport function itoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  let sign: u32 = 0;\n  if (isSigned<T>()) {\n    sign = u32(value < 0);\n    if (sign) {\n      if (sizeof<T>() == 1) {\n        if (value == -0x80) {\n          // -0x80  ->  -128\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 1) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 8) << 48\n          );\n          return 4;\n        }\n      }\n      if (sizeof<T>() == 2) {\n        if (value == -0x8000) {\n          // -0x8000  ->  -32768\n          store<u64>(buffer,\n            <u64>CharCode.MINUS |\n            <u64>(CharCode._0 + 3) << 16 |\n            <u64>(CharCode._0 + 2) << 32 |\n            <u64>(CharCode._0 + 7) << 48\n          ); // -327\n          store<u32>(buffer + 8,\n            (CharCode._0 + 6) << 0 |\n            (CharCode._0 + 8) << 16\n          ); // 68\n          return 6;\n        }\n      }\n      store<u16>(buffer, CharCode.MINUS);\n      // @ts-ignore\n      value = -value;\n    }\n  }\n  let dest = buffer + (sign << 1);\n  if (ASC_SHRINK_LEVEL <= 1) {\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        if (<u32>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      } else {\n        if (<u64>value < 10) {\n          store<u16>(dest, value | CharCode._0);\n          return 1 + sign;\n        }\n      }\n    } else {\n      if (value < 10) {\n        store<u16>(buffer, value | CharCode._0);\n        return 1;\n      }\n    }\n  }\n  let decimals: u32 = 0;\n  if (sizeof<T>() <= 4) {\n    let val32 = <u32>value;\n    decimals = decimalCount32(val32);\n    utoa32_dec_core(dest, val32, decimals);\n  } else {\n    if (<u64>value <= <u64>u32.MAX_VALUE) {\n      let val32 = <u32>value;\n      decimals = decimalCount32(val32);\n      utoa32_dec_core(dest, val32, decimals);\n    } else {\n      let val64 = <u64>value;\n      decimals = decimalCount64High(val64);\n      utoa64_dec_core(dest, val64, decimals);\n    }\n  }\n  return sign + decimals;\n}\n\nexport function dtoa_buffered<T extends number>(buffer: usize, value: T): u32 {\n  const isSingle = isFloat<T>() && sizeof<T>() == 4;\n  return dtoa_buffered_impl(buffer, value, isSingle);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction dtoa_buffered_impl(buffer: usize, value: f64, isSingle: bool): u32 {\n  if (value == 0) {\n    store<u16>(buffer, CharCode._0);\n    store<u16>(buffer, CharCode.DOT, 2);\n    store<u16>(buffer, CharCode._0,  4);\n    return 3;\n  }\n  if (!isFinite(value)) {\n    if (isNaN(value)) {\n      store<u16>(buffer, CharCode.N);\n      store<u16>(buffer, CharCode.a, 2);\n      store<u16>(buffer, CharCode.N, 4);\n      return 3;\n    } else {\n      let sign = value < 0;\n      if (sign) {\n        store<u16>(buffer, CharCode.MINUS); // -\n        buffer += 2;\n      }\n      store<u64>(buffer, 0x690066006E0049, 0); // ifnI\n      store<u64>(buffer, 0x7900740069006E, 8); // ytin\n      return 8 + u32(sign);\n    }\n  }\n  return dtoa_core(buffer, value, isSingle);\n}\n","//\n// Lookup data for exp2f\n//\n\n// @ts-ignore: decorator\n@inline const EXP2F_TABLE_BITS = 5;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP2F_DATA_TAB = memory.data<u64>([\n  // exp2f_data_tab[i] = uint(2^(i/N)) - (i << 52-BITS)\n  // used for computing 2^(k/N) for an int |k| < 150 N as\n  // double(tab[k%N] + (k << 52-BITS))\n  0x3FF0000000000000, 0x3FEFD9B0D3158574, 0x3FEFB5586CF9890F, 0x3FEF9301D0125B51,\n  0x3FEF72B83C7D517B, 0x3FEF54873168B9AA, 0x3FEF387A6E756238, 0x3FEF1E9DF51FDEE1,\n  0x3FEF06FE0A31B715, 0x3FEEF1A7373AA9CB, 0x3FEEDEA64C123422, 0x3FEECE086061892D,\n  0x3FEEBFDAD5362A27, 0x3FEEB42B569D4F82, 0x3FEEAB07DD485429, 0x3FEEA47EB03A5585,\n  0x3FEEA09E667F3BCD, 0x3FEE9F75E8EC5F74, 0x3FEEA11473EB0187, 0x3FEEA589994CCE13,\n  0x3FEEACE5422AA0DB, 0x3FEEB737B0CDC5E5, 0x3FEEC49182A3F090, 0x3FEED503B23E255D,\n  0x3FEEE89F995AD3AD, 0x3FEEFF76F2FB5E47, 0x3FEF199BDD85529C, 0x3FEF3720DCEF9069,\n  0x3FEF5818DCFBA487, 0x3FEF7C97337B9B5F, 0x3FEFA4AFA2A490DA, 0x3FEFD0765B6E4540\n]);\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-1/64, 1/64] (before rounding.)\n// Wrong count: 168353 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function exp2f_lut(x: f32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N, // 0x1.8p+52\n    Ox127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x430) {\n    // |x| >= 128 or x is nan.\n    if (ix == 0xFF800000) return 0; // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;  // x == Inf/NaN -> Inf/NaN\n    if (x > 0) return x * Ox127f;   // x >     0    -> HugeVal (Owerflow)\n    if (x <= -150) return 0;        // x <= -150    -> 0 (Underflow)\n  }\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)] and int k.\n  let kd = xd + shift;\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  y  = C2 * r + 1;\n  y += (C0 * r + C1) * (r  * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n// ULP error: 0.502 (nearest rounding.)\n// Relative error: 1.69 * 2^-34 in [-ln2/64, ln2/64] (before rounding.)\n// Wrong count: 170635 (all nearest rounding wrong results with fma.)\n// @ts-ignore: decorator\n@inline\nexport function expf_lut(x: f32): f32 {\n  const\n    N        = 1 << EXP2F_TABLE_BITS,\n    N_MASK   = N - 1,\n    shift    = reinterpret<f64>(0x4338000000000000),        // 0x1.8p+52\n    InvLn2N  = reinterpret<f64>(0x3FF71547652B82FE) * N,    // 0x1.71547652b82fep+0\n    Ox1p127f = reinterpret<f32>(0x7F000000);\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394) / N / N / N, // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3) / N / N,     // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6) / N;         // 0x1.62e42ff0c52d6p-1\n\n  let xd = <f64>x;\n  let ix = reinterpret<u32>(x);\n  let ux = ix >> 20 & 0x7FF;\n  if (ux >= 0x42B) {\n    // |x| >= 88 or x is nan.\n    if (ix == 0xFF800000) return 0;                            // x == -Inf    -> 0\n    if (ux >= 0x7F8) return x + x;                             // x == Inf/NaN -> Inf/NaN\n    if (x > reinterpret<f32>(0x42B17217)) return x * Ox1p127f; // x > log(0x1p128)  ~=  88.72 -> HugeVal (Owerflow)\n    if (x < reinterpret<f32>(0xC2CFF1B4)) return 0;            // x < log(0x1p-150) ~= -103.97 -> 0 (Underflow)\n  }\n\n  // x*N/Ln2 = k + r with r in [-1/2, 1/2] and int k.\n  let z = InvLn2N * xd;\n\n  // Round and convert z to int, the result is in [-150*N, 128*N] and\n  // ideally ties-to-even rule is used, otherwise the magnitude of r\n  // can be bigger which gives larger approximation error.\n  let kd = <f64>(z + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = z - (kd - shift);\n  let s: f64, y: f64, t: u64;\n\n  // exp(x) = 2^(k/N) * 2^(r/N) ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += ki << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for log2f\n//\n\n// @ts-ignore: decorator\n@inline const LOG2F_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2F_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFDEFEC65B963019, // 0x1.661ec79f8f3bep+0, -0x1.efec65b963019p-2,\n  0x3FF571ED4AAF883D, 0xBFDB0B6832D4FCA4, // 0x1.571ed4aaf883dp+0, -0x1.b0b6832d4fca4p-2,\n  0x3FF49539F0F010B0, 0xBFD7418B0A1FB77B, // 0x1.49539f0f010bp+0 , -0x1.7418b0a1fb77bp-2,\n  0x3FF3C995B0B80385, 0xBFD39DE91A6DCF7B, // 0x1.3c995b0b80385p+0, -0x1.39de91a6dcf7bp-2,\n  0x3FF30D190C8864A5, 0xBFD01D9BF3F2B631, // 0x1.30d190c8864a5p+0, -0x1.01d9bf3f2b631p-2,\n  0x3FF25E227B0B8EA0, 0xBFC97C1D1B3B7AF0, // 0x1.25e227b0b8eap+0 , -0x1.97c1d1b3b7afp-3 ,\n  0x3FF1BB4A4A1A343F, 0xBFC2F9E393AF3C9F, // 0x1.1bb4a4a1a343fp+0, -0x1.2f9e393af3c9fp-3,\n  0x3FF12358F08AE5BA, 0xBFB960CBBF788D5C, // 0x1.12358f08ae5bap+0, -0x1.960cbbf788d5cp-4,\n  0x3FF0953F419900A7, 0xBFAA6F9DB6475FCE, // 0x1.0953f419900a7p+0, -0x1.a6f9db6475fcep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0x0,\n  0x3FEE608CFD9A47AC, 0x3FB338CA9F24F53D, // 0x1.e608cfd9a47acp-1,  0x1.338ca9f24f53dp-4,\n  0x3FECA4B31F026AA0, 0x3FC476A9543891BA, // 0x1.ca4b31f026aap-1 ,  0x1.476a9543891bap-3,\n  0x3FEB2036576AFCE6, 0x3FCE840B4AC4E4D2, // 0x1.b2036576afce6p-1,  0x1.e840b4ac4e4d2p-3,\n  0x3FE9C2D163A1AA2D, 0x3FD40645F0C6651C, // 0x1.9c2d163a1aa2dp-1,  0x1.40645f0c6651cp-2,\n  0x3FE886E6037841ED, 0x3FD88E9C2C1B9FF8, // 0x1.886e6037841edp-1,  0x1.88e9c2c1b9ff8p-2,\n  0x3FE767DCF5534862, 0x3FDCE0A44EB17BCC  // 0x1.767dcf5534862p-1,  0x1.ce0a44eb17bccp-2\n]);\n\n// ULP error: 0.752 (nearest rounding.)\n// Relative error: 1.9 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function log2f_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOG2F_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    A0 = reinterpret<f64>(0xBFD712B6F70A7E4D), // -0x1.712b6f70a7e4dp-2\n    A1 = reinterpret<f64>(0x3FDECABF496832E0), //  0x1.ecabf496832ep-2\n    A2 = reinterpret<f64>(0xBFE715479FFAE3DE), // -0x1.715479ffae3dep-1\n    A3 = reinterpret<f64>(0x3FF715475F35C8B8); //  0x1.715475f35c8b8p0\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && predict_false(ix == 0x3f800000)) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if (ux * 2 == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log2(inf) == inf.\n    if ((ux >> 31) || ux * 2 >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = (tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK;\n  let top  = tmp & 0xFF800000;\n  let iz   = ux - top;\n  let k    = <i32>tmp >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(iz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y  = A1 * r + A2;\n  let p  = A3 * r + y0;\n  let r2 = r * r;\n  y += A0 * r2;\n  y  = y * r2 + p;\n\n  return <f32>y;\n}\n\n//\n// Lookup data for logf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/logf.c\n//\n\n// @ts-ignore: decorator\n@inline const LOGF_TABLE_BITS = 4;\n\n// @ts-ignore: decorator\n@lazy @inline const LOGF_DATA_TAB = memory.data<u64>([\n  0x3FF661EC79F8F3BE, 0xBFD57BF7808CAADE, // 0x1.661ec79f8f3bep+0, -0x1.57bf7808caadep-2,\n  0x3FF571ED4AAF883D, 0xBFD2BEF0A7C06DDB, // 0x1.571ed4aaf883dp+0, -0x1.2bef0a7c06ddbp-2,\n  0x3FF49539F0F010B0, 0xBFD01EAE7F513A67, // 0x1.49539f0f010bp+0 , -0x1.01eae7f513a67p-2,\n  0x3FF3C995B0B80385, 0xBFCB31D8A68224E9, // 0x1.3c995b0b80385p+0, -0x1.b31d8a68224e9p-3,\n  0x3FF30D190C8864A5, 0xBFC6574F0AC07758, // 0x1.30d190c8864a5p+0, -0x1.6574f0ac07758p-3,\n  0x3FF25E227B0B8EA0, 0xBFC1AA2BC79C8100, // 0x1.25e227b0b8eap+0 , -0x1.1aa2bc79c81p-3  ,\n  0x3FF1BB4A4A1A343F, 0xBFBA4E76CE8C0E5E, // 0x1.1bb4a4a1a343fp+0, -0x1.a4e76ce8c0e5ep-4,\n  0x3FF12358F08AE5BA, 0xBFB1973C5A611CCC, // 0x1.12358f08ae5bap+0, -0x1.1973c5a611cccp-4,\n  0x3FF0953F419900A7, 0xBFA252F438E10C1E, // 0x1.0953f419900a7p+0, -0x1.252f438e10c1ep-5,\n  0x3FF0000000000000, 0,                  // 0x1p+0,                0,\n  0x3FEE608CFD9A47AC, 0x3FAAA5AA5DF25984, // 0x1.e608cfd9a47acp-1,  0x1.aa5aa5df25984p-5,\n  0x3FECA4B31F026AA0, 0x3FBC5E53AA362EB4, // 0x1.ca4b31f026aap-1 ,  0x1.c5e53aa362eb4p-4,\n  0x3FEB2036576AFCE6, 0x3FC526E57720DB08, // 0x1.b2036576afce6p-1,  0x1.526e57720db08p-3,\n  0x3FE9C2D163A1AA2D, 0x3FCBC2860D224770, // 0x1.9c2d163a1aa2dp-1,  0x1.bc2860d22477p-3 ,\n  0x3FE886E6037841ED, 0x3FD1058BC8A07EE1, // 0x1.886e6037841edp-1,  0x1.1058bc8a07ee1p-2,\n  0x3FE767DCF5534862, 0x3FD4043057B6EE09  // 0x1.767dcf5534862p-1,  0x1.4043057b6ee09p-2\n]);\n\n// ULP error: 0.818 (nearest rounding.)\n// Relative error: 1.957 * 2^-26 (before rounding.)\n// @ts-ignore: decorator\n@inline\nexport function logf_lut(x: f32): f32 {\n  const\n    N_MASK  = (1 << LOGF_TABLE_BITS) - 1,\n    Ox1p23f = reinterpret<f32>(0x4B000000); // 0x1p23f\n\n  const\n    Ln2 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1;\n    A0  = reinterpret<f64>(0xBFD00EA348B88334), // -0x1.00ea348b88334p-2\n    A1  = reinterpret<f64>(0x3FD5575B0BE00B6A), //  0x1.5575b0be00b6ap-2\n    A2  = reinterpret<f64>(0xBFDFFFFEF20A4123); // -0x1.ffffef20a4123p-2\n\n  let ux = reinterpret<u32>(x);\n  // Fix sign of zero with downward rounding when x==1.\n  // if (WANT_ROUNDING && ux == 0x3f800000) return 0;\n  if (ux - 0x00800000 >= 0x7F800000 - 0x00800000) {\n    // x < 0x1p-126 or inf or nan.\n    if ((ux << 1) == 0) return -Infinity;\n    if (ux == 0x7F800000) return x; // log(inf) == inf.\n    if ((ux >> 31) || (ux << 1) >= 0xFF000000) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ux = reinterpret<u32>(x * Ox1p23f);\n    ux -= 23 << 23;\n  }\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ux - 0x3F330000;\n  let i   = (tmp >> (23 - LOGF_TABLE_BITS)) & N_MASK;\n  let k   = <i32>tmp >> 23;\n  let iz  = ux - (tmp & 0x1FF << 23);\n\n  let invc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOGF_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n\n  let z = <f64>reinterpret<f32>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2\n  let r = z * invc - 1;\n  let y0 = logc + <f64>k * Ln2;\n\n  // Pipelined polynomial evaluation to approximate log1p(r).\n  let r2 = r * r;\n  let y  = A1 * r + A2;\n  y += A0 * r2;\n  y = y * r2 + (y0 + r);\n\n  return <f32>y;\n}\n\n//\n// Lookup data for powf. See: https://git.musl-libc.org/cgit/musl/tree/src/math/powf.c\n//\n\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnanf(ux: u32): bool {\n  return (ux << 1) - 1 >= (<u32>0x7f800000 << 1) - 1;\n}\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkintf(iy: u32): i32 {\n  let e = iy >> 23 & 0xFF;\n  if (e < 0x7F     ) return 0;\n  if (e > 0x7F + 23) return 2;\n  e = 1 << (0x7F + 23 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// Subnormal input is normalized so ix has negative biased exponent.\n// Output is multiplied by N (POWF_SCALE) if TOINT_INTRINICS is set.\n// @ts-ignore: decorator\n@inline\nfunction log2f_inline(ux: u32): f64 {\n  const N_MASK = (1 << LOG2F_TABLE_BITS) - 1;\n\n  const\n    A0 = reinterpret<f64>(0x3FD27616C9496E0B), //  0x1.27616c9496e0bp-2\n    A1 = reinterpret<f64>(0xBFD71969A075C67A), // -0x1.71969a075c67ap-2\n    A2 = reinterpret<f64>(0x3FDEC70A6CA7BADD), //  0x1.ec70a6ca7baddp-2\n    A3 = reinterpret<f64>(0xBFE7154748BEF6C8), // -0x1.7154748bef6c8p-1\n    A4 = reinterpret<f64>(0x3FF71547652AB82B); //  0x1.71547652ab82bp+0\n\n  // x = 2^k z; where z is in range [OFF,2*OFF] and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ux - 0x3F330000;\n  let i    = usize((tmp >> (23 - LOG2F_TABLE_BITS)) & N_MASK);\n  let top  = tmp & 0xFF800000;\n  let uz   = ux - top;\n  let k    = <i32>top >> 23;\n\n  let invc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 0 << alignof<f64>());\n  let logc = load<f64>(LOG2F_DATA_TAB + (i << (1 + alignof<f64>())), 1 << alignof<f64>());\n  let z    = <f64>reinterpret<f32>(uz);\n\n  // log2(x) = log1p(z/c-1)/ln2 + log2(c) + k\n  let r  = z * invc - 1;\n  let y0 = logc + <f64>k;\n\n  // Pipelined polynomial evaluation to approximate log1p(r)/ln2.\n  let y = A0 * r + A1;\n  let p = A2 * r + A3;\n  let q = A4 * r + y0;\n\n  r *= r;\n  q += p * r;\n  y  = y * (r * r) + q;\n\n  return y;\n}\n\n// The output of log2 and thus the input of exp2 is either scaled by N\n// (in case of fast toint intrinsics) or not.  The unscaled xd must be\n// in [-1021,1023], sign_bias sets the sign of the result.\n// @ts-ignore: decorator\n@inline\nfunction exp2f_inline(xd: f64, signBias: u32): f32 {\n  const\n    N      = 1 << EXP2F_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p+52\n\n  const\n    C0 = reinterpret<f64>(0x3FAC6AF84B912394), // 0x1.c6af84b912394p-5\n    C1 = reinterpret<f64>(0x3FCEBFCE50FAC4F3), // 0x1.ebfce50fac4f3p-3\n    C2 = reinterpret<f64>(0x3FE62E42FF0C52D6); // 0x1.62e42ff0c52d6p-1\n\n  // x = k/N + r with r in [-1/(2N), 1/(2N)]\n  let kd = <f64>(xd + shift);\n  let ki = reinterpret<u64>(kd);\n  let r  = xd - (kd - shift);\n  let t: u64, z: f64, y: f64, s: f64;\n\n  // exp2(x) = 2^(k/N) * 2^r ~= s * (C0*r^3 + C1*r^2 + C2*r + 1)\n  t  = load<u64>(EXP2F_DATA_TAB + ((<usize>ki & N_MASK) << alignof<u64>()));\n  t += (ki + signBias) << (52 - EXP2F_TABLE_BITS);\n  s  = reinterpret<f64>(t);\n  z  = C0 * r + C1;\n  y  = C2 * r + 1;\n  y += z * (r * r);\n  y *= s;\n  return <f32>y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflowf(sign: u32, y: f32): f32 {\n  return select<f32>(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x70000000)); // 0x1p97f\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflowf(sign: u32): f32 {\n  return xflowf(sign, reinterpret<f32>(0x10000000)); // 0x1p-95f\n}\n\n// @ts-ignore: decorator\n@inline\nexport function powf_lut(x: f32, y: f32): f32 {\n  const\n    Ox1p23f     = reinterpret<f32>(0x4B000000), // 0x1p23f\n    UPPER_LIMIT = reinterpret<f64>(0x405FFFFFFFD1D571), // 0x1.fffffffd1d571p+6\n    LOWER_LIMIT = -150.0,\n    SIGN_BIAS   = 1 << (EXP2F_TABLE_BITS + 11);\n\n  let signBias: u32 = 0;\n  let ix = reinterpret<u32>(x);\n  let iy = reinterpret<u32>(y);\n  let ny = 0;\n\n  if (i32(ix - 0x00800000 >= 0x7f800000 - 0x00800000) | (ny = i32(zeroinfnanf(iy)))) {\n    // Either (x < 0x1p-126 or inf or nan) or (y is 0 or inf or nan).\n    if (ny) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3F800000) return NaN; // original: 1.0\n      if ((ix << 1) > (<u32>0x7F800000 << 1) || (iy << 1) > (<u32>0x7F800000 << 1)) return x + y;\n      if ((ix << 1) == (0x3F800000 << 1)) return NaN; // original: 1.0\n      if (((ix << 1) < (0x3F800000 << 1)) == !(iy >> 31)) return 0; // |x| < 1 && y==inf or |x| > 1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnanf(ix)) {\n      let x2 = x * x;\n      if ((ix >> 31) && checkintf(iy) == 1) x2 = -x2;\n      return <i32>iy < 0 ? 1 / x2 : x2;\n    }\n    // x and y are non-zero finite.\n    if (<i32>ix < 0) {\n      // Finite x < 0.\n      let yint = checkintf(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) signBias = SIGN_BIAS;\n      ix &= 0x7FFFFFFF;\n    }\n    if (ix < 0x00800000) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u32>(x * Ox1p23f);\n      ix &= 0x7FFFFFFF;\n      ix -= 23 << 23;\n    }\n  }\n  let logx = log2f_inline(ix);\n  let ylogx = y * logx; // cannot overflow, y is single prec.\n  if ((reinterpret<u64>(ylogx) >> 47 & 0xFFFF) >= 0x80BF) { // reinterpret<u64>(126.0) >> 47\n    // |y * log(x)| >= 126\n    if (ylogx  > UPPER_LIMIT) return oflowf(signBias); // overflow\n    if (ylogx <= LOWER_LIMIT) return uflowf(signBias); // underflow\n  }\n  return exp2f_inline(ylogx, signBias);\n}\n\n//\n// Lookup data for exp. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp.c\n//\n\n// @ts-ignore: decorator\n@inline const EXP_TABLE_BITS = 7;\n\n// @ts-ignore: decorator\n@lazy @inline const EXP_DATA_TAB = memory.data<u64>([\n  0x0000000000000000, 0x3FF0000000000000,\n  0x3C9B3B4F1A88BF6E, 0x3FEFF63DA9FB3335,\n  0xBC7160139CD8DC5D, 0x3FEFEC9A3E778061,\n  0xBC905E7A108766D1, 0x3FEFE315E86E7F85,\n  0x3C8CD2523567F613, 0x3FEFD9B0D3158574,\n  0xBC8BCE8023F98EFA, 0x3FEFD06B29DDF6DE,\n  0x3C60F74E61E6C861, 0x3FEFC74518759BC8,\n  0x3C90A3E45B33D399, 0x3FEFBE3ECAC6F383,\n  0x3C979AA65D837B6D, 0x3FEFB5586CF9890F,\n  0x3C8EB51A92FDEFFC, 0x3FEFAC922B7247F7,\n  0x3C3EBE3D702F9CD1, 0x3FEFA3EC32D3D1A2,\n  0xBC6A033489906E0B, 0x3FEF9B66AFFED31B,\n  0xBC9556522A2FBD0E, 0x3FEF9301D0125B51,\n  0xBC5080EF8C4EEA55, 0x3FEF8ABDC06C31CC,\n  0xBC91C923B9D5F416, 0x3FEF829AAEA92DE0,\n  0x3C80D3E3E95C55AF, 0x3FEF7A98C8A58E51,\n  0xBC801B15EAA59348, 0x3FEF72B83C7D517B,\n  0xBC8F1FF055DE323D, 0x3FEF6AF9388C8DEA,\n  0x3C8B898C3F1353BF, 0x3FEF635BEB6FCB75,\n  0xBC96D99C7611EB26, 0x3FEF5BE084045CD4,\n  0x3C9AECF73E3A2F60, 0x3FEF54873168B9AA,\n  0xBC8FE782CB86389D, 0x3FEF4D5022FCD91D,\n  0x3C8A6F4144A6C38D, 0x3FEF463B88628CD6,\n  0x3C807A05B0E4047D, 0x3FEF3F49917DDC96,\n  0x3C968EFDE3A8A894, 0x3FEF387A6E756238,\n  0x3C875E18F274487D, 0x3FEF31CE4FB2A63F,\n  0x3C80472B981FE7F2, 0x3FEF2B4565E27CDD,\n  0xBC96B87B3F71085E, 0x3FEF24DFE1F56381,\n  0x3C82F7E16D09AB31, 0x3FEF1E9DF51FDEE1,\n  0xBC3D219B1A6FBFFA, 0x3FEF187FD0DAD990,\n  0x3C8B3782720C0AB4, 0x3FEF1285A6E4030B,\n  0x3C6E149289CECB8F, 0x3FEF0CAFA93E2F56,\n  0x3C834D754DB0ABB6, 0x3FEF06FE0A31B715,\n  0x3C864201E2AC744C, 0x3FEF0170FC4CD831,\n  0x3C8FDD395DD3F84A, 0x3FEEFC08B26416FF,\n  0xBC86A3803B8E5B04, 0x3FEEF6C55F929FF1,\n  0xBC924AEDCC4B5068, 0x3FEEF1A7373AA9CB,\n  0xBC9907F81B512D8E, 0x3FEEECAE6D05D866,\n  0xBC71D1E83E9436D2, 0x3FEEE7DB34E59FF7,\n  0xBC991919B3CE1B15, 0x3FEEE32DC313A8E5,\n  0x3C859F48A72A4C6D, 0x3FEEDEA64C123422,\n  0xBC9312607A28698A, 0x3FEEDA4504AC801C,\n  0xBC58A78F4817895B, 0x3FEED60A21F72E2A,\n  0xBC7C2C9B67499A1B, 0x3FEED1F5D950A897,\n  0x3C4363ED60C2AC11, 0x3FEECE086061892D,\n  0x3C9666093B0664EF, 0x3FEECA41ED1D0057,\n  0x3C6ECCE1DAA10379, 0x3FEEC6A2B5C13CD0,\n  0x3C93FF8E3F0F1230, 0x3FEEC32AF0D7D3DE,\n  0x3C7690CEBB7AAFB0, 0x3FEEBFDAD5362A27,\n  0x3C931DBDEB54E077, 0x3FEEBCB299FDDD0D,\n  0xBC8F94340071A38E, 0x3FEEB9B2769D2CA7,\n  0xBC87DECCDC93A349, 0x3FEEB6DAA2CF6642,\n  0xBC78DEC6BD0F385F, 0x3FEEB42B569D4F82,\n  0xBC861246EC7B5CF6, 0x3FEEB1A4CA5D920F,\n  0x3C93350518FDD78E, 0x3FEEAF4736B527DA,\n  0x3C7B98B72F8A9B05, 0x3FEEAD12D497C7FD,\n  0x3C9063E1E21C5409, 0x3FEEAB07DD485429,\n  0x3C34C7855019C6EA, 0x3FEEA9268A5946B7,\n  0x3C9432E62B64C035, 0x3FEEA76F15AD2148,\n  0xBC8CE44A6199769F, 0x3FEEA5E1B976DC09,\n  0xBC8C33C53BEF4DA8, 0x3FEEA47EB03A5585,\n  0xBC845378892BE9AE, 0x3FEEA34634CCC320,\n  0xBC93CEDD78565858, 0x3FEEA23882552225,\n  0x3C5710AA807E1964, 0x3FEEA155D44CA973,\n  0xBC93B3EFBF5E2228, 0x3FEEA09E667F3BCD,\n  0xBC6A12AD8734B982, 0x3FEEA012750BDABF,\n  0xBC6367EFB86DA9EE, 0x3FEE9FB23C651A2F,\n  0xBC80DC3D54E08851, 0x3FEE9F7DF9519484,\n  0xBC781F647E5A3ECF, 0x3FEE9F75E8EC5F74,\n  0xBC86EE4AC08B7DB0, 0x3FEE9F9A48A58174,\n  0xBC8619321E55E68A, 0x3FEE9FEB564267C9,\n  0x3C909CCB5E09D4D3, 0x3FEEA0694FDE5D3F,\n  0xBC7B32DCB94DA51D, 0x3FEEA11473EB0187,\n  0x3C94ECFD5467C06B, 0x3FEEA1ED0130C132,\n  0x3C65EBE1ABD66C55, 0x3FEEA2F336CF4E62,\n  0xBC88A1C52FB3CF42, 0x3FEEA427543E1A12,\n  0xBC9369B6F13B3734, 0x3FEEA589994CCE13,\n  0xBC805E843A19FF1E, 0x3FEEA71A4623C7AD,\n  0xBC94D450D872576E, 0x3FEEA8D99B4492ED,\n  0x3C90AD675B0E8A00, 0x3FEEAAC7D98A6699,\n  0x3C8DB72FC1F0EAB4, 0x3FEEACE5422AA0DB,\n  0xBC65B6609CC5E7FF, 0x3FEEAF3216B5448C,\n  0x3C7BF68359F35F44, 0x3FEEB1AE99157736,\n  0xBC93091FA71E3D83, 0x3FEEB45B0B91FFC6,\n  0xBC5DA9B88B6C1E29, 0x3FEEB737B0CDC5E5,\n  0xBC6C23F97C90B959, 0x3FEEBA44CBC8520F,\n  0xBC92434322F4F9AA, 0x3FEEBD829FDE4E50,\n  0xBC85CA6CD7668E4B, 0x3FEEC0F170CA07BA,\n  0x3C71AFFC2B91CE27, 0x3FEEC49182A3F090,\n  0x3C6DD235E10A73BB, 0x3FEEC86319E32323,\n  0xBC87C50422622263, 0x3FEECC667B5DE565,\n  0x3C8B1C86E3E231D5, 0x3FEED09BEC4A2D33,\n  0xBC91BBD1D3BCBB15, 0x3FEED503B23E255D,\n  0x3C90CC319CEE31D2, 0x3FEED99E1330B358,\n  0x3C8469846E735AB3, 0x3FEEDE6B5579FDBF,\n  0xBC82DFCD978E9DB4, 0x3FEEE36BBFD3F37A,\n  0x3C8C1A7792CB3387, 0x3FEEE89F995AD3AD,\n  0xBC907B8F4AD1D9FA, 0x3FEEEE07298DB666,\n  0xBC55C3D956DCAEBA, 0x3FEEF3A2B84F15FB,\n  0xBC90A40E3DA6F640, 0x3FEEF9728DE5593A,\n  0xBC68D6F438AD9334, 0x3FEEFF76F2FB5E47,\n  0xBC91EEE26B588A35, 0x3FEF05B030A1064A,\n  0x3C74FFD70A5FDDCD, 0x3FEF0C1E904BC1D2,\n  0xBC91BDFBFA9298AC, 0x3FEF12C25BD71E09,\n  0x3C736EAE30AF0CB3, 0x3FEF199BDD85529C,\n  0x3C8EE3325C9FFD94, 0x3FEF20AB5FFFD07A,\n  0x3C84E08FD10959AC, 0x3FEF27F12E57D14B,\n  0x3C63CDAF384E1A67, 0x3FEF2F6D9406E7B5,\n  0x3C676B2C6C921968, 0x3FEF3720DCEF9069,\n  0xBC808A1883CCB5D2, 0x3FEF3F0B555DC3FA,\n  0xBC8FAD5D3FFFFA6F, 0x3FEF472D4A07897C,\n  0xBC900DAE3875A949, 0x3FEF4F87080D89F2,\n  0x3C74A385A63D07A7, 0x3FEF5818DCFBA487,\n  0xBC82919E2040220F, 0x3FEF60E316C98398,\n  0x3C8E5A50D5C192AC, 0x3FEF69E603DB3285,\n  0x3C843A59AC016B4B, 0x3FEF7321F301B460,\n  0xBC82D52107B43E1F, 0x3FEF7C97337B9B5F,\n  0xBC892AB93B470DC9, 0x3FEF864614F5A129,\n  0x3C74B604603A88D3, 0x3FEF902EE78B3FF6,\n  0x3C83C5EC519D7271, 0x3FEF9A51FBC74C83,\n  0xBC8FF7128FD391F0, 0x3FEFA4AFA2A490DA,\n  0xBC8DAE98E223747D, 0x3FEFAF482D8E67F1,\n  0x3C8EC3BC41AA2008, 0x3FEFBA1BEE615A27,\n  0x3C842B94C3A9EB32, 0x3FEFC52B376BBA97,\n  0x3C8A64A931D185EE, 0x3FEFD0765B6E4540,\n  0xBC8E37BAE43BE3ED, 0x3FEFDBFDAD9CBE14,\n  0x3C77893B4D91CD9D, 0x3FEFE7C1819E90D8,\n  0x3C5305C14160CC89, 0x3FEFF3C22B8F71F1\n]);\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding. The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase(tmp: f64, sbits: u64, ki: u64): f64 {\n  const\n    Ox1p_1022 = reinterpret<f64>(0x0010000000000000), // 0x1p-1022\n    Ox1p1009  = reinterpret<f64>(0x7F00000000000000); // 0x1p1009\n\n  let scale: f64;\n  if (!(ki & 0x80000000)) {\n    // k > 0, the exponent of scale might have overflowed by <= 460.\n    sbits -= u64(1009) << 52;\n    scale = reinterpret<f64>(sbits);\n    return Ox1p1009 * (scale + scale * tmp); // 0x1p1009\n  }\n  // k < 0, need special care in the subnormal range.\n  sbits += u64(1022) << 52;\n  // Note: sbits is signed scale.\n  scale = reinterpret<f64>(sbits);\n  let y = scale + scale * tmp;\n  if (abs(y) < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range.  So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let one = copysign(1.0, y);\n    let lo = scale - y + scale * tmp;\n    let hi = one + y;\n    lo = one - hi + y + lo;\n    y  = (hi + lo) - one;\n    // Fix the sign of 0.\n    if (y == 0.0) y = reinterpret<f64>(sbits & 0x8000000000000000);\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52;\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) {\n        return 1.0 + x;\n      } else {\n        return select<f64>(0, Infinity, <i64>ux < 0);\n      }\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)]\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N]\n  let z = InvLn2N * x;\n  // #if TOINT_INTRINSICS\n  // \tkd = roundtoint(z);\n  // \tki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  // \t// z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  // let kd = z + shift;\n  // let ki = reinterpret<u64>(kd) >> 16;\n  // let kd = <f64><i32>ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes.\n  let kd = z + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  let r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // 2^(k/N) ~= scale * (1 + tail).\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()))); // T[idx]\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n//\n// Lookup data for exp2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/exp2.c\n//\n\n// Handle cases that may overflow or underflow when computing the result that\n// is scale*(1+TMP) without intermediate rounding.  The bit representation of\n// scale is in SBITS, however it has a computed exponent that may have\n// overflown into the sign bit so that needs to be adjusted before using it as\n// a double.  (int32_t)KI is the k used in the argument reduction and exponent\n// adjustment of scale, positive k here means the result may overflow and\n// negative k means the result may underflow.\n// @ts-ignore: decorator\n@inline\nfunction specialcase2(tmp: f64, sbits: u64, ki: u64): f64 {\n  const Ox1p_1022 = reinterpret<f64>(0x10000000000000); // 0x1p-1022\n  let scale: f64;\n  if ((ki & 0x80000000) == 0) {\n    // k > 0, the exponent of scale might have overflowed by 1\n    sbits -= u64(1) << 52;\n    scale = reinterpret<f64>(sbits);\n    return 2 * (scale * tmp + scale);\n  }\n  // k < 0, need special care in the subnormal range\n  sbits += u64(1022) << 52;\n  scale = reinterpret<f64>(sbits);\n  let y = scale * tmp + scale;\n  if (y < 1.0) {\n    // Round y to the right precision before scaling it into the subnormal\n    // range to avoid double rounding that can cause 0.5+E/2 ulp error where\n    // E is the worst-case ulp error outside the subnormal range. So this\n    // is only useful if the goal is better than 1 ulp worst-case error.\n    let hi: f64, lo: f64;\n    lo = scale - y + scale * tmp;\n    hi = 1.0 + y;\n    lo = 1.0 - hi + y + lo;\n    y = (hi + lo) - 1.0;\n  }\n  return y * Ox1p_1022;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function exp2_lut(x: f64): f64 {\n  const\n    N      = 1 << EXP_TABLE_BITS,\n    N_MASK = N - 1,\n    shift  = reinterpret<f64>(0x4338000000000000) / N; // 0x1.8p52\n\n  const\n    C1 = reinterpret<f64>(0x3FE62E42FEFA39EF), // 0x1.62e42fefa39efp-1\n    C2 = reinterpret<f64>(0x3FCEBFBDFF82C424), // 0x1.ebfbdff82c424p-3\n    C3 = reinterpret<f64>(0x3FAC6B08D70CF4B5), // 0x1.c6b08d70cf4b5p-5\n    C4 = reinterpret<f64>(0x3F83B2ABD24650CC), // 0x1.3b2abd24650ccp-7\n    C5 = reinterpret<f64>(0x3F55D7E09B4E3A84); // 0x1.5d7e09b4e3a84p-10\n\n  let ux = reinterpret<u64>(x);\n  let abstop = u32(ux >> 52) & 0x7ff;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) return 1.0;\n    if (abstop >= 0x409) {\n      if (ux == 0xFFF0000000000000) return 0;\n      if (abstop >= 0x7FF) return 1.0 + x;\n      if (<i64>ux >= 0) return Infinity;\n      else if (ux >= 0xC090CC0000000000) return 0;\n    }\n    if ((ux << 1) > 0x811A000000000000) abstop = 0; // Large x is special cased below.\n  }\n\n  // exp2(x) = 2^(k/N) * 2^r, with 2^r in [2^(-1/2N),2^(1/2N)].\n  // x = k/N + r, with int k and r in [-1/2N, 1/2N]\n  let kd = x + shift;\n  let ki = reinterpret<u64>(kd);\n  kd -= shift; // k/N for int k\n  let r = x - kd;\n  // 2^(k/N) ~= scale * (1 + tail)\n  let idx = usize((ki & N_MASK) << 1);\n  let top = ki << (52 - EXP_TABLE_BITS);\n\n  let tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 0 << alignof<u64>())); // T[idx])\n  // This is only a valid scale when -1023*N < k < 1024*N\n  let sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top; // T[idx + 1]\n  // exp2(x) = 2^(k/N) * 2^r ~= scale + scale * (tail + 2^r - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r;\n  // Without fma the worst case error is 0.5/N ulp larger.\n  // Worst case error is less than 0.5+0.86/N+(abs poly error * 2^53) ulp.\n  let tmp = tail + r * C1 + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase2(tmp, sbits, ki);\n  let scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-65 and scale > 2^-928, so there\n  // is no spurious underflow here even without fma.\n  return scale * tmp + scale;\n}\n\n//\n// Lookup data for log2. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log2.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG2_TABLE_BITS = 6;\n\n/* Algorithm:\n\n  x = 2^k z\n  log2(x) = k + log2(c) + log2(z/c)\n  log2(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log2(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p10 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-64 and\n  3) the rounding error in (double)log2(c) is minimized (< 0x1p-68).\n\nNote: 1) ensures that k + logc can be computed without rounding error, 2)\nensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to a\nsingle rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log2(x)| < 0x1p-4, this is not enough so that is special cased. */\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB1 = memory.data<u64>([\n  //     invc       ,        logc\n  0x3FF724286BB1ACF8, 0xBFE1095FEECDB000,\n  0x3FF6E1F766D2CCA1, 0xBFE08494BD76D000,\n  0x3FF6A13D0E30D48A, 0xBFE00143AEE8F800,\n  0x3FF661EC32D06C85, 0xBFDEFEC5360B4000,\n  0x3FF623FA951198F8, 0xBFDDFDD91AB7E000,\n  0x3FF5E75BA4CF026C, 0xBFDCFFAE0CC79000,\n  0x3FF5AC055A214FB8, 0xBFDC043811FDA000,\n  0x3FF571ED0F166E1E, 0xBFDB0B67323AE000,\n  0x3FF53909590BF835, 0xBFDA152F5A2DB000,\n  0x3FF5014FED61ADDD, 0xBFD9217F5AF86000,\n  0x3FF4CAB88E487BD0, 0xBFD8304DB0719000,\n  0x3FF49539B4334FEE, 0xBFD74189F9A9E000,\n  0x3FF460CBDFAFD569, 0xBFD6552BB5199000,\n  0x3FF42D664EE4B953, 0xBFD56B23A29B1000,\n  0x3FF3FB01111DD8A6, 0xBFD483650F5FA000,\n  0x3FF3C995B70C5836, 0xBFD39DE937F6A000,\n  0x3FF3991C4AB6FD4A, 0xBFD2BAA1538D6000,\n  0x3FF3698E0CE099B5, 0xBFD1D98340CA4000,\n  0x3FF33AE48213E7B2, 0xBFD0FA853A40E000,\n  0x3FF30D191985BDB1, 0xBFD01D9C32E73000,\n  0x3FF2E025CAB271D7, 0xBFCE857DA2FA6000,\n  0x3FF2B404CF13CD82, 0xBFCCD3C8633D8000,\n  0x3FF288B02C7CCB50, 0xBFCB26034C14A000,\n  0x3FF25E2263944DE5, 0xBFC97C1C2F4FE000,\n  0x3FF234563D8615B1, 0xBFC7D6023F800000,\n  0x3FF20B46E33EAF38, 0xBFC633A71A05E000,\n  0x3FF1E2EEFDCDA3DD, 0xBFC494F5E9570000,\n  0x3FF1BB4A580B3930, 0xBFC2F9E424E0A000,\n  0x3FF19453847F2200, 0xBFC162595AFDC000,\n  0x3FF16E06C0D5D73C, 0xBFBF9C9A75BD8000,\n  0x3FF1485F47B7E4C2, 0xBFBC7B575BF9C000,\n  0x3FF12358AD0085D1, 0xBFB960C60FF48000,\n  0x3FF0FEF00F532227, 0xBFB64CE247B60000,\n  0x3FF0DB2077D03A8F, 0xBFB33F78B2014000,\n  0x3FF0B7E6D65980D9, 0xBFB0387D1A42C000,\n  0x3FF0953EFE7B408D, 0xBFAA6F9208B50000,\n  0x3FF07325CAC53B83, 0xBFA47A954F770000,\n  0x3FF05197E40D1B5C, 0xBF9D23A8C50C0000,\n  0x3FF03091C1208EA2, 0xBF916A2629780000,\n  0x3FF0101025B37E21, 0xBF7720F8D8E80000,\n  0x3FEFC07EF9CAA76B, 0x3F86FE53B1500000,\n  0x3FEF4465D3F6F184, 0x3FA11CCCE10F8000,\n  0x3FEECC079F84107F, 0x3FAC4DFC8C8B8000,\n  0x3FEE573A99975AE8, 0x3FB3AA321E574000,\n  0x3FEDE5D6F0BD3DE6, 0x3FB918A0D08B8000,\n  0x3FED77B681FF38B3, 0x3FBE72E9DA044000,\n  0x3FED0CB5724DE943, 0x3FC1DCD2507F6000,\n  0x3FECA4B2DC0E7563, 0x3FC476AB03DEA000,\n  0x3FEC3F8EE8D6CB51, 0x3FC7074377E22000,\n  0x3FEBDD2B4F020C4C, 0x3FC98EDE8BA94000,\n  0x3FEB7D6C006015CA, 0x3FCC0DB86AD2E000,\n  0x3FEB20366E2E338F, 0x3FCE840AAFCEE000,\n  0x3FEAC57026295039, 0x3FD0790AB4678000,\n  0x3FEA6D01BC2731DD, 0x3FD1AC056801C000,\n  0x3FEA16D3BC3FF18B, 0x3FD2DB11D4FEE000,\n  0x3FE9C2D14967FEAD, 0x3FD406464EC58000,\n  0x3FE970E4F47C9902, 0x3FD52DBE093AF000,\n  0x3FE920FB3982BCF2, 0x3FD651902050D000,\n  0x3FE8D30187F759F1, 0x3FD771D2CDEAF000,\n  0x3FE886E5EBB9F66D, 0x3FD88E9C857D9000,\n  0x3FE83C97B658B994, 0x3FD9A80155E16000,\n  0x3FE7F405FFC61022, 0x3FDABE186ED3D000,\n  0x3FE7AD22181415CA, 0x3FDBD0F2AEA0E000,\n  0x3FE767DCF99EFF8C, 0x3FDCE0A43DBF4000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG2_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE6200012B90A8E, 0x3C8904AB0644B605,\n  0x3FE66000045734A6, 0x3C61FF9BEA62F7A9,\n  0x3FE69FFFC325F2C5, 0x3C827ECFCB3C90BA,\n  0x3FE6E00038B95A04, 0x3C88FF8856739326,\n  0x3FE71FFFE09994E3, 0x3C8AFD40275F82B1,\n  0x3FE7600015590E10, 0xBC72FD75B4238341,\n  0x3FE7A00012655BD5, 0x3C7808E67C242B76,\n  0x3FE7E0003259E9A6, 0xBC6208E426F622B7,\n  0x3FE81FFFEDB4B2D2, 0xBC8402461EA5C92F,\n  0x3FE860002DFAFCC3, 0x3C6DF7F4A2F29A1F,\n  0x3FE89FFFF78C6B50, 0xBC8E0453094995FD,\n  0x3FE8E00039671566, 0xBC8A04F3BEC77B45,\n  0x3FE91FFFE2BF1745, 0xBC77FA34400E203C,\n  0x3FE95FFFCC5C9FD1, 0xBC76FF8005A0695D,\n  0x3FE9A0003BBA4767, 0x3C70F8C4C4EC7E03,\n  0x3FE9DFFFE7B92DA5, 0x3C8E7FD9478C4602,\n  0x3FEA1FFFD72EFDAF, 0xBC6A0C554DCDAE7E,\n  0x3FEA5FFFDE04FF95, 0x3C867DA98CE9B26B,\n  0x3FEA9FFFCA5E8D2B, 0xBC8284C9B54C13DE,\n  0x3FEADFFFDDAD03EA, 0x3C5812C8EA602E3C,\n  0x3FEB1FFFF10D3D4D, 0xBC8EFADDAD27789C,\n  0x3FEB5FFFCE21165A, 0x3C53CB1719C61237,\n  0x3FEB9FFFD950E674, 0x3C73F7D94194CE00,\n  0x3FEBE000139CA8AF, 0x3C750AC4215D9BC0,\n  0x3FEC20005B46DF99, 0x3C6BEEA653E9C1C9,\n  0x3FEC600040B9F7AE, 0xBC7C079F274A70D6,\n  0x3FECA0006255FD8A, 0xBC7A0B4076E84C1F,\n  0x3FECDFFFD94C095D, 0x3C88F933F99AB5D7,\n  0x3FED1FFFF975D6CF, 0xBC582C08665FE1BE,\n  0x3FED5FFFA2561C93, 0xBC7B04289BD295F3,\n  0x3FED9FFF9D228B0C, 0x3C870251340FA236,\n  0x3FEDE00065BC7E16, 0xBC75011E16A4D80C,\n  0x3FEE200002F64791, 0x3C89802F09EF62E0,\n  0x3FEE600057D7A6D8, 0xBC7E0B75580CF7FA,\n  0x3FEEA00027EDC00C, 0xBC8C848309459811,\n  0x3FEEE0006CF5CB7C, 0xBC8F8027951576F4,\n  0x3FEF2000782B7DCC, 0xBC8F81D97274538F,\n  0x3FEF6000260C450A, 0xBC4071002727FFDC,\n  0x3FEF9FFFE88CD533, 0xBC581BDCE1FDA8B0,\n  0x3FEFDFFFD50F8689, 0x3C87F91ACB918E6E,\n  0x3FF0200004292367, 0x3C9B7FF365324681,\n  0x3FF05FFFE3E3D668, 0x3C86FA08DDAE957B,\n  0x3FF0A0000A85A757, 0xBC57E2DE80D3FB91,\n  0x3FF0E0001A5F3FCC, 0xBC91823305C5F014,\n  0x3FF11FFFF8AFBAF5, 0xBC8BFABB6680BAC2,\n  0x3FF15FFFE54D91AD, 0xBC9D7F121737E7EF,\n  0x3FF1A00011AC36E1, 0x3C9C000A0516F5FF,\n  0x3FF1E00019C84248, 0xBC9082FBE4DA5DA0,\n  0x3FF220000FFE5E6E, 0xBC88FDD04C9CFB43,\n  0x3FF26000269FD891, 0x3C8CFE2A7994D182,\n  0x3FF2A00029A6E6DA, 0xBC700273715E8BC5,\n  0x3FF2DFFFE0293E39, 0x3C9B7C39DAB2A6F9,\n  0x3FF31FFFF7DCF082, 0x3C7DF1336EDC5254,\n  0x3FF35FFFF05A8B60, 0xBC9E03564CCD31EB,\n  0x3FF3A0002E0EAECC, 0x3C75F0E74BD3A477,\n  0x3FF3E000043BB236, 0x3C9C7DCB149D8833,\n  0x3FF4200002D187FF, 0x3C7E08AFCF2D3D28,\n  0x3FF460000D387CB1, 0x3C820837856599A6,\n  0x3FF4A00004569F89, 0xBC89FA5C904FBCD2,\n  0x3FF4E000043543F3, 0xBC781125ED175329,\n  0x3FF51FFFCC027F0F, 0x3C9883D8847754DC,\n  0x3FF55FFFFD87B36F, 0xBC8709E731D02807,\n  0x3FF59FFFF21DF7BA, 0x3C87F79F68727B02,\n  0x3FF5DFFFEBFC3481, 0xBC9180902E30E93E\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log2_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG2_TABLE_BITS) - 1;\n\n  const\n    LO: u64 = 0x3FEEA4AF00000000, // reinterpret<u64>(1.0 - 0x1.5b51p-5)\n    HI: u64 = 0x3FF0B55900000000; // reinterpret<u64>(1.0 + 0x1.6ab2p-5)\n\n  const\n    InvLn2hi = reinterpret<f64>(0x3FF7154765200000), // 0x1.7154765200000p+0\n    InvLn2lo = reinterpret<f64>(0x3DE705FC2EEFA200), // 0x1.705fc2eefa200p-33\n    Ox1p52   = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  const\n    B0 = reinterpret<f64>(0xBFE71547652B82FE), // -0x1.71547652b82fep-1\n    B1 = reinterpret<f64>(0x3FDEC709DC3A03F7), //  0x1.ec709dc3a03f7p-2\n    B2 = reinterpret<f64>(0xBFD71547652B7C3F), // -0x1.71547652b7c3fp-2\n    B3 = reinterpret<f64>(0x3FD2776C50F05BE4), //  0x1.2776c50f05be4p-2\n    B4 = reinterpret<f64>(0xBFCEC709DD768FE5), // -0x1.ec709dd768fe5p-3\n    B5 = reinterpret<f64>(0x3FCA61761EC4E736), //  0x1.a61761ec4e736p-3\n    B6 = reinterpret<f64>(0xBFC7153FBC64A79B), // -0x1.7153fbc64a79bp-3\n    B7 = reinterpret<f64>(0x3FC484D154F01B4A), //  0x1.484d154f01b4ap-3\n    B8 = reinterpret<f64>(0xBFC289E4A72C383C), // -0x1.289e4a72c383cp-3\n    B9 = reinterpret<f64>(0x3FC0B32F285AEE66); //  0x1.0b32f285aee66p-3\n\n  const\n    A0 = reinterpret<f64>(0xBFE71547652B8339), // -0x1.71547652b8339p-1\n    A1 = reinterpret<f64>(0x3FDEC709DC3A04BE), //  0x1.ec709dc3a04bep-2\n    A2 = reinterpret<f64>(0xBFD7154764702FFB), // -0x1.7154764702ffbp-2\n    A3 = reinterpret<f64>(0x3FD2776C50034C48), //  0x1.2776c50034c48p-2\n    A4 = reinterpret<f64>(0xBFCEC7B328EA92BC), // -0x1.ec7b328ea92bcp-3\n    A5 = reinterpret<f64>(0x3FCA6225E117F92E); //  0x1.a6225e117f92ep-3\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r = x - 1.0;\n    // #if __FP_FAST_FMA\n    //     hi = r * InvLn2hi;\n    //     lo = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -hi);\n    // #else\n    let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n    let rlo = r - rhi;\n    let hi  = rhi * InvLn2hi;\n    let lo  = rlo * InvLn2hi + r * InvLn2lo;\n    // #endif\n    let r2 = r * r; // rounding error: 0x1p-62\n    let r4 = r2 * r2;\n    // Worst-case error is less than 0.54 ULP (0.55 ULP without fma)\n    let p = r2 * (B0 + r * B1);\n    let y = hi + p;\n    lo += hi - y + p;\n    lo += r4 * (B2 + r * B3 + r2 * (B4 + r * B5) +\n          r4 * (B6 + r * B7 + r2 * (B8 + r * B9)));\n    return y + lo;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7ff0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan.\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == 0x7FF0000000000000) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it.\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG2_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & 0xFFF0000000000000);\n\n  let invc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG2_DATA_TAB1  + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n  let kd   = <f64>k;\n\n  // log2(x) = log2(z/c) + log2(c) + k.\n  // r ~= z/c - 1, |r| < 1/(2*N).\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N.\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // \tt1 = r * InvLn2hi;\n  // \tt2 = r * InvLn2lo + __builtin_fma(r, InvLn2hi, -t1);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-65.\n  let chi = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].chi;\n  let clo = load<f64>(LOG2_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].clo;\n\n  let r   = (z - chi - clo) * invc;\n  let rhi = reinterpret<f64>(reinterpret<u64>(r) & 0xFFFFFFFF00000000);\n  let rlo = r - rhi;\n  let t1  = rhi * InvLn2hi;\n  let t2  = rlo * InvLn2hi + r * InvLn2lo;\n  // #endif\n\n  // hi + lo = r/ln2 + log2(c) + k\n  let t3 = kd + logc;\n  let hi = t3 + t1;\n  let lo = t3 - hi + t1 + t2;\n\n  // log2(r+1) = r/ln2 + r^2*poly(r)\n  // Evaluation is optimized assuming superscalar pipelined execution\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst-case error if |y| > 0x1p-4: 0.547 ULP (0.550 ULP without fma).\n  // ~ 0.5 + 2/N/ln2 + abs-poly-error*0x1p56 ULP (+ 0.003 ULP without fma).\n  let p = A0 + r * A1 + r2 * (A2 + r * A3) + (r2 * r2) * (A4 + r * A5);\n  return lo + r2 * p + hi;\n}\n\n//\n// Lookup data for log. See: https://git.musl-libc.org/cgit/musl/tree/src/math/log.c\n//\n\n// @ts-ignore: decorator\n@inline const LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [1.6p-1; 1.6p0] which is split into N subintervals and z falls\ninto the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = (double)log(c)\n  tab2[i].chi = (double)c\n  tab2[i].clo = (double)(c - (double)c)\n\nwhere c is near the center of the subinterval and is chosen by trying +-2^29\nfloating point invc candidates around 1/center and selecting one for which\n\n  1) the rounding error in 0x1.8p9 + logc is 0,\n  2) the rounding error in z - chi - clo is < 0x1p-66 and\n  3) the rounding error in (double)log(c) is minimized (< 0x1p-66).\n\nNote: 1) ensures that k*ln2hi + logc can be computed without rounding error,\n2) ensures that z/c - 1 can be computed as (z - chi - clo)*invc with close to\na single rounding error when there is no fast fma for z*invc - 1, 3) ensures\nthat logc + poly(z/c - 1) has small error, however near x == 1 when\n|log(x)| < 0x1p-4, this is not enough so that is special cased.*/\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB1 = memory.data<u64>([\n  //      invc      ,        logc\n  0x3FF734F0C3E0DE9F, 0xBFD7CC7F79E69000,\n  0x3FF713786A2CE91F, 0xBFD76FEEC20D0000,\n  0x3FF6F26008FAB5A0, 0xBFD713E31351E000,\n  0x3FF6D1A61F138C7D, 0xBFD6B85B38287800,\n  0x3FF6B1490BC5B4D1, 0xBFD65D5590807800,\n  0x3FF69147332F0CBA, 0xBFD602D076180000,\n  0x3FF6719F18224223, 0xBFD5A8CA86909000,\n  0x3FF6524F99A51ED9, 0xBFD54F4356035000,\n  0x3FF63356AA8F24C4, 0xBFD4F637C36B4000,\n  0x3FF614B36B9DDC14, 0xBFD49DA7FDA85000,\n  0x3FF5F66452C65C4C, 0xBFD445923989A800,\n  0x3FF5D867B5912C4F, 0xBFD3EDF439B0B800,\n  0x3FF5BABCCB5B90DE, 0xBFD396CE448F7000,\n  0x3FF59D61F2D91A78, 0xBFD3401E17BDA000,\n  0x3FF5805612465687, 0xBFD2E9E2EF468000,\n  0x3FF56397CEE76BD3, 0xBFD2941B3830E000,\n  0x3FF54725E2A77F93, 0xBFD23EC58CDA8800,\n  0x3FF52AFF42064583, 0xBFD1E9E129279000,\n  0x3FF50F22DBB2BDDF, 0xBFD1956D2B48F800,\n  0x3FF4F38F4734DED7, 0xBFD141679AB9F800,\n  0x3FF4D843CFDE2840, 0xBFD0EDD094EF9800,\n  0x3FF4BD3EC078A3C8, 0xBFD09AA518DB1000,\n  0x3FF4A27FC3E0258A, 0xBFD047E65263B800,\n  0x3FF4880524D48434, 0xBFCFEB224586F000,\n  0x3FF46DCE1B192D0B, 0xBFCF474A7517B000,\n  0x3FF453D9D3391854, 0xBFCEA4443D103000,\n  0x3FF43A2744B4845A, 0xBFCE020D44E9B000,\n  0x3FF420B54115F8FB, 0xBFCD60A22977F000,\n  0x3FF40782DA3EF4B1, 0xBFCCC00104959000,\n  0x3FF3EE8F5D57FE8F, 0xBFCC202956891000,\n  0x3FF3D5D9A00B4CE9, 0xBFCB81178D811000,\n  0x3FF3BD60C010C12B, 0xBFCAE2C9CCD3D000,\n  0x3FF3A5242B75DAB8, 0xBFCA45402E129000,\n  0x3FF38D22CD9FD002, 0xBFC9A877681DF000,\n  0x3FF3755BC5847A1C, 0xBFC90C6D69483000,\n  0x3FF35DCE49AD36E2, 0xBFC87120A645C000,\n  0x3FF34679984DD440, 0xBFC7D68FB4143000,\n  0x3FF32F5CCEFFCB24, 0xBFC73CB83C627000,\n  0x3FF3187775A10D49, 0xBFC6A39A9B376000,\n  0x3FF301C8373E3990, 0xBFC60B3154B7A000,\n  0x3FF2EB4EBB95F841, 0xBFC5737D76243000,\n  0x3FF2D50A0219A9D1, 0xBFC4DC7B8FC23000,\n  0x3FF2BEF9A8B7FD2A, 0xBFC4462C51D20000,\n  0x3FF2A91C7A0C1BAB, 0xBFC3B08ABC830000,\n  0x3FF293726014B530, 0xBFC31B996B490000,\n  0x3FF27DFA5757A1F5, 0xBFC2875490A44000,\n  0x3FF268B39B1D3BBF, 0xBFC1F3B9F879A000,\n  0x3FF2539D838FF5BD, 0xBFC160C8252CA000,\n  0x3FF23EB7AAC9083B, 0xBFC0CE7F57F72000,\n  0x3FF22A012BA940B6, 0xBFC03CDC49FEA000,\n  0x3FF2157996CC4132, 0xBFBF57BDBC4B8000,\n  0x3FF201201DD2FC9B, 0xBFBE370896404000,\n  0x3FF1ECF4494D480B, 0xBFBD17983EF94000,\n  0x3FF1D8F5528F6569, 0xBFBBF9674ED8A000,\n  0x3FF1C52311577E7C, 0xBFBADC79202F6000,\n  0x3FF1B17C74CB26E9, 0xBFB9C0C3E7288000,\n  0x3FF19E010C2C1AB6, 0xBFB8A646B372C000,\n  0x3FF18AB07BB670BD, 0xBFB78D01B3AC0000,\n  0x3FF1778A25EFBCB6, 0xBFB674F145380000,\n  0x3FF1648D354C31DA, 0xBFB55E0E6D878000,\n  0x3FF151B990275FDD, 0xBFB4485CDEA1E000,\n  0x3FF13F0EA432D24C, 0xBFB333D94D6AA000,\n  0x3FF12C8B7210F9DA, 0xBFB22079F8C56000,\n  0x3FF11A3028ECB531, 0xBFB10E4698622000,\n  0x3FF107FBDA8434AF, 0xBFAFFA6C6AD20000,\n  0x3FF0F5EE0F4E6BB3, 0xBFADDA8D4A774000,\n  0x3FF0E4065D2A9FCE, 0xBFABBCECE4850000,\n  0x3FF0D244632CA521, 0xBFA9A1894012C000,\n  0x3FF0C0A77CE2981A, 0xBFA788583302C000,\n  0x3FF0AF2F83C636D1, 0xBFA5715E67D68000,\n  0x3FF09DDB98A01339, 0xBFA35C8A49658000,\n  0x3FF08CABAF52E7DF, 0xBFA149E364154000,\n  0x3FF07B9F2F4E28FB, 0xBF9E72C082EB8000,\n  0x3FF06AB58C358F19, 0xBF9A55F152528000,\n  0x3FF059EEA5ECF92C, 0xBF963D62CF818000,\n  0x3FF04949CDD12C90, 0xBF9228FB8CAA0000,\n  0x3FF038C6C6F0ADA9, 0xBF8C317B20F90000,\n  0x3FF02865137932A9, 0xBF8419355DAA0000,\n  0x3FF0182427EA7348, 0xBF781203C2EC0000,\n  0x3FF008040614B195, 0xBF60040979240000,\n  0x3FEFE01FF726FA1A, 0x3F6FEFF384900000,\n  0x3FEFA11CC261EA74, 0x3F87DC41353D0000,\n  0x3FEF6310B081992E, 0x3F93CEA3C4C28000,\n  0x3FEF25F63CEEADCD, 0x3F9B9FC114890000,\n  0x3FEEE9C8039113E7, 0x3FA1B0D8CE110000,\n  0x3FEEAE8078CBB1AB, 0x3FA58A5BD001C000,\n  0x3FEE741AA29D0C9B, 0x3FA95C8340D88000,\n  0x3FEE3A91830A99B5, 0x3FAD276AEF578000,\n  0x3FEE01E009609A56, 0x3FB07598E598C000,\n  0x3FEDCA01E577BB98, 0x3FB253F5E30D2000,\n  0x3FED92F20B7C9103, 0x3FB42EDD8B380000,\n  0x3FED5CAC66FB5CCE, 0x3FB606598757C000,\n  0x3FED272CAA5EDE9D, 0x3FB7DA76356A0000,\n  0x3FECF26E3E6B2CCD, 0x3FB9AB434E1C6000,\n  0x3FECBE6DA2A77902, 0x3FBB78C7BB0D6000,\n  0x3FEC8B266D37086D, 0x3FBD431332E72000,\n  0x3FEC5894BD5D5804, 0x3FBF0A3171DE6000,\n  0x3FEC26B533BB9F8C, 0x3FC067152B914000,\n  0x3FEBF583EEECE73F, 0x3FC147858292B000,\n  0x3FEBC4FD75DB96C1, 0x3FC2266ECDCA3000,\n  0x3FEB951E0C864A28, 0x3FC303D7A6C55000,\n  0x3FEB65E2C5EF3E2C, 0x3FC3DFC33C331000,\n  0x3FEB374867C9888B, 0x3FC4BA366B7A8000,\n  0x3FEB094B211D304A, 0x3FC5933928D1F000,\n  0x3FEADBE885F2EF7E, 0x3FC66ACD2418F000,\n  0x3FEAAF1D31603DA2, 0x3FC740F8EC669000,\n  0x3FEA82E63FD358A7, 0x3FC815C0F51AF000,\n  0x3FEA5740EF09738B, 0x3FC8E92954F68000,\n  0x3FEA2C2A90AB4B27, 0x3FC9BB3602F84000,\n  0x3FEA01A01393F2D1, 0x3FCA8BED1C2C0000,\n  0x3FE9D79F24DB3C1B, 0x3FCB5B515C01D000,\n  0x3FE9AE2505C7B190, 0x3FCC2967CCBCC000,\n  0x3FE9852EF297CE2F, 0x3FCCF635D5486000,\n  0x3FE95CBAEEA44B75, 0x3FCDC1BD3446C000,\n  0x3FE934C69DE74838, 0x3FCE8C01B8CFE000,\n  0x3FE90D4F2F6752E6, 0x3FCF5509C0179000,\n  0x3FE8E6528EFFD79D, 0x3FD00E6C121FB800,\n  0x3FE8BFCE9FCC007C, 0x3FD071B80E93D000,\n  0x3FE899C0DABEC30E, 0x3FD0D46B9E867000,\n  0x3FE87427AA2317FB, 0x3FD13687334BD000,\n  0x3FE84F00ACB39A08, 0x3FD1980D67234800,\n  0x3FE82A49E8653E55, 0x3FD1F8FFE0CC8000,\n  0x3FE8060195F40260, 0x3FD2595FD7636800,\n  0x3FE7E22563E0A329, 0x3FD2B9300914A800,\n  0x3FE7BEB377DCB5AD, 0x3FD3187210436000,\n  0x3FE79BAA679725C2, 0x3FD377266DEC1800,\n  0x3FE77907F2170657, 0x3FD3D54FFBAF3000,\n  0x3FE756CADBD6130C, 0x3FD432EEE32FE000\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOG_DATA_TAB2 = memory.data<u64>([\n  //      chi       ,         clo\n  0x3FE61000014FB66B, 0x3C7E026C91425B3C,\n  0x3FE63000034DB495, 0x3C8DBFEA48005D41,\n  0x3FE650000D94D478, 0x3C8E7FA786D6A5B7,\n  0x3FE67000074E6FAD, 0x3C61FCEA6B54254C,\n  0x3FE68FFFFEDF0FAE, 0xBC7C7E274C590EFD,\n  0x3FE6B0000763C5BC, 0xBC8AC16848DCDA01,\n  0x3FE6D0001E5CC1F6, 0x3C833F1C9D499311,\n  0x3FE6EFFFEB05F63E, 0xBC7E80041AE22D53,\n  0x3FE710000E869780, 0x3C7BFF6671097952,\n  0x3FE72FFFFC67E912, 0x3C8C00E226BD8724,\n  0x3FE74FFFDF81116A, 0xBC6E02916EF101D2,\n  0x3FE770000F679C90, 0xBC67FC71CD549C74,\n  0x3FE78FFFFA7EC835, 0x3C81BEC19EF50483,\n  0x3FE7AFFFFE20C2E6, 0xBC707E1729CC6465,\n  0x3FE7CFFFED3FC900, 0xBC808072087B8B1C,\n  0x3FE7EFFFE9261A76, 0x3C8DC0286D9DF9AE,\n  0x3FE81000049CA3E8, 0x3C897FD251E54C33,\n  0x3FE8300017932C8F, 0xBC8AFEE9B630F381,\n  0x3FE850000633739C, 0x3C89BFBF6B6535BC,\n  0x3FE87000204289C6, 0xBC8BBF65F3117B75,\n  0x3FE88FFFEBF57904, 0xBC89006EA23DCB57,\n  0x3FE8B00022BC04DF, 0xBC7D00DF38E04B0A,\n  0x3FE8CFFFE50C1B8A, 0xBC88007146FF9F05,\n  0x3FE8EFFFFC918E43, 0x3C83817BD07A7038,\n  0x3FE910001EFA5FC7, 0x3C893E9176DFB403,\n  0x3FE9300013467BB9, 0x3C7F804E4B980276,\n  0x3FE94FFFE6EE076F, 0xBC8F7EF0D9FF622E,\n  0x3FE96FFFDE3C12D1, 0xBC7082AA962638BA,\n  0x3FE98FFFF4458A0D, 0xBC87801B9164A8EF,\n  0x3FE9AFFFDD982E3E, 0xBC8740E08A5A9337,\n  0x3FE9CFFFED49FB66, 0x3C3FCE08C19BE000,\n  0x3FE9F00020F19C51, 0xBC8A3FAA27885B0A,\n  0x3FEA10001145B006, 0x3C74FF489958DA56,\n  0x3FEA300007BBF6FA, 0x3C8CBEAB8A2B6D18,\n  0x3FEA500010971D79, 0x3C88FECADD787930,\n  0x3FEA70001DF52E48, 0xBC8F41763DD8ABDB,\n  0x3FEA90001C593352, 0xBC8EBF0284C27612,\n  0x3FEAB0002A4F3E4B, 0xBC69FD043CFF3F5F,\n  0x3FEACFFFD7AE1ED1, 0xBC823EE7129070B4,\n  0x3FEAEFFFEE510478, 0x3C6A063EE00EDEA3,\n  0x3FEB0FFFDB650D5B, 0x3C5A06C8381F0AB9,\n  0x3FEB2FFFFEAACA57, 0xBC79011E74233C1D,\n  0x3FEB4FFFD995BADC, 0xBC79FF1068862A9F,\n  0x3FEB7000249E659C, 0x3C8AFF45D0864F3E,\n  0x3FEB8FFFF9871640, 0x3C7CFE7796C2C3F9,\n  0x3FEBAFFFD204CB4F, 0xBC63FF27EEF22BC4,\n  0x3FEBCFFFD2415C45, 0xBC6CFFB7EE3BEA21,\n  0x3FEBEFFFF86309DF, 0xBC814103972E0B5C,\n  0x3FEC0FFFE1B57653, 0x3C8BC16494B76A19,\n  0x3FEC2FFFF1FA57E3, 0xBC64FEEF8D30C6ED,\n  0x3FEC4FFFDCBFE424, 0xBC843F68BCEC4775,\n  0x3FEC6FFFED54B9F7, 0x3C847EA3F053E0EC,\n  0x3FEC8FFFEB998FD5, 0x3C7383068DF992F1,\n  0x3FECB0002125219A, 0xBC68FD8E64180E04,\n  0x3FECCFFFDD94469C, 0x3C8E7EBE1CC7EA72,\n  0x3FECEFFFEAFDC476, 0x3C8EBE39AD9F88FE,\n  0x3FED1000169AF82B, 0x3C757D91A8B95A71,\n  0x3FED30000D0FF71D, 0x3C89C1906970C7DA,\n  0x3FED4FFFEA790FC4, 0xBC580E37C558FE0C,\n  0x3FED70002EDC87E5, 0xBC7F80D64DC10F44,\n  0x3FED900021DC82AA, 0xBC747C8F94FD5C5C,\n  0x3FEDAFFFD86B0283, 0x3C8C7F1DC521617E,\n  0x3FEDD000296C4739, 0x3C88019EB2FFB153,\n  0x3FEDEFFFE54490F5, 0x3C6E00D2C652CC89,\n  0x3FEE0FFFCDABF694, 0xBC7F8340202D69D2,\n  0x3FEE2FFFDB52C8DD, 0x3C7B00C1CA1B0864,\n  0x3FEE4FFFF24216EF, 0x3C72FFA8B094AB51,\n  0x3FEE6FFFE88A5E11, 0xBC57F673B1EFBE59,\n  0x3FEE9000119EFF0D, 0xBC84808D5E0BC801,\n  0x3FEEAFFFDFA51744, 0x3C780006D54320B5,\n  0x3FEED0001A127FA1, 0xBC5002F860565C92,\n  0x3FEEF00007BABCC4, 0xBC8540445D35E611,\n  0x3FEF0FFFF57A8D02, 0xBC4FFB3139EF9105,\n  0x3FEF30001EE58AC7, 0x3C8A81ACF2731155,\n  0x3FEF4FFFF5823494, 0x3C8A3F41D4D7C743,\n  0x3FEF6FFFFCA94C6B, 0xBC6202F41C987875,\n  0x3FEF8FFFE1F9C441, 0x3C777DD1F477E74B,\n  0x3FEFAFFFD2E0E37E, 0xBC6F01199A7CA331,\n  0x3FEFD0001C77E49E, 0x3C7181EE4BCEACB1,\n  0x3FEFEFFFF7E0C331, 0xBC6E05370170875A,\n  0x3FF00FFFF465606E, 0xBC8A7EAD491C0ADA,\n  0x3FF02FFFF3867A58, 0xBC977F69C3FCB2E0,\n  0x3FF04FFFFDFC0D17, 0x3C97BFFE34CB945B,\n  0x3FF0700003CD4D82, 0x3C820083C0E456CB,\n  0x3FF08FFFF9F2CBE8, 0xBC6DFFDFBE37751A,\n  0x3FF0B000010CDA65, 0xBC913F7FAEE626EB,\n  0x3FF0D00001A4D338, 0x3C807DFA79489FF7,\n  0x3FF0EFFFFADAFDFD, 0xBC77040570D66BC0,\n  0x3FF110000BBAFD96, 0x3C8E80D4846D0B62,\n  0x3FF12FFFFAE5F45D, 0x3C9DBFFA64FD36EF,\n  0x3FF150000DD59AD9, 0x3C9A0077701250AE,\n  0x3FF170000F21559A, 0x3C8DFDF9E2E3DEEE,\n  0x3FF18FFFFC275426, 0x3C910030DC3B7273,\n  0x3FF1B000123D3C59, 0x3C997F7980030188,\n  0x3FF1CFFFF8299EB7, 0xBC65F932AB9F8C67,\n  0x3FF1EFFFF48AD400, 0x3C937FBF9DA75BEB,\n  0x3FF210000C8B86A4, 0x3C9F806B91FD5B22,\n  0x3FF2300003854303, 0x3C93FFC2EB9FBF33,\n  0x3FF24FFFFFBCF684, 0x3C7601E77E2E2E72,\n  0x3FF26FFFF52921D9, 0x3C7FFCBB767F0C61,\n  0x3FF2900014933A3C, 0xBC7202CA3C02412B,\n  0x3FF2B00014556313, 0xBC92808233F21F02,\n  0x3FF2CFFFEBFE523B, 0xBC88FF7E384FDCF2,\n  0x3FF2F0000BB8AD96, 0xBC85FF51503041C5,\n  0x3FF30FFFFB7AE2AF, 0xBC810071885E289D,\n  0x3FF32FFFFEAC5F7F, 0xBC91FF5D3FB7B715,\n  0x3FF350000CA66756, 0x3C957F82228B82BD,\n  0x3FF3700011FBF721, 0x3C8000BAC40DD5CC,\n  0x3FF38FFFF9592FB9, 0xBC943F9D2DB2A751,\n  0x3FF3B00004DDD242, 0x3C857F6B707638E1,\n  0x3FF3CFFFF5B2C957, 0x3C7A023A10BF1231,\n  0x3FF3EFFFEAB0B418, 0x3C987F6D66B152B0,\n  0x3FF410001532AFF4, 0x3C67F8375F198524,\n  0x3FF4300017478B29, 0x3C8301E672DC5143,\n  0x3FF44FFFE795B463, 0x3C89FF69B8B2895A,\n  0x3FF46FFFE80475E0, 0xBC95C0B19BC2F254,\n  0x3FF48FFFEF6FC1E7, 0x3C9B4009F23A2A72,\n  0x3FF4AFFFE5BEA704, 0xBC94FFB7BF0D7D45,\n  0x3FF4D000171027DE, 0xBC99C06471DC6A3D,\n  0x3FF4F0000FF03EE2, 0x3C977F890B85531C,\n  0x3FF5100012DC4BD1, 0x3C6004657166A436,\n  0x3FF530001605277A, 0xBC96BFCECE233209,\n  0x3FF54FFFECDB704C, 0xBC8902720505A1D7,\n  0x3FF56FFFEF5F54A9, 0x3C9BBFE60EC96412,\n  0x3FF5900017E61012, 0x3C887EC581AFEF90,\n  0x3FF5B00003C93E92, 0xBC9F41080ABF0CC0,\n  0x3FF5D0001D4919BC, 0xBC98812AFB254729,\n  0x3FF5EFFFE7B87A89, 0xBC947EB780ED6904\n]);\n\n// @ts-ignore: decorator\n@inline\nexport function log_lut(x: f64): f64 {\n  const N_MASK = (1 << LOG_TABLE_BITS) - 1;\n\n  const\n    B0  = reinterpret<f64>(0xBFE0000000000000), // -0x1p-1\n    B1  = reinterpret<f64>(0x3FD5555555555577), //  0x1.5555555555577p-2\n    B2  = reinterpret<f64>(0xBFCFFFFFFFFFFDCB), // -0x1.ffffffffffdcbp-3\n    B3  = reinterpret<f64>(0x3FC999999995DD0C), //  0x1.999999995dd0cp-3\n    B4  = reinterpret<f64>(0xBFC55555556745A7), // -0x1.55555556745a7p-3\n    B5  = reinterpret<f64>(0x3FC24924A344DE30), //  0x1.24924a344de3p-3\n    B6  = reinterpret<f64>(0xBFBFFFFFA4423D65), // -0x1.fffffa4423d65p-4\n    B7  = reinterpret<f64>(0x3FBC7184282AD6CA), //  0x1.c7184282ad6cap-4\n    B8  = reinterpret<f64>(0xBFB999EB43B068FF), // -0x1.999eb43b068ffp-4\n    B9  = reinterpret<f64>(0x3FB78182F7AFD085), //  0x1.78182f7afd085p-4\n    B10 = reinterpret<f64>(0xBFB5521375D145CD); // -0x1.5521375d145cdp-4\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000001),  // -0x1.0000000000001p-1\n    A1 = reinterpret<f64>(0x3FD555555551305B),  //  0x1.555555551305bp-2\n    A2 = reinterpret<f64>(0xBFCFFFFFFFEB4590),  // -0x1.fffffffeb459p-3\n    A3 = reinterpret<f64>(0x3FC999B324F10111),  //  0x1.999b324f10111p-3\n    A4 = reinterpret<f64>(0xBFC55575E506C89F);  // -0x1.55575e506c89fp-3\n\n  const\n    LO: u64 = 0x3FEE000000000000,\n    HI: u64 = 0x3FF1090000000000;\n\n  const\n    Ln2hi  = reinterpret<f64>(0x3FE62E42FEFA3800), // 0x1.62e42fefa3800p-1\n    Ln2lo  = reinterpret<f64>(0x3D2EF35793C76730), // 0x1.ef35793c76730p-45\n    Ox1p27 = reinterpret<f64>(0x41A0000000000000), // 0x1p27\n    Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let ix = reinterpret<u64>(x);\n  if (ix - LO < HI - LO) {\n    let r  = x - 1.0;\n    let r2 = r * r;\n    let r3 = r2 * r;\n    let y =\n      r3 * (B1 + r * B2 + r2 * B3 +\n      r3 * (B4 + r * B5 + r2 * B6 +\n      r3 * (B7 + r * B8 + r2 * B9 + r3 * B10)));\n    // Worst-case error is around 0.507 ULP\n    let w   = r * Ox1p27;\n    let rhi = r + w - w;\n    let rlo = r - rhi;\n    w = rhi * rhi * B0; // B[0] == -0.5\n    let hi = r + w;\n    let lo = r - hi + w;\n    lo += B0 * rlo * (rhi + r);\n    return y + lo + hi;\n  }\n  let top = u32(ix >> 48);\n  if (top - 0x0010 >= 0x7FF0 - 0x0010) {\n    // x < 0x1p-1022 or inf or nan\n    if ((ix << 1) == 0) return -1.0 / (x * x);\n    if (ix == reinterpret<u64>(Infinity)) return x; // log(inf) == inf\n    if ((top & 0x8000) || (top & 0x7FF0) == 0x7FF0) return (x - x) / (x - x);\n    // x is subnormal, normalize it\n    ix = reinterpret<u64>(x * Ox1p52);\n    ix -= u64(52) << 52;\n  }\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp  = ix - 0x3FE6000000000000;\n  let i    = <usize>((tmp >> (52 - LOG_TABLE_BITS)) & N_MASK);\n  let k    = <i64>tmp >> 52;\n  let iz   = ix - (tmp & (u64(0xFFF) << 52));\n\n  let invc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T[i].invc;\n  let logc = load<f64>(LOG_DATA_TAB1 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T[i].logc;\n  let z    = reinterpret<f64>(iz);\n\n  // log(x) = log1p(z/c-1) + log(c) + k*Ln2.\n  // r ~= z/c - 1, |r| < 1/(2*N)\n  // #if __FP_FAST_FMA\n  // \t// rounding error: 0x1p-55/N\n  // \tr = __builtin_fma(z, invc, -1.0);\n  // #else\n  // rounding error: 0x1p-55/N + 0x1p-66\n  const chi = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 0 << alignof<f64>()); // T2[i].chi\n  const clo = load<f64>(LOG_DATA_TAB2 + (i << (1 + alignof<f64>())), 1 << alignof<f64>()); // T2[i].clo\n  let r = (z - chi - clo) * invc;\n  // #endif\n  let kd = <f64>k;\n\n  // hi + lo = r + log(c) + k*Ln2\n  let w  = kd * Ln2hi + logc;\n  let hi = w + r;\n  let lo = w - hi + r + kd * Ln2lo;\n\n  // log(x) = lo + (log1p(r) - r) + hi\n  let r2 = r * r; // rounding error: 0x1p-54/N^2\n  // Worst case error if |y| > 0x1p-5:\n  // 0.5 + 4.13/N + abs-poly-error*2^57 ULP (+ 0.002 ULP without fma)\n  // Worst case error if |y| > 0x1p-4:\n  // 0.5 + 2.06/N + abs-poly-error*2^56 ULP (+ 0.001 ULP without fma).\n  return lo + r2 * A0 + r * r2 * (A1 + r * A2 + r2 * (A3 + r * A4)) + hi;\n}\n\n//\n// Lookup data for pow. See: https://git.musl-libc.org/cgit/musl/tree/src/math/pow.c\n//\n\n// @ts-ignore: decorator\n@inline const POW_LOG_TABLE_BITS = 7;\n\n/* Algorithm:\n\n  x = 2^k z\n  log(x) = k ln2 + log(c) + log(z/c)\n  log(z/c) = poly(z/c - 1)\n\nwhere z is in [0x1.69555p-1; 0x1.69555p0] which is split into N subintervals\nand z falls into the ith one, then table entries are computed as\n\n  tab[i].invc = 1/c\n  tab[i].logc = round(0x1p43*log(c))/0x1p43\n  tab[i].logctail = (double)(log(c) - logc)\n\nwhere c is chosen near the center of the subinterval such that 1/c has only a\nfew precision bits so z/c - 1 is exactly representible as double:\n\n  1/c = center < 1 ? round(N/center)/N : round(2*N/center)/N/2\n\nNote: |z/c - 1| < 1/N for the chosen c, |log(c) - logc - logctail| < 0x1p-97,\nthe last few bits of logc are rounded away so k*ln2hi + logc has no rounding\nerror and the interval for z is selected such that near x == 1, where log(x)\nis tiny, large cancellation error is avoided in logc + poly(z/c - 1). */\n\n// @ts-ignore: decorator\n@lazy @inline const POW_LOG_DATA_TAB = memory.data<u64>([\n  //      invc      ,pad,       logc       ,       logctail\n  0x3FF6A00000000000, 0, 0xBFD62C82F2B9C800, 0x3CFAB42428375680,\n  0x3FF6800000000000, 0, 0xBFD5D1BDBF580800, 0xBD1CA508D8E0F720,\n  0x3FF6600000000000, 0, 0xBFD5767717455800, 0xBD2362A4D5B6506D,\n  0x3FF6400000000000, 0, 0xBFD51AAD872DF800, 0xBCE684E49EB067D5,\n  0x3FF6200000000000, 0, 0xBFD4BE5F95777800, 0xBD041B6993293EE0,\n  0x3FF6000000000000, 0, 0xBFD4618BC21C6000, 0x3D13D82F484C84CC,\n  0x3FF5E00000000000, 0, 0xBFD404308686A800, 0x3CDC42F3ED820B3A,\n  0x3FF5C00000000000, 0, 0xBFD3A64C55694800, 0x3D20B1C686519460,\n  0x3FF5A00000000000, 0, 0xBFD347DD9A988000, 0x3D25594DD4C58092,\n  0x3FF5800000000000, 0, 0xBFD2E8E2BAE12000, 0x3D267B1E99B72BD8,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5600000000000, 0, 0xBFD2895A13DE8800, 0x3D15CA14B6CFB03F,\n  0x3FF5400000000000, 0, 0xBFD22941FBCF7800, 0xBD165A242853DA76,\n  0x3FF5200000000000, 0, 0xBFD1C898C1699800, 0xBD1FAFBC68E75404,\n  0x3FF5000000000000, 0, 0xBFD1675CABABA800, 0x3D1F1FC63382A8F0,\n  0x3FF4E00000000000, 0, 0xBFD1058BF9AE4800, 0xBD26A8C4FD055A66,\n  0x3FF4C00000000000, 0, 0xBFD0A324E2739000, 0xBD0C6BEE7EF4030E,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4A00000000000, 0, 0xBFD0402594B4D000, 0xBCF036B89EF42D7F,\n  0x3FF4800000000000, 0, 0xBFCFB9186D5E4000, 0x3D0D572AAB993C87,\n  0x3FF4600000000000, 0, 0xBFCEF0ADCBDC6000, 0x3D2B26B79C86AF24,\n  0x3FF4400000000000, 0, 0xBFCE27076E2AF000, 0xBD172F4F543FFF10,\n  0x3FF4200000000000, 0, 0xBFCD5C216B4FC000, 0x3D21BA91BBCA681B,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF4000000000000, 0, 0xBFCC8FF7C79AA000, 0x3D27794F689F8434,\n  0x3FF3E00000000000, 0, 0xBFCBC286742D9000, 0x3D194EB0318BB78F,\n  0x3FF3C00000000000, 0, 0xBFCAF3C94E80C000, 0x3CBA4E633FCD9066,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3A00000000000, 0, 0xBFCA23BC1FE2B000, 0xBD258C64DC46C1EA,\n  0x3FF3800000000000, 0, 0xBFC9525A9CF45000, 0xBD2AD1D904C1D4E3,\n  0x3FF3600000000000, 0, 0xBFC87FA06520D000, 0x3D2BBDBF7FDBFA09,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3400000000000, 0, 0xBFC7AB890210E000, 0x3D2BDB9072534A58,\n  0x3FF3200000000000, 0, 0xBFC6D60FE719D000, 0xBD10E46AA3B2E266,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF3000000000000, 0, 0xBFC5FF3070A79000, 0xBD1E9E439F105039,\n  0x3FF2E00000000000, 0, 0xBFC526E5E3A1B000, 0xBD20DE8B90075B8F,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2C00000000000, 0, 0xBFC44D2B6CCB8000, 0x3D170CC16135783C,\n  0x3FF2A00000000000, 0, 0xBFC371FC201E9000, 0x3CF178864D27543A,\n  0x3FF2800000000000, 0, 0xBFC29552F81FF000, 0xBD248D301771C408,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2600000000000, 0, 0xBFC1B72AD52F6000, 0xBD2E80A41811A396,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2400000000000, 0, 0xBFC0D77E7CD09000, 0x3D0A699688E85BF4,\n  0x3FF2200000000000, 0, 0xBFBFEC9131DBE000, 0xBD2575545CA333F2,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF2000000000000, 0, 0xBFBE27076E2B0000, 0x3D2A342C2AF0003C,\n  0x3FF1E00000000000, 0, 0xBFBC5E548F5BC000, 0xBD1D0C57585FBE06,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1C00000000000, 0, 0xBFBA926D3A4AE000, 0x3D253935E85BAAC8,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1A00000000000, 0, 0xBFB8C345D631A000, 0x3D137C294D2F5668,\n  0x3FF1800000000000, 0, 0xBFB6F0D28AE56000, 0xBD269737C93373DA,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1600000000000, 0, 0xBFB51B073F062000, 0x3D1F025B61C65E57,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1400000000000, 0, 0xBFB341D7961BE000, 0x3D2C5EDACCF913DF,\n  0x3FF1200000000000, 0, 0xBFB16536EEA38000, 0x3D147C5E768FA309,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF1000000000000, 0, 0xBFAF0A30C0118000, 0x3D2D599E83368E91,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0E00000000000, 0, 0xBFAB42DD71198000, 0x3D1C827AE5D6704C,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0C00000000000, 0, 0xBFA77458F632C000, 0xBD2CFC4634F2A1EE,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0A00000000000, 0, 0xBFA39E87B9FEC000, 0x3CF502B7F526FEAA,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0800000000000, 0, 0xBF9F829B0E780000, 0xBD2980267C7E09E4,\n  0x3FF0600000000000, 0, 0xBF97B91B07D58000, 0xBD288D5493FAA639,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0400000000000, 0, 0xBF8FC0A8B0FC0000, 0xBCDF1E7CF6D3A69C,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0200000000000, 0, 0xBF7FE02A6B100000, 0xBD19E23F0DDA40E4,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FF0000000000000, 0, 0, 0,\n  0x3FEFC00000000000, 0, 0x3F80101575890000, 0xBD10C76B999D2BE8,\n  0x3FEF800000000000, 0, 0x3F90205658938000, 0xBD23DC5B06E2F7D2,\n  0x3FEF400000000000, 0, 0x3F98492528C90000, 0xBD2AA0BA325A0C34,\n  0x3FEF000000000000, 0, 0x3FA0415D89E74000, 0x3D0111C05CF1D753,\n  0x3FEEC00000000000, 0, 0x3FA466AED42E0000, 0xBD2C167375BDFD28,\n  0x3FEE800000000000, 0, 0x3FA894AA149FC000, 0xBD197995D05A267D,\n  0x3FEE400000000000, 0, 0x3FACCB73CDDDC000, 0xBD1A68F247D82807,\n  0x3FEE200000000000, 0, 0x3FAEEA31C006C000, 0xBD0E113E4FC93B7B,\n  0x3FEDE00000000000, 0, 0x3FB1973BD1466000, 0xBD25325D560D9E9B,\n  0x3FEDA00000000000, 0, 0x3FB3BDF5A7D1E000, 0x3D2CC85EA5DB4ED7,\n  0x3FED600000000000, 0, 0x3FB5E95A4D97A000, 0xBD2C69063C5D1D1E,\n  0x3FED400000000000, 0, 0x3FB700D30AEAC000, 0x3CEC1E8DA99DED32,\n  0x3FED000000000000, 0, 0x3FB9335E5D594000, 0x3D23115C3ABD47DA,\n  0x3FECC00000000000, 0, 0x3FBB6AC88DAD6000, 0xBD1390802BF768E5,\n  0x3FECA00000000000, 0, 0x3FBC885801BC4000, 0x3D2646D1C65AACD3,\n  0x3FEC600000000000, 0, 0x3FBEC739830A2000, 0xBD2DC068AFE645E0,\n  0x3FEC400000000000, 0, 0x3FBFE89139DBE000, 0xBD2534D64FA10AFD,\n  0x3FEC000000000000, 0, 0x3FC1178E8227E000, 0x3D21EF78CE2D07F2,\n  0x3FEBE00000000000, 0, 0x3FC1AA2B7E23F000, 0x3D2CA78E44389934,\n  0x3FEBA00000000000, 0, 0x3FC2D1610C868000, 0x3D039D6CCB81B4A1,\n  0x3FEB800000000000, 0, 0x3FC365FCB0159000, 0x3CC62FA8234B7289,\n  0x3FEB400000000000, 0, 0x3FC4913D8333B000, 0x3D25837954FDB678,\n  0x3FEB200000000000, 0, 0x3FC527E5E4A1B000, 0x3D2633E8E5697DC7,\n  0x3FEAE00000000000, 0, 0x3FC6574EBE8C1000, 0x3D19CF8B2C3C2E78,\n  0x3FEAC00000000000, 0, 0x3FC6F0128B757000, 0xBD25118DE59C21E1,\n  0x3FEAA00000000000, 0, 0x3FC7898D85445000, 0xBD1C661070914305,\n  0x3FEA600000000000, 0, 0x3FC8BEAFEB390000, 0xBD073D54AAE92CD1,\n  0x3FEA400000000000, 0, 0x3FC95A5ADCF70000, 0x3D07F22858A0FF6F,\n  0x3FEA000000000000, 0, 0x3FCA93ED3C8AE000, 0xBD28724350562169,\n  0x3FE9E00000000000, 0, 0x3FCB31D8575BD000, 0xBD0C358D4EACE1AA,\n  0x3FE9C00000000000, 0, 0x3FCBD087383BE000, 0xBD2D4BC4595412B6,\n  0x3FE9A00000000000, 0, 0x3FCC6FFBC6F01000, 0xBCF1EC72C5962BD2,\n  0x3FE9600000000000, 0, 0x3FCDB13DB0D49000, 0xBD2AFF2AF715B035,\n  0x3FE9400000000000, 0, 0x3FCE530EFFE71000, 0x3CC212276041F430,\n  0x3FE9200000000000, 0, 0x3FCEF5ADE4DD0000, 0xBCCA211565BB8E11,\n  0x3FE9000000000000, 0, 0x3FCF991C6CB3B000, 0x3D1BCBECCA0CDF30,\n  0x3FE8C00000000000, 0, 0x3FD07138604D5800, 0x3CF89CDB16ED4E91,\n  0x3FE8A00000000000, 0, 0x3FD0C42D67616000, 0x3D27188B163CEAE9,\n  0x3FE8800000000000, 0, 0x3FD1178E8227E800, 0xBD2C210E63A5F01C,\n  0x3FE8600000000000, 0, 0x3FD16B5CCBACF800, 0x3D2B9ACDF7A51681,\n  0x3FE8400000000000, 0, 0x3FD1BF99635A6800, 0x3D2CA6ED5147BDB7,\n  0x3FE8200000000000, 0, 0x3FD214456D0EB800, 0x3D0A87DEBA46BAEA,\n  0x3FE7E00000000000, 0, 0x3FD2BEF07CDC9000, 0x3D2A9CFA4A5004F4,\n  0x3FE7C00000000000, 0, 0x3FD314F1E1D36000, 0xBD28E27AD3213CB8,\n  0x3FE7A00000000000, 0, 0x3FD36B6776BE1000, 0x3D116ECDB0F177C8,\n  0x3FE7800000000000, 0, 0x3FD3C25277333000, 0x3D183B54B606BD5C,\n  0x3FE7600000000000, 0, 0x3FD419B423D5E800, 0x3D08E436EC90E09D,\n  0x3FE7400000000000, 0, 0x3FD4718DC271C800, 0xBD2F27CE0967D675,\n  0x3FE7200000000000, 0, 0x3FD4C9E09E173000, 0xBD2E20891B0AD8A4,\n  0x3FE7000000000000, 0, 0x3FD522AE0738A000, 0x3D2EBE708164C759,\n  0x3FE6E00000000000, 0, 0x3FD57BF753C8D000, 0x3D1FADEDEE5D40EF,\n  0x3FE6C00000000000, 0, 0x3FD5D5BDDF596000, 0xBD0A0B2A08A465DC\n]);\n\n// Returns 0 if not int, 1 if odd int, 2 if even int. The argument is\n// the bit representation of a non-zero finite floating-point value.\n// @ts-ignore: decorator\n@inline\nfunction checkint(iy: u64): i32 {\n  let e = iy >> 52 & 0x7FF;\n  if (e < 0x3FF     ) return 0;\n  if (e > 0x3FF + 52) return 2;\n  e = u64(1) << (0x3FF + 52 - e);\n  if (iy & (e - 1)) return 0;\n  if (iy &  e     ) return 1;\n  return 2;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction xflow(sign: u32, y: f64): f64 {\n  return select(-y, y, sign) * y;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction uflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x1000000000000000)); // 0x1p-767\n}\n\n// @ts-ignore: decorator\n@inline\nfunction oflow(sign: u32): f64 {\n  return xflow(sign, reinterpret<f64>(0x7000000000000000)); // 0x1p769\n}\n\n// Returns 1 if input is the bit representation of 0, infinity or nan.\n// @ts-ignore: decorator\n@inline\nfunction zeroinfnan(u: u64): bool {\n  return (u << 1) - 1 >= 0xFFE0000000000000 - 1;\n}\n\n// @ts-ignore: decorator\n@lazy let log_tail: f64 = 0;\n\n// Compute y+TAIL = log(x) where the rounded result is y and TAIL has about\n// additional 15 bits precision. IX is the bit representation of x, but\n// normalized in the subnormal range using the sign bit for the exponent.\n// @ts-ignore: decorator\n@inline\nfunction log_inline(ix: u64): f64 {\n  const N = 1 << POW_LOG_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    Ln2hi = reinterpret<f64>(0x3FE62E42FEFA3800),\n    Ln2lo = reinterpret<f64>(0x3D2EF35793C76730);\n\n  const\n    A0 = reinterpret<f64>(0xBFE0000000000000),\n    A1 = reinterpret<f64>(0xBFE5555555555560),\n    A2 = reinterpret<f64>(0x3FE0000000000006),\n    A3 = reinterpret<f64>(0x3FE999999959554E),\n    A4 = reinterpret<f64>(0xBFE555555529A47A),\n    A5 = reinterpret<f64>(0xBFF2495B9B4845E9),\n    A6 = reinterpret<f64>(0x3FF0002B8B263FC3);\n\n  // x = 2^k z; where z is in range [OFF,2*OFF) and exact.\n  // The range is split into N subintervals.\n  // The ith subinterval contains z and c is near its center.\n  let tmp = ix - 0x3fE6955500000000;\n  let i   = usize((tmp >> (52 - POW_LOG_TABLE_BITS)) & N_MASK);\n  let k   = <i64>tmp >> 52;\n  let iz  = ix - (tmp & u64(0xFFF) << 52);\n  let z   = reinterpret<f64>(iz);\n  let kd  = <f64>k;\n\n  // log(x) = k*Ln2 + log(c) + log1p(z/c-1).\n  let invc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 0 << alignof<f64>()); // tab[i].invc\n  let logc     = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 2 << alignof<f64>()); // tab[i].logc\n  let logctail = load<f64>(POW_LOG_DATA_TAB + (i << (2 + alignof<f64>())), 3 << alignof<f64>()); // tab[i].logctail\n\n  // Note: 1/c is j/N or j/N/2 where j is an integer in [N,2N) and\n  // |z/c - 1| < 1/N, so r = z/c - 1 is exactly representible.\n  // Split z such that rhi, rlo and rhi*rhi are exact and |rlo| <= |r|.\n  let zhi = reinterpret<f64>((iz + u64(0x80000000)) & 0xFFFFFFFF00000000);\n  let zlo = z - zhi;\n  let rhi = zhi * invc - 1.0;\n  let rlo = zlo * invc;\n  let r   = rhi + rlo;\n\n  // k * Ln2 + log(c) + r.\n  let t1  = kd * Ln2hi + logc;\n  let t2  = t1 + r;\n  let lo1 = kd * Ln2lo + logctail;\n  let lo2 = t1 - t2 + r;\n\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  let ar  = A0 * r; // A[0] = -0.5\n  let ar2 = r * ar;\n  let ar3 = r * ar2;\n  // k * Ln2 + log(c) + r + A[0] * r * r.\n  let arhi  = A0  * rhi;\n  let arhi2 = rhi * arhi;\n  let hi    = t2  + arhi2;\n  let lo3   = rlo * (ar + arhi);\n  let lo4   = t2 - hi + arhi2;\n\n  // p = log1p(r) - r - A[0] * r * r.\n  let p  = ar3 * (A1 + r * A2 + ar2 * (A3 + r * A4 + ar2 * (A5 + r * A6)));\n  let lo = lo1 + lo2 + lo3 + lo4 + p;\n  let y  = hi + lo;\n  log_tail = hi - y + lo;\n\n  return y;\n}\n\n// @ts-ignore: decorator\n@inline const SIGN_BIAS = 0x800 << EXP_TABLE_BITS;\n\n// Computes sign*exp(x+xtail) where |xtail| < 2^-8/N and |xtail| <= |x|.\n// The sign_bias argument is SIGN_BIAS or 0 and sets the sign to -1 or 1.\n// @ts-ignore: decorator\n@inline\nfunction exp_inline(x: f64, xtail: f64, sign_bias: u32): f64 {\n  const N      = 1 << EXP_TABLE_BITS;\n  const N_MASK = N - 1;\n\n  const\n    InvLn2N   = reinterpret<f64>(0x3FF71547652B82FE) * N, // 0x1.71547652b82fep0\n    NegLn2hiN = reinterpret<f64>(0xBF762E42FEFA0000),     // -0x1.62e42fefa0000p-8\n    NegLn2loN = reinterpret<f64>(0xBD0CF79ABC9E3B3A),     // -0x1.cf79abc9e3b3ap-47\n    shift     = reinterpret<f64>(0x4338000000000000);     // 0x1.8p52\n\n  const\n    C2 = reinterpret<f64>(0x3FDFFFFFFFFFFDBD), // __exp_data.poly[0] (0x1.ffffffffffdbdp-2)\n    C3 = reinterpret<f64>(0x3FC555555555543C), // __exp_data.poly[1] (0x1.555555555543cp-3)\n    C4 = reinterpret<f64>(0x3FA55555CF172B91), // __exp_data.poly[2] (0x1.55555cf172b91p-5)\n    C5 = reinterpret<f64>(0x3F81111167A4D017); // __exp_data.poly[3] (0x1.1111167a4d017p-7)\n\n  let abstop: u32;\n  let ki: u64, top: u64, sbits: u64;\n  let idx: usize;\n  // double_t for better performance on targets with FLT_EVAL_METHOD==2.\n  let kd: f64, z: f64, r: f64, r2: f64, scale: f64, tail: f64, tmp: f64;\n\n  let ux = reinterpret<u64>(x);\n  abstop = u32(ux >> 52) & 0x7FF;\n  if (abstop - 0x3C9 >= 0x03F) {\n    if (abstop - 0x3C9 >= 0x80000000) {\n      // Avoid spurious underflow for tiny x.\n      // Note: 0 is common input.\n      return select(-1.0, 1.0, sign_bias);\n    }\n    if (abstop >= 0x409) { // top12(1024.0)\n      // Note: inf and nan are already handled.\n      return <i64>ux < 0\n        ? uflow(sign_bias)\n        : oflow(sign_bias);\n    }\n    // Large x is special cased below.\n    abstop = 0;\n  }\n\n  // exp(x) = 2^(k/N) * exp(r), with exp(r) in [2^(-1/2N),2^(1/2N)].\n  // x = ln2/N*k + r, with int k and r in [-ln2/2N, ln2/2N].\n  z = InvLn2N * x;\n\n  // #if TOINT_INTRINSICS\n  //   kd = roundtoint(z);\n  //   ki = converttoint(z);\n  // #elif EXP_USE_TOINT_NARROW\n  //   // z - kd is in [-0.5-2^-16, 0.5] in all rounding modes.\n  //   kd = eval_as_double(z + shift);\n  //   ki = asuint64(kd) >> 16;\n  //   kd = (double_t)(int32_t)ki;\n  // #else\n  // z - kd is in [-1, 1] in non-nearest rounding modes\n  kd  = z + shift;\n  ki  = reinterpret<u64>(kd);\n  kd -= shift;\n  // #endif\n  r = x + kd * NegLn2hiN + kd * NegLn2loN;\n  // The code assumes 2^-200 < |xtail| < 2^-8/N\n  r += xtail;\n  // 2^(k/N) ~= scale * (1 + tail)\n  idx = usize((ki & N_MASK) << 1);\n  top = (ki + sign_bias) << (52 - EXP_TABLE_BITS);\n\n  tail = reinterpret<f64>(load<u64>(EXP_DATA_TAB + (idx << alignof<u64>())));\n  // This is only a valid scale when -1023*N < k < 1024*N\n  sbits = load<u64>(EXP_DATA_TAB + (idx << alignof<u64>()), 1 << alignof<u64>()) + top;\n  // exp(x) = 2^(k/N) * exp(r) ~= scale + scale * (tail + exp(r) - 1).\n  // Evaluation is optimized assuming superscalar pipelined execution.\n  r2 = r * r;\n  // Without fma the worst case error is 0.25/N ulp larger.\n  // Worst case error is less than 0.5+1.11/N+(abs poly error * 2^53) ulp\n  tmp = tail + r + r2 * (C2 + r * C3) + r2 * r2 * (C4 + r * C5);\n  if (abstop == 0) return specialcase(tmp, sbits, ki);\n  scale = reinterpret<f64>(sbits);\n  // Note: tmp == 0 or |tmp| > 2^-200 and scale > 2^-739, so there\n  // is no spurious underflow here even without fma.\n  return scale + scale * tmp;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function pow_lut(x: f64, y: f64): f64 {\n  const Ox1p52 = reinterpret<f64>(0x4330000000000000); // 0x1p52\n\n  let sign_bias: u32 = 0;\n  let ix = reinterpret<u64>(x);\n  let iy = reinterpret<u64>(y);\n  let topx = ix >> 52;\n  let topy = iy >> 52;\n\n  if (topx - 0x001 >= 0x7FF - 0x001 || (topy & 0x7FF) - 0x3BE >= 0x43e - 0x3BE) {\n    // Note: if |y| > 1075 * ln2 * 2^53 ~= 0x1.749p62 then pow(x,y) = inf/0\n    // and if |y| < 2^-54 / 1075 ~= 0x1.e7b6p-65 then pow(x,y) = +-1.\n    // Special cases: (x < 0x1p-126 or inf or nan) or\n    // (|y| < 0x1p-65 or |y| >= 0x1p63 or nan).\n    if (zeroinfnan(iy)) {\n      if ((iy << 1) == 0) return 1.0;\n      if (ix == 0x3FF0000000000000) return NaN; // original: 1.0\n      if ((ix << 1) > 0xFFE0000000000000 || (iy << 1) > 0xFFE0000000000000) return x + y;\n      if ((ix << 1) == 0x7FE0000000000000) return NaN; // original: 1.0\n      if (((ix << 1) < 0x7FE0000000000000) == !(iy >> 63)) return 0; // |x|<1 && y==inf or |x|>1 && y==-inf.\n      return y * y;\n    }\n    if (zeroinfnan(ix)) {\n      let x2 = x * x;\n      if (i32(ix >> 63) && checkint(iy) == 1) x2 = -x2;\n      return <i64>iy < 0 ? 1 / x2 : x2;\n    }\n    // Here x and y are non-zero finite\n    if (<i64>ix < 0) {\n      // Finite x < 0\n      let yint = checkint(iy);\n      if (yint == 0) return (x - x) / (x - x);\n      if (yint == 1) sign_bias = SIGN_BIAS;\n      ix   &= 0x7FFFFFFFFFFFFFFF;\n      topx &= 0x7FF;\n    }\n    if ((topy & 0x7FF) - 0x3BE >= 0x43E - 0x3BE) {\n      // Note: sign_bias == 0 here because y is not odd.\n      if (ix == 0x3FF0000000000000) return 1;\n      if ((topy & 0x7FF) < 0x3BE)   return 1; // |y| < 2^-65, x^y ~= 1 + y*log(x).\n      return (ix > 0x3FF0000000000000) == (topy < 0x800) ? Infinity : 0;\n    }\n    if (topx == 0) {\n      // Normalize subnormal x so exponent becomes negative.\n      ix = reinterpret<u64>(x * Ox1p52);\n      ix &= 0x7FFFFFFFFFFFFFFF;\n      ix -= u64(52) << 52;\n    }\n  }\n\n  let hi = log_inline(ix);\n  let lo = log_tail;\n  let ehi: f64, elo: f64;\n  // #if __FP_FAST_FMA\n  //   ehi = y * hi;\n  //   elo = y * lo + __builtin_fma(y, hi, -ehi);\n  // #else\n  let yhi = reinterpret<f64>(iy & 0xFFFFFFFFF8000000);\n  let ylo = y - yhi;\n  let lhi = reinterpret<f64>(reinterpret<u64>(hi) & 0xFFFFFFFFF8000000);\n  let llo = hi - lhi + lo;\n  ehi = yhi * lhi;\n  elo = ylo * lhi + y * llo; // |elo| < |ehi| * 2^-25.\n  // #endif\n  return exp_inline(ehi, elo, sign_bias);\n}\n","import {\n  itoa32,\n  utoa32,\n  itoa64,\n  utoa64,\n  dtoa,\n  itoa_buffered,\n  dtoa_buffered,\n  MAX_DOUBLE_LENGTH\n} from \"./number\";\n\nimport {\n  ipow32\n} from \"../math\";\n\n// All tables are stored as two staged lookup tables (static tries)\n// because the full range of Unicode symbols can't be efficiently\n// represented as-is in memory (see Unicode spec ch 5, p.196):\n// https://www.unicode.org/versions/Unicode12.0.0/ch05.pdf\n// Tables have been generated using these forked musl tools:\n// https://github.com/MaxGraey/musl-chartable-tools/tree/case-ignorable\n\n// Lookup table to check if a character is alphanumeric or not\n// See: https://git.musl-libc.org/cgit/musl/tree/src/ctype/alpha.h\n// size: 3904 bytes\n// @ts-ignore\n@inline @lazy const ALPHA_TABLE = memory.data<u8>([\n  18,17,19,20,21,22,23,24,25,26,27,28,29,30,31,32,33,17,34,35,36,17,37,38,39,40,\n  41,42,43,44,17,45,46,47,16,16,48,16,16,16,16,16,16,16,49,50,51,16,52,53,16,16,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,54,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,55,17,17,17,17,56,17,57,58,59,60,61,62,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,63,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,64,65,17,66,67,\n  68,69,70,71,72,73,74,17,75,76,77,78,79,80,81,82,83,84,85,86,87,88,89,90,91,92,\n  93,94,16,95,96,97,98,17,17,17,99,100,101,16,16,16,16,16,16,16,16,16,16,17,17,\n  17,17,102,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,17,17,103,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,17,17,104,105,16,16,106,107,17,17,17,17,17,17,17,17,17,17,17,17,17,\n  17,17,17,17,17,17,17,17,17,17,108,17,17,17,17,109,110,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  17,111,112,16,16,16,16,16,16,16,16,16,113,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,114,115,116,117,16,16,16,16,16,16,16,16,118,\n  119,120,16,16,16,16,16,121,122,16,16,16,16,123,16,16,124,16,16,16,16,16,16,16,\n  16,16,125,16,16,16,\n  16,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,254,255,255,7,254,\n  255,255,7,0,0,0,0,0,4,32,4,255,255,127,255,255,255,127,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,195,255,3,0,31,80,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,0,223,188,64,215,255,255,\n  251,255,255,255,255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,3,252,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,254,255,255,255,127,2,255,255,255,\n  255,255,1,0,0,0,0,255,191,182,0,255,255,255,135,7,0,0,0,255,7,255,255,255,255,\n  255,255,255,254,255,195,255,255,255,255,255,255,255,255,255,255,255,255,239,\n  31,254,225,255,\n  159,0,0,255,255,255,255,255,255,0,224,255,255,255,255,255,255,255,255,255,255,\n  255,255,3,0,255,255,255,255,255,7,48,4,255,255,255,252,255,31,0,0,255,255,255,\n  1,255,7,0,0,0,0,0,0,255,255,223,255,255,0,240,255,248,3,255,255,255,255,255,\n  255,255,255,255,239,255,223,225,255,207,255,254,255,239,159,249,255,255,253,\n  197,227,159,89,128,176,207,255,3,16,238,135,249,255,255,253,109,195,135,25,2,\n  94,192,255,63,0,238,191,251,255,255,253,237,227,191,27,1,0,207,255,0,30,238,\n  159,249,255,255,253,237,227,159,25,192,176,207,255,2,0,236,199,61,214,24,199,\n  255,195,199,29,129,0,192,255,0,0,239,223,253,255,255,253,255,227,223,29,96,7,\n  207,255,0,0,239,223,253,255,255,253,239,227,223,29,96,64,207,255,6,0,255,223,\n  253,255,255,255,255,231,223,93,240,128,207,255,0,252,238,255,127,252,255,255,\n  251,47,127,128,95,255,192,255,12,0,254,255,255,255,255,127,255,7,63,32,255,3,\n  0,0,0,0,214,247,255,255,175,255,255,59,95,32,255,243,0,0,0,\n  0,1,0,0,0,255,3,0,0,255,254,255,255,255,31,254,255,3,255,255,254,255,255,255,\n  31,0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,249,255,3,255,255,255,255,255,\n  255,255,255,255,63,255,255,255,255,191,32,255,255,255,255,255,247,255,255,255,\n  255,255,255,255,255,255,61,127,61,255,255,255,255,255,61,255,255,255,255,61,\n  127,61,255,127,255,255,255,255,255,255,255,61,255,255,255,255,255,255,255,255,\n  7,0,0,0,0,255,255,0,0,255,255,255,255,255,255,255,255,255,255,63,63,254,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,159,255,255,254,255,255,7,255,255,255,255,255,255,255,255,\n  255,199,255,1,255,223,15,0,255,255,15,0,255,255,15,0,255,223,13,0,255,255,255,\n  255,255,255,207,255,255,1,128,16,255,3,0,0,0,0,255,3,255,255,255,255,255,255,\n  255,255,255,255,255,1,255,255,255,255,255,7,255,255,255,255,255,255,255,255,\n  63,\n  0,255,255,255,127,255,15,255,1,192,255,255,255,255,63,31,0,255,255,255,255,\n  255,15,255,255,255,3,255,3,0,0,0,0,255,255,255,15,255,255,255,255,255,255,255,\n  127,254,255,31,0,255,3,255,3,128,0,0,128,1,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,239,255,239,15,255,3,0,0,0,0,255,255,255,255,255,243,255,255,255,255,255,\n  255,191,255,3,0,255,255,255,255,255,255,127,0,255,227,255,255,255,255,255,63,\n  255,1,255,255,255,255,255,231,0,0,0,0,0,222,111,4,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,0,\n  128,255,31,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,255,\n  255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,132,252,47,62,80,189,255,243,\n  224,67,0,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,\n  0,255,255,255,255,255,127,255,255,255,255,255,127,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,31,120,12,0,255,255,255,255,191,32,255,\n  255,255,255,255,255,255,128,0,0,255,255,127,0,127,127,127,127,127,127,127,127,\n  255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,224,0,0,0,254,3,62,31,254,255,255,255,255,255,255,255,255,255,127,224,254,\n  255,255,255,255,255,255,255,255,255,255,247,224,255,255,255,255,255,254,255,\n  255,255,255,255,255,255,255,255,255,127,0,0,255,255,255,255,0,0,0,0,0,0,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,\n  31,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,63,255,31,255,255,255,15,0,0,255,255,255,255,\n  255,127,240,143,255,255,255,255,255,255,255,255,255,255,255,255,255,255,0,0,0,\n  0,128,255,252,255,255,255,255,255,255,255,255,255,255,255,255,249,255,255,255,\n  255,255,255,252,7,0,0,0,0,224,255,191,255,255,255,255,0,0,0,255,255,255,255,\n  255,255,15,0,255,255,255,255,255,255,255,255,47,0,255,3,0,0,252,232,255,255,\n  255,255,255,7,255,255,255,255,7,0,255,255,255,31,255,255,255,255,255,255,247,\n  255,0,128,255,3,255,255,255,127,255,255,255,255,255,255,127,0,255,63,255,3,\n  255,255,127,252,255,255,255,255,255,255,255,127,5,0,0,56,255,255,60,0,126,126,\n  126,0,127,127,255,255,255,255,255,247,255,3,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,7,255,3,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,15,0,255,255,127,248,255,255,255,255,\n  255,\n  15,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,3,0,0,0,0,127,0,248,224,255,253,127,95,219,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,3,0,0,0,248,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,0,0,255,255,255,255,255,255,255,255,\n  252,255,255,255,255,255,255,0,0,0,0,0,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,223,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,0,0,255,3,\n  254,255,255,7,254,255,255,7,192,255,255,255,255,255,255,255,255,255,255,127,\n  252,252,252,28,0,0,0,0,255,239,255,255,127,255,255,183,255,63,255,63,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,31,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,31,255,255,255,255,255,255,1,0,0,0,0,\n  0,255,255,255,255,0,224,255,255,255,7,255,255,255,255,255,7,255,255,255,63,\n  255,255,255,255,15,255,62,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,63,255,3,255,255,255,255,15,255,255,255,\n  255,15,255,255,255,255,255,0,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,127,0,255,255,63,0,255,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,63,253,255,255,255,255,191,145,255,255,63,0,255,255,\n  127,0,255,255,255,127,0,0,0,0,0,0,0,0,255,255,55,0,255,255,63,0,255,255,255,3,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,192,0,0,0,0,0,0,0,0,111,240,239,\n  254,255,255,63,0,0,0,0,0,255,255,255,31,255,255,255,31,0,0,0,0,255,254,255,\n  255,31,0,0,0,255,255,255,255,255,255,63,0,255,255,63,0,255,255,7,0,255,255,3,\n  0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,255,1,0,0,0,0,0,0,255,255,255,255,255,255,7,\n  0,255,255,255,255,255,255,7,0,255,255,255,255,255,0,255,3,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  255,27,3,0,0,0,0,0,0,0,0,0,255,255,255,31,128,0,255,255,63,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,31,0,0,0,255,255,127,0,255,255,255,255,255,255,255,255,63,0,0,\n  0,192,255,0,0,252,255,255,255,255,255,255,1,0,0,255,255,255,1,255,3,255,255,\n  255,255,255,255,199,255,240,0,255,255,255,255,71,0,255,255,255,255,255,255,\n  255,255,30,192,255,23,0,0,0,0,255,255,251,255,255,255,159,64,0,0,0,0,0,0,0,0,\n  127,189,255,191,255,1,255,255,255,255,255,255,255,1,255,3,239,159,249,255,255,\n  253,237,227,159,25,129,224,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,187,7,255,131,3,0,0,0,255,255,255,255,255,\n  255,255,255,179,0,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  255,255,255,63,127,0,0,0,63,0,0,0,0,255,255,255,255,255,255,255,127,17,0,255,\n  3,0,0,0,0,255,255,255,255,255,255,63,1,255,3,0,0,0,0,0,0,255,255,255,231,255,\n  7,255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,\n  255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,3,0,128,\n  127,242,111,255,255,255,191,153,7,0,255,3,0,0,0,0,0,0,0,0,255,252,255,255,255,\n  255,255,252,26,0,0,0,255,255,255,255,255,255,231,127,0,0,255,255,255,255,255,\n  255,255,255,255,32,0,0,0,0,255,255,255,255,255,255,255,1,255,253,255,255,255,\n  255,127,127,1,0,255,3,0,0,252,255,255,255,252,255,255,254,127,0,0,0,0,0,0,0,0,\n  0,127,251,255,255,255,255,127,180,203,0,255,3,191,253,255,255,255,127,123,1,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,1,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,127,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,255,255,255,255,255,255,255,255,127,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,\n  0,255,255,255,255,255,255,255,1,255,255,255,127,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,63,0,0,255,255,255,255,255,255,0,0,15,0,255,3,248,255,255,224,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,\n  255,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,135,\n  255,255,255,255,255,255,255,128,255,255,0,0,0,0,0,0,0,0,11,0,3,0,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,0,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,0,0,0,0,0,\n  255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,\n  127,0,0,0,0,0,0,7,0,240,0,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,15,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,7,255,31,255,1,255,67,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,255,255,255,\n  223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,\n  255,123,95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,63,255,255,255,253,255,255,247,255,255,255,\n  247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,255,253,\n  255,255,255,253,255,255,247,207,255,255,255,255,255,255,127,255,255,249,219,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,31,\n  128,63,255,67,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,15,255,\n  3,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,31,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,143,8,\n  255,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,239,255,255,255,150,254,247,10,\n  132,234,150,170,150,247,247,94,255,251,255,15,238,251,255,15,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,3\n]);\n\n// size: 1568 bytes (compressed to ~1380 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASED = memory.data<u8>([\n  18,19,20,21,22,23,16,16,16,16,16,16,16,16,16,16,\n  24,16,16,25,16,16,16,16,16,16,16,16,26,27,17,28,\n  29,30,16,16,31,16,16,16,16,16,16,16,32,33,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,34,35,16,16,16,36,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,37,16,16,16,38,\n  16,16,16,16,39,16,16,16,16,16,16,16,40,16,16,16,\n  16,16,16,16,16,16,16,16,41,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,42,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,43,44,45,46,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,47,16,16,16,16,16,16,\n  16,48,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,254,255,255,7,254,255,255,7,0,0,0,0,0,4,32,4,\n  255,255,127,255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,247,240,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,239,255,255,255,255,1,3,0,0,0,31,0,0,0,\n  0,0,0,0,0,0,0,0,32,0,0,0,0,0,207,188,64,215,255,255,251,255,255,255,\n  255,255,255,255,255,255,191,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  3,252,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,254,255,\n  255,255,127,0,255,255,255,255,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,\n  191,32,255,255,255,255,255,231,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,255,255,255,255,255,255,63,63,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,1,255,255,255,255,255,231,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,255,255,63,63,255,255,255,255,63,63,255,170,255,255,255,63,\n  255,255,255,255,255,255,223,95,220,31,207,15,255,31,220,31,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,2,128,0,0,255,31,0,0,0,0,0,0,0,0,0,0,0,0,\n  132,252,47,62,80,189,31,242,224,67,0,0,255,255,255,255,24,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,192,255,255,255,255,255,255,3,0,0,255,255,255,255,255,127,255,255,\n  255,255,255,127,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,31,120,12,0,\n  255,255,255,255,191,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,63,0,0,\n  255,255,255,63,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,255,255,\n  255,255,255,255,255,255,255,255,255,120,255,255,255,255,255,255,252,7,0,0,0,0,96,7,\n  0,0,0,0,0,0,255,255,255,255,255,247,255,1,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,0,0,0,0,127,0,248,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,254,255,255,7,\n  254,255,255,7,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,0,0,0,0,255,255,\n  255,255,15,255,255,255,255,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,7,0,255,255,255,255,255,255,7,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,223,255,255,255,255,255,\n  255,255,255,223,100,222,255,235,239,255,255,255,255,255,255,255,191,231,223,223,255,255,255,123,\n  95,252,253,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,63,255,255,255,\n  253,255,255,247,255,255,255,247,255,255,223,255,255,255,223,255,255,127,255,255,255,127,255,255,\n  255,253,255,255,255,253,255,255,247,15,0,0,0,0,0,0,255,255,255,255,255,255,255,255,\n  15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,3,255,255,255,3,255,255,255,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0\n]);\n\n// size: 2976 bytes (compressed to ~2050 bytes after binaryen)\n// @ts-ignore: decorator\n@lazy @inline const CASE_IGNORABLES = memory.data<u8>([\n  18,16,19,20,21,22,23,24,25,26,27,28,29,30,31,32,\n  33,16,16,34,16,16,16,35,36,37,38,39,40,41,16,42,\n  43,16,16,16,16,16,16,16,16,16,16,16,44,45,46,16,\n  47,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  48,16,16,16,49,16,50,51,52,53,54,55,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,56,16,16,57,58,\n  16,59,60,61,16,16,16,16,16,16,62,16,16,63,64,65,\n  66,67,68,69,70,71,72,73,74,75,76,16,77,78,79,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,80,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,81,82,16,16,16,83,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,84,16,16,16,\n  16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,16,\n  16,85,86,16,16,16,16,16,16,16,87,16,16,16,16,16,\n  88,89,90,16,16,16,16,16,91,92,16,16,16,16,16,16,\n  16,16,16,93,16,16,16,16,16,16,16,16,16,16,16,16,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  0,0,0,0,128,64,0,4,0,0,0,64,1,0,0,0,0,0,0,0,0,161,144,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,255,\n  255,255,255,255,255,255,48,4,176,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,248,3,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,130,0,0,0,0,\n  0,0,254,255,255,255,255,191,182,0,0,0,0,0,16,0,63,0,255,23,0,0,0,0,\n  1,248,255,255,0,0,1,0,0,0,0,0,0,0,0,0,0,0,192,191,255,61,0,0,\n  0,128,2,0,0,0,255,255,255,7,0,0,0,0,0,0,0,0,0,0,192,255,1,0,\n  0,0,0,0,0,248,63,36,0,0,192,255,255,63,0,0,0,0,0,14,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,248,255,255,255,255,255,7,0,0,0,0,0,0,20,\n  254,33,254,0,12,0,2,0,2,0,0,0,0,0,0,16,30,32,0,0,12,0,0,64,\n  6,0,0,0,0,0,0,16,134,57,2,0,0,0,35,0,6,0,0,0,0,0,0,16,\n  190,33,0,0,12,0,0,252,2,0,0,0,0,0,0,144,30,32,96,0,12,0,0,0,\n  4,0,0,0,0,0,0,0,1,32,0,0,0,0,0,0,17,0,0,0,0,0,0,192,\n  193,61,96,0,12,0,0,0,2,0,0,0,0,0,0,144,64,48,0,0,12,0,0,0,\n  3,0,0,0,0,0,0,24,30,32,0,0,12,0,0,0,2,0,0,0,0,0,0,0,\n  0,4,92,0,0,0,0,0,0,0,0,0,0,0,242,7,192,127,0,0,0,0,0,0,\n  0,0,0,0,0,0,242,31,64,63,0,0,0,0,0,0,0,0,0,3,0,0,160,2,\n  0,0,0,0,0,0,254,127,223,224,255,254,255,255,255,31,64,0,0,0,0,0,0,0,\n  0,0,0,0,0,224,253,102,0,0,0,195,1,0,30,0,100,32,0,32,0,0,0,0,\n  0,0,0,0,0,0,0,16,0,0,0,0,0,0,0,0,0,0,0,224,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,28,0,0,0,28,0,\n  0,0,12,0,0,0,12,0,0,0,0,0,0,0,176,63,64,254,143,32,0,0,0,0,\n  0,120,0,0,0,0,0,0,8,0,0,0,0,0,0,0,96,0,0,0,0,2,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,135,1,4,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,9,0,0,0,0,\n  0,0,64,127,229,31,248,159,0,0,0,0,128,0,255,255,1,0,0,0,0,0,0,0,\n  15,0,0,0,0,0,208,23,4,0,0,0,0,248,15,0,3,0,0,0,60,59,0,0,\n  0,0,0,0,64,163,3,0,0,0,0,0,0,240,207,0,0,0,0,0,0,0,0,63,\n  0,0,0,0,0,0,0,0,0,0,247,255,253,33,16,3,0,0,0,0,0,240,255,255,\n  255,255,255,255,255,7,0,1,0,0,0,248,255,255,255,255,255,255,255,255,255,255,255,251,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,160,\n  3,224,0,224,0,224,0,96,0,248,0,3,144,124,0,0,0,0,0,0,223,255,2,128,\n  0,0,255,31,0,0,0,0,0,0,255,255,255,255,1,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,48,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,128,0,128,0,0,0,0,0,0,0,0,\n  0,0,0,0,255,255,255,255,0,0,0,0,0,128,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,0,0,0,0,60,62,8,\n  0,0,0,0,0,0,0,0,0,0,0,126,0,0,0,0,0,0,0,0,0,0,0,112,\n  0,0,32,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,63,0,16,0,0,0,0,0,0,\n  0,0,0,0,0,128,247,191,0,0,0,240,0,0,0,0,0,0,0,0,0,0,3,0,\n  255,255,255,255,3,0,0,0,0,0,0,0,0,0,1,0,0,7,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,3,68,8,0,0,96,16,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,48,0,0,0,255,255,3,128,0,0,0,0,192,63,0,0,\n  128,255,3,0,0,0,0,0,7,0,0,0,0,0,200,51,0,128,0,0,96,0,0,0,\n  0,0,0,0,0,126,102,0,8,16,0,0,0,0,1,16,0,0,0,0,0,0,157,193,\n  2,0,0,32,0,48,88,0,0,0,0,0,0,0,0,0,0,0,0,248,0,14,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,32,33,0,0,0,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,252,255,3,0,0,0,0,0,0,0,\n  255,255,8,0,255,255,0,0,0,0,36,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,128,128,64,0,4,0,0,0,64,1,0,0,0,0,0,1,0,\n  0,0,0,192,0,0,0,0,0,0,0,0,8,0,0,14,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,32,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,192,7,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,110,240,0,0,0,0,0,135,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,0,0,0,\n  0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,24,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  192,255,1,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  2,0,0,0,0,0,0,255,127,0,0,0,0,0,0,128,3,0,0,0,0,0,120,38,\n  0,32,0,0,0,0,0,0,7,0,0,0,128,239,31,0,0,0,0,0,0,0,8,0,\n  3,0,0,0,0,0,192,127,0,158,0,0,0,0,0,0,0,0,0,0,0,128,211,64,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,248,7,0,0,\n  3,0,0,0,0,0,0,24,1,0,0,0,192,31,31,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,92,0,0,64,0,0,0,0,\n  0,0,0,0,0,0,248,133,13,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,60,176,1,0,0,48,0,0,0,0,\n  0,0,0,0,0,0,248,167,1,0,0,0,0,0,0,0,0,0,0,0,0,40,191,0,\n  0,0,0,0,0,0,0,0,0,0,0,224,188,15,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,255,6,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,88,8,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,240,12,1,0,0,0,254,7,0,0,0,0,248,121,128,0,126,14,0,0,0,0,\n  0,252,127,3,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,127,191,\n  0,0,0,0,0,0,0,0,0,0,252,255,255,252,109,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,126,180,191,0,0,0,0,0,0,0,0,0,163,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,24,0,0,0,0,0,0,0,255,1,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,31,0,0,0,0,0,0,0,127,0,15,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,128,0,0,0,0,0,0,0,128,255,255,0,0,0,0,0,0,0,0,27,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,96,15,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,128,3,248,255,\n  231,15,0,0,0,60,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  28,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  255,255,255,255,255,255,127,248,255,255,255,255,255,31,32,0,16,0,0,248,254,255,0,0,\n  0,0,0,0,0,0,0,0,127,255,255,249,219,7,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,255,63,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,240,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,127,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  240,15,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,\n  0,0,0,0,0,0,0,248\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const LOWER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  91,92,93,94,95,96,\n  97,98,99,100,101,102,103,104,105,106,107,108,109,\n  110,111,112,113,114,115,116,117,118,119,120,121,122,\n  123,124,125,126,127\n]);\n\n// @ts-ignore: decorator\n@lazy @inline const UPPER127 = memory.data<u8>([\n  0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,\n  16,17,18,19,20,21,22,23,24,25,26,27,28,29,30,31,\n  32,33,34,35,36,37,38,39,40,41,42,43,44,45,46,47,\n  48,49,50,51,52,53,54,55,56,57,58,59,60,61,62,63,\n  64,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  91,92,93,94,95,96,\n  65,66,67,68,69,70,71,72,73,74,75,76,77,\n  78,79,80,81,82,83,84,85,86,87,88,89,90,\n  123,124,125,126,127\n]);\n\n// 23 * 8 = 184 bytes\n// @ts-ignore: decorator\n@lazy @inline const POWERS10 = memory.data<f64>([\n  1e00, 1e01, 1e02, 1e03, 1e04, 1e05, 1e06, 1e07, 1e08, 1e09,\n  1e10, 1e11, 1e12, 1e13, 1e14, 1e15, 1e16, 1e17, 1e18, 1e19,\n  1e20, 1e21, 1e22\n]);\n\n// @ts-ignore: decorator\n@inline\nexport const enum CharCode {\n  PERCENT = 0x25,\n  PLUS = 0x2B,\n  MINUS = 0x2D,\n  DOT = 0x2E,\n  _0 = 0x30,\n  _1 = 0x31,\n  _2 = 0x32,\n  _3 = 0x33,\n  _4 = 0x34,\n  _5 = 0x35,\n  _6 = 0x36,\n  _7 = 0x37,\n  _8 = 0x38,\n  _9 = 0x39,\n  A = 0x41,\n  B = 0x42,\n  E = 0x45,\n  I = 0x49,\n  N = 0x4E,\n  O = 0x4F,\n  X = 0x58,\n  Z = 0x5A,\n  a = 0x61,\n  b = 0x62,\n  e = 0x65,\n  n = 0x6E,\n  o = 0x6F,\n  u = 0x75,\n  x = 0x78,\n  z = 0x7A\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isAscii(c: u32): bool {\n  return !(c >> 7);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isLower8(c: u32): bool {\n  return c - CharCode.a < 26;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isUpper8(c: u32): bool {\n  return c - CharCode.A < 26;\n}\n\nexport function isSpace(c: u32): bool {\n  if (c < 0x1680) { // < <LS> (1)\n    // <SP>, <TAB>, <LF>, <VT>, <FF>, <CR> and <NBSP>\n    // (c == 0x20 || c == 0xA0) was optimized to (c | 0x80) == 0xA0\n    return ((c | 0x80) == 0xA0) || (c - 0x09 <= 0x0D - 0x09);\n  }\n  if (c - 0x2000 <= 0x200A - 0x2000) return true;\n  switch (c) {\n    case 0x1680: // <LS> (1)\n    case 0x2028: // <LS> (2)\n    case 0x2029: // <PS>\n    case 0x202F: // <NNS>\n    case 0x205F: // <MMSP>\n    case 0x3000: // <IS>\n    case 0xFEFF: return true; // <ZWNBSP>\n  }\n  return false;\n}\n\nexport function isAlpha(c: u32): bool {\n  if (isAscii(c)) return (c | 32) - CharCode.a < 26;\n  if (c < 0x20000) {\n    // @ts-ignore: cast\n    return stagedBinaryLookup(ALPHA_TABLE, c);\n  }\n  return c < 0x2FFFE;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCased(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0x1F18A && stagedBinaryLookup(CASED, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isCaseIgnorable(c: u32): bool {\n  // @ts-ignore: cast\n  return c < 0xE01F0 && stagedBinaryLookup(CASE_IGNORABLES, c);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function isFinalSigma(buffer: usize, index: isize, len: isize): bool {\n  const lookaheadLimit = 30; // max lookahead limit\n  let found = false;\n  let pos = index;\n  let minPos = max(0, pos - lookaheadLimit);\n  while (pos > minPos) {\n    let c = codePointBefore(buffer, pos);\n    if (!isCaseIgnorable(c)) {\n      if (isCased(c)) {\n        found = true;\n      } else {\n        return false;\n      }\n    }\n    pos -= isize(c >= 0x10000) + 1;\n  }\n  if (!found) return false;\n  pos = index + 1;\n  let maxPos = min(pos + lookaheadLimit, len);\n  while (pos < maxPos) {\n    let c = <u32>load<u16>(buffer + (pos << 1));\n    if (u32((c & 0xFC00) == 0xD800) & u32(pos + 1 != len)) {\n      let c1 = <u32>load<u16>(buffer + (pos << 1), 2);\n      if ((c1 & 0xFC00) == 0xDC00) {\n        c = (c - 0xD800 << 10) + (c1 - 0xDC00) + 0x10000;\n      }\n    }\n    if (!isCaseIgnorable(c)) {\n      return !isCased(c);\n    }\n    pos += isize(c >= 0x10000) + 1;\n  }\n  return true;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction codePointBefore(buffer: usize, index: isize): i32 {\n  if (index <= 0) return -1;\n  let c = <u32>load<u16>(buffer + (index - 1 << 1));\n  if (u32((c & 0xFC00) == 0xDC00) & u32(index - 2 >= 0)) {\n    let c1 = <u32>load<u16>(buffer + (index - 2 << 1));\n    if ((c1 & 0xFC00) == 0xD800) {\n      return ((c1 & 0x3FF) << 10) + (c & 0x3FF) + 0x10000;\n    }\n  }\n  return (c & 0xF800) == 0xD800 ? 0xFFFD : c;\n}\n\n// Search routine for two-staged lookup tables\nfunction stagedBinaryLookup(table: usize, c: u32): bool {\n  return <bool>((load<u8>(table + (<u32>load<u8>(table + (c >>> 8)) << 5) + ((c & 255) >> 3)) >>> (c & 7)) & 1);\n}\n\nexport function compareImpl(str1: string, index1: usize, str2: string, index2: usize, len: usize): i32 {\n  let ptr1 = changetype<usize>(str1) + (index1 << 1);\n  let ptr2 = changetype<usize>(str2) + (index2 << 1);\n  if (ASC_SHRINK_LEVEL < 2) {\n    if (len >= 4 && !((ptr1 & 7) | (ptr2 & 7))) {\n      do {\n        if (load<u64>(ptr1) != load<u64>(ptr2)) break;\n        ptr1 += 8;\n        ptr2 += 8;\n        len  -= 4;\n      } while (len >= 4);\n    }\n  }\n  while (len--) {\n    let a = <i32>load<u16>(ptr1);\n    let b = <i32>load<u16>(ptr2);\n    if (a != b) return a - b;\n    ptr1 += 2;\n    ptr2 += 2;\n  }\n  return 0;\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toLower8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c | u32(isUpper8(c)) << 5;\n  } else {\n    return <u32>load<u8>(LOWER127 + c);\n  }\n}\n\n// @ts-ignore: decorator\n@inline\nexport function toUpper8(c: u32): u32 {\n  if (ASC_SHRINK_LEVEL > 0) {\n    return c & ~(u32(isLower8(c)) << 5);\n  } else {\n    return <u32>load<u8>(UPPER127 + c);\n  }\n}\n\n/** Parses a string to an integer (usually), using the specified radix. */\nexport function strtol<T>(str: string, radix: i32 = 0): T {\n  let len = str.length;\n  if (!len) {\n    if (isFloat<T>()) {\n      // @ts-ignore: cast\n      return <T>NaN;\n    } else {\n      // @ts-ignore: cast\n      return <T>0;\n    }\n  }\n\n  let ptr = changetype<usize>(str) /* + HEAD -> offset */;\n  let code = <u32>load<u16>(ptr);\n\n  // trim white spaces\n  while (isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  // determine sign\n  // @ts-ignore\n  let sign: T = 1;\n  if (code == CharCode.MINUS || code == CharCode.PLUS) {\n    if (!--len) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    if (code == CharCode.MINUS) {\n      // @ts-ignore: type\n      sign = -1;\n    }\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // See https://tc39.es/ecma262/#sec-parseint-string-radix\n  if (radix) {\n    if (radix < 2 || radix > 36) {\n      if (isFloat<T>()) {\n        // @ts-ignore: cast\n        return <T>NaN;\n      } else {\n        // @ts-ignore: cast\n        return <T>0;\n      }\n    }\n    // handle case as parseInt(\"0xFF\", 16) by spec\n    if (radix == 16) {\n      if (\n        len > 2 &&\n        code == CharCode._0 &&\n        (<u32>load<u16>(ptr, 2) | 32) == CharCode.x\n      ) {\n        ptr += 4; len -= 2;\n      }\n    }\n  } else {\n    // determine radix by literal prefix\n    if (code == CharCode._0 && len > 2) {\n      switch (<u32>load<u16>(ptr, 2) | 32) {\n        case CharCode.b: {\n          ptr += 4; len -= 2;\n          radix = 2;\n          break;\n        }\n        case CharCode.o: {\n          ptr += 4; len -= 2;\n          radix = 8;\n          break;\n        }\n        case CharCode.x: {\n          ptr += 4; len -= 2;\n          radix = 16;\n          break;\n        }\n      }\n    }\n    if (!radix) radix = 10;\n  }\n\n  // calculate value\n  // @ts-ignore: type\n  let num: T = 0;\n  let initial = len - 1;\n  while (len--) {\n    code = <u32>load<u16>(ptr);\n    if (code - CharCode._0 < 10) {\n      code -= CharCode._0;\n    } else if (code - CharCode.A <= <u32>(CharCode.Z - CharCode.A)) {\n      code -= CharCode.A - 10;\n    } else if (code - CharCode.a <= <u32>(CharCode.z - CharCode.a)) {\n      code -= CharCode.a - 10;\n    }\n    if (code >= <u32>radix) {\n      if (initial == len) {\n        if (isFloat<T>()) {\n          // @ts-ignore: cast\n          return <T>NaN;\n        } else {\n          // @ts-ignore: cast\n          return <T>0;\n        }\n      }\n      break;\n    }\n    // @ts-ignore: type\n    num = num * radix + code;\n    ptr += 2;\n  }\n  // @ts-ignore: type\n  return sign * num;\n}\n\nexport function strtod(str: string): f64 {\n  let len = str.length;\n  if (!len) return NaN;\n\n  let ptr  = changetype<usize>(str);\n  let code = <u32>load<u16>(ptr);\n\n  let sign = 1.0;\n  // skip white spaces\n  while (len && isSpace(code)) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (!len) return NaN;\n\n  // try parse '-' or '+'\n  if (code == CharCode.MINUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return NaN;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  // try parse Infinity\n  if (len >= 8 && code == CharCode.I) {\n    if (\n      load<u64>(ptr, 0) == 0x690066006E0049 && // ifnI\n      load<u64>(ptr, 8) == 0x7900740069006E    // ytin\n    ) {\n      return Infinity * sign;\n    }\n    return NaN;\n  }\n  // validate next symbol\n  if (code != CharCode.DOT && <u32>(code - CharCode._0) >= 10) {\n    return NaN;\n  }\n  let savedPtr = ptr;\n  // skip zeros\n  while (code == CharCode._0) {\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  if (len <= 0) return 0.0 * sign;\n  const capacity = 19; // int(64 * 0.3010)\n  let pointed = false;\n  let consumed = 0;\n  let position = 0;\n  let x: u64 = 0;\n  if (code == CharCode.DOT) {\n    let noDigits = !(savedPtr - ptr);\n    ptr += 2; --len;\n    if (!len && noDigits) return NaN;\n    for (pointed = true; (code = <u32>load<u16>(ptr)) == CharCode._0; --position, ptr += 2) --len;\n    if (len <= 0) return 0.0 * sign;\n    if (!position && noDigits && code - CharCode._0 >= 10) return NaN;\n  }\n  for (let digit = code - CharCode._0; digit < 10 || (code == CharCode.DOT && !pointed); digit = code - CharCode._0) {\n    if (digit < 10) {\n      x = consumed < capacity ? 10 * x + digit : x | u64(!!digit);\n      ++consumed;\n    } else {\n      position = consumed;\n      pointed = true;\n    }\n    if (!--len) break;\n    code = <u32>load<u16>(ptr += 2);\n  }\n\n  if (!pointed) position = consumed;\n  return copysign<f64>(scientific(x, position - min(capacity, consumed) + parseExp(ptr, len)), sign);\n}\n\nexport function strtob(str: string): bool {\n  let size: usize = str.length << 1;\n  let offset: usize = 0;\n  if (size > 8) {\n    // try trim end whitespaces first\n    while (size && isSpace(load<u16>(changetype<usize>(str) + size - 2))) size -= 2;\n    if (size > 8) {\n      // trim start whitespaces\n      while (offset < size && isSpace(load<u16>(changetype<usize>(str) + offset))) offset += 2;\n      size -= offset;\n    }\n  }\n  if (size != 8) return false;\n  // \"true\" represents as \\00\\e\\00\\u\\00\\e\\00\\t (00 65 00 75 00 72 00 74)\n  return load<u64>(changetype<usize>(str) + offset) == 0x0065_0075_0072_0074;\n}\n\nexport function joinBooleanArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) return select(\"true\", \"false\", load<bool>(dataStart));\n\n  let sepLen = separator.length;\n  let valueLen = 5; // max possible length of element len(\"false\")\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: bool;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<bool>(dataStart + i);\n    valueLen = 4 + i32(!value);\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(select(\"true\", \"false\", value)),\n      <usize>valueLen << 1\n    );\n    offset += valueLen;\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<bool>(dataStart + <usize>lastIndex);\n  valueLen = 4 + i32(!value);\n  memory.copy(\n    changetype<usize>(result) + (<usize>offset << 1),\n    changetype<usize>(select(\"true\", \"false\", value)),\n    valueLen << 1\n  );\n  offset += valueLen;\n\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinIntegerArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    let value = load<T>(dataStart);\n    if (isSigned<T>()) {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(itoa32(<i32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(itoa64(<i32>value, 10));\n      }\n    } else {\n      if (sizeof<T>() <= 4) {\n        // @ts-ignore: type\n        return changetype<string>(utoa32(<u32>value, 10));\n      } else {\n        // @ts-ignore: type\n        return changetype<string>(utoa64(<u64>value, 10));\n      }\n    }\n  }\n\n  let sepLen = separator.length;\n  const valueLen = (sizeof<T>() <= 4 ? 10 : 20) + i32(isSigned<T>());\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += itoa_buffered<T>(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinFloatArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    return changetype<string>(dtoa(\n      // @ts-ignore: type\n      load<T>(dataStart))\n    );\n  }\n\n  const valueLen = MAX_DOUBLE_LENGTH;\n  let sepLen = separator.length;\n  let estLen = (valueLen + sepLen) * lastIndex + valueLen;\n  let result = changetype<string>(__new(estLen << 1, idof<string>()));\n  let offset = 0;\n  let value: T;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  offset += dtoa_buffered(changetype<usize>(result) + (<usize>offset << 1), value);\n  if (estLen > offset) return result.substring(0, offset);\n  return result;\n}\n\nexport function joinStringArray(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  if (!lastIndex) {\n    // @ts-ignore: type\n    return load<string>(dataStart) || \"\";\n  }\n  let estLen = 0;\n  let value: string;\n  for (let i = 0; i < length; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) estLen += value.length;\n  }\n  let offset = 0;\n  let sepLen = separator.length;\n  let result = changetype<string>(__new((estLen + sepLen * lastIndex) << 1, idof<string>()));\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<string>(dataStart + (<usize>i << alignof<string>()));\n    if (changetype<usize>(value) != 0) {\n      let valueLen = value.length;\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(value),\n        <usize>valueLen << 1\n      );\n      offset += valueLen;\n    }\n    if (sepLen) {\n      memory.copy(\n        changetype<usize>(result) + (<usize>offset << 1),\n        changetype<usize>(separator),\n        <usize>sepLen << 1\n      );\n      offset += sepLen;\n    }\n  }\n  value = load<string>(dataStart + (<usize>lastIndex << alignof<string>()));\n  if (changetype<usize>(value) != 0) {\n    memory.copy(\n      changetype<usize>(result) + (<usize>offset << 1),\n      changetype<usize>(value),\n      <usize>value.length << 1\n    );\n  }\n  return result;\n}\n\nexport function joinReferenceArray<T>(dataStart: usize, length: i32, separator: string): string {\n  let lastIndex = length - 1;\n  if (lastIndex < 0) return \"\";\n  let value: T;\n  if (!lastIndex) {\n    value = load<T>(dataStart);\n    // @ts-ignore: type\n    return value != null ? value.toString() : \"\";\n  }\n  let result = \"\";\n  let sepLen = separator.length;\n  for (let i = 0; i < lastIndex; ++i) {\n    value = load<T>(dataStart + (<usize>i << alignof<T>()));\n    // @ts-ignore: type\n    if (value != null) result += value.toString();\n    if (sepLen) result += separator;\n  }\n  value = load<T>(dataStart + (<usize>lastIndex << alignof<T>()));\n  // @ts-ignore: type\n  if (value != null) result += value.toString();\n  return result;\n}\n\n// @ts-ignore: decorator\n@inline\nfunction scientific(significand: u64, exp: i32): f64 {\n  if (!significand || exp < -342) return 0;\n  if (exp > 308) return Infinity;\n  // Try use fast path\n  // Use fast path for string-to-double conversion if possible\n  // see http://www.exploringbinary.com/fast-path-decimal-to-floating-point-conversion\n  // Simple integer\n  let significandf = <f64>significand;\n  if (!exp) return significandf;\n  if (exp > 22 && exp <= 22 + 15) {\n    significandf *= pow10(exp - 22);\n    exp = 22;\n  }\n  if (significand <= 9007199254740991 && abs(exp) <= 22) {\n    if (exp > 0) return significandf * pow10(exp);\n    return significandf / pow10(-exp);\n  } else if (exp < 0) {\n    return scaledown(significand, exp);\n  } else {\n    return scaleup(significand, exp);\n  }\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaledown(significand: u64, exp: i32): f64 {\n  const denom: u64 = 6103515625; // 1e14 * 0x1p-14\n  const scale = reinterpret<f64>(0x3F06849B86A12B9B); // 1e-14 * 0x1p32\n\n  let shift = clz(significand);\n  significand <<= shift;\n  shift = exp - shift;\n\n  for (; exp <= -14; exp += 14) {\n    let q = significand / denom;\n    let r = significand % denom;\n    let s = clz(q);\n    significand = (q << s) + <u64>nearest(scale * <f64>(r << (s - 18)));\n    shift -= s;\n  }\n  let b = <u64>ipow32(5, -exp);\n  let q = significand / b;\n  let r = significand % b;\n  let s = clz(q);\n  significand = (q << s) + <u64>(reinterpret<f64>(reinterpret<u64>(<f64>r) + (s << 52)) / <f64>b);\n  shift -= s;\n\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction scaleup(significand: u64, exp: i32): f64 {\n  const coeff: u32 = 1220703125; // 1e13 * 0x1p-13;\n  let shift = ctz(significand);\n  significand >>= shift;\n  shift += exp;\n\n  __fixmulShift = shift;\n  for (; exp >= 13; exp -= 13) {\n    significand = fixmul(significand, coeff);\n  }\n  significand = fixmul(significand, <u32>ipow32(5, exp));\n  shift = __fixmulShift;\n  return NativeMath.scalbn(<f64>significand, <i32>shift);\n}\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction parseExp(ptr: usize, len: i32): i32 {\n  let sign = 1, magnitude = 0;\n  let code = <u32>load<u16>(ptr);\n  // check code is 'e' or 'E'\n  if ((code | 32) != CharCode.e) return 0;\n\n  if (!--len) return 0;\n  code = <u32>load<u16>(ptr += 2);\n  if (code == CharCode.MINUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n    sign = -1;\n  } else if (code == CharCode.PLUS) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  // skip zeros\n  while (code == CharCode._0) {\n    if (!--len) return 0;\n    code = <u32>load<u16>(ptr += 2);\n  }\n  for (let digit: u32 = code - CharCode._0; len && digit < 10; digit = code - CharCode._0) {\n    if (magnitude >= 3200) return sign * 3200;\n    magnitude = 10 * magnitude + digit;\n    code = <u32>load<u16>(ptr += 2);\n    --len;\n  }\n  return sign * magnitude;\n}\n\n// @ts-ignore: decorator\n@lazy let __fixmulShift: u64 = 0;\n\n// Adopted from metallic lib:\n// https://github.com/jdh8/metallic/blob/master/src/stdlib/parse/scientific.h\n// @ts-ignore: decorator\n@inline\nfunction fixmul(a: u64, b: u32): u64 {\n  let low  = (a & 0xFFFFFFFF) * b;\n  let high = (a >> 32) * b + (low >> 32);\n  let overflow = <u32>(high >> 32);\n  let space = clz(overflow);\n  let revspace: u64 = 32 - space;\n  __fixmulShift += revspace;\n  return (high << space | (low & 0xFFFFFFFF) >> revspace) + (low << space >> 31 & 1);\n}\n\n// @ts-ignore: decorator\n@inline\nfunction pow10(n: i32): f64 {\n  // argument `n` should bounds in [0, 22] range\n  return load<f64>(POWERS10 + (n << alignof<f64>()));\n}\n","import { i128, u128, u256 } from 'as-bignum/assembly';\nimport { Result } from './result';\nimport { Serializable } from './serializable';\nimport * as ser from './serialization';\n\n/**\n * Args for remote function call.\n *\n * @remarks\n * - This class can serialize assembly script native types into bytes, in order to\n *   make smart-contract function call easier.\n *\n * - In a smart-contract exposed function, use this class to deserialize the string\n *   argument, using the `next...` methods.\n *\n * - In a smart-contract, to call another smart-contract function, use this class\n *   to serialize the arguments you want to pass to the smart-contract function\n *   call.\n *\n */\nexport class Args {\n  private _offset: i32 = 0;\n  private serialized: StaticArray<u8> = new StaticArray<u8>(0);\n\n  /**\n   * Initializes a new instance of Args.\n   *\n   * @param serialized - The serialized arguments. Default: []\n   * @param offset - The offset to start deserializing from. Default: 0\n   *\n   */\n  constructor(serialized: StaticArray<u8> = [], offset: i32 = 0) {\n    this.serialized = serialized;\n    this._offset = offset;\n  }\n\n  /**\n   * Gets the offset to start deserializing from.\n   *\n   * @returns the offset\n   */\n  get offset(): i32 {\n    return this._offset;\n  }\n\n  /**\n   * Returns the serialized arguments.\n   *\n   * @returns The serialized arguments as a static array of bytes.\n   */\n  serialize(): StaticArray<u8> {\n    return this.serialized;\n  }\n\n  // getters\n\n  /**\n   * Deserializes a string from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result object containing an empty string and an error message:\n   * \"can't deserialize string from given argument: out of range\".\n   * In this case, the offset will not be changed.\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized string starting from the current offset.\n   * - Containing an empty string and an error message if the deserialization failed.\n   *\n   */\n  nextString(): Result<string> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        '',\n        \"can't deserialize string from given argument: out of range\",\n      );\n    }\n\n    const value = ser.bytesToString(this.getNextData(length.unwrap()));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes a bytes array from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing an empty StaticArray of u8\n   * and an error message: \"can't deserialize bytes from given argument: out of range\".\n   * In this case, the offset will not be changed.\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized StaticArray of u8 starting from the current offset\n   * - Containing an empty StaticArray and an error message if the deserialization failed\n   *\n   */\n  nextBytes(): Result<StaticArray<u8>> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        new StaticArray<u8>(0),\n        \"can't deserialize bytes from given argument: out of range\",\n      );\n    }\n\n    const bufferSize = length.unwrap();\n    if (!bufferSize) {\n      return new Result([]);\n    }\n\n    const value = this.getNextData(bufferSize);\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an array of fixed size elements\n   * starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result object containing an empty array and an error message:\n   * \"can't deserialize length of array from given argument\".\n   * In this case, the offset will not be changed.\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized array of fixed size elements\n   * - Containing an empty array and an error message if the deserialization failed\n   */\n  nextFixedSizeArray<T>(): Result<T[]> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        [],\n        \"can't deserialize length of array from given argument\",\n      );\n    }\n\n    const bufferSize = length.unwrap();\n    if (!bufferSize) {\n      return new Result([]);\n    }\n\n    const buffer = this.getNextData(bufferSize);\n\n    let value: T[] = [];\n    if (isBoolean<T>() || isInteger<T>() || isFloat<T>()) {\n      // Optimized implementation for native types\n      value = ser.bytesToNativeTypeArray<T>(buffer);\n    } else {\n      value = ser.bytesToFixedSizeArray<T>(buffer);\n    }\n\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an array of strings starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result object containing an empty array and an error message:\n   * \"can't deserialize length of array from given argument\".\n   * In this case, the offset will not be changed.\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized array of strings\n   * - Containing an empty array and an error message if the deserialization failed\n   */\n  nextStringArray(): Result<string[]> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        [],\n        \"can't deserialize length of array from given argument\",\n      );\n    }\n\n    const bufferSize = length.unwrap();\n    if (!bufferSize) {\n      return new Result([]);\n    }\n\n    const value: string[] = [];\n    const startOffset = this._offset;\n    while (this._offset < startOffset + bufferSize) {\n      const u32Size = sizeof<u32>();\n      const strLen = ser.bytesToU32(this.getNextData(<i32>u32Size));\n      value.push(ser.bytesToString(this.getNextData(strLen)));\n    }\n\n    // Note: no need to update this._offset at this point, previous call to getNextData already did\n    // this._offset += bufferSize;\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an array of serializable objects from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing an empty array and an error message:\n   * \"can't deserialize length of array from given argument\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized array of objects that implement Serializable objects starting from the current\n   *    offset\n   * - Containing an empty array and an error message if the deserialization failed\n   *\n   */\n  nextSerializableObjectArray<T extends Serializable>(): Result<T[]> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        [],\n        \"can't deserialize length of array from given argument\",\n      );\n    }\n\n    const bufferSize = length.unwrap();\n\n    if (bufferSize === 0) {\n      return new Result([]);\n    }\n\n    const buffer = this.getNextData(bufferSize);\n\n    const value = ser.bytesToSerializableObjectArray<T>(buffer);\n    return value;\n  }\n\n  /**\n   * Deserializes an array of u8 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing an empty Uint8Array and an error message:\n   * \"can't deserialize Uint8Array from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized array of u8 starting from the current offset\n   * - Containing an empty Uint8Array and an error message if the deserialization failed\n   *\n   */\n  nextUint8Array(): Result<Uint8Array> {\n    const length = this.nextU32();\n    if (\n      length.isErr() ||\n      this._offset + length.unwrap() > this.serialized.length\n    ) {\n      return new Result(\n        new Uint8Array(0),\n        \"can't deserialize Uint8Array from given argument: out of range\",\n      );\n    }\n\n    const value = ser.wrapStaticArray(this.getNextData(length.unwrap()));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an u256 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u256 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized u256 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU256(): Result<u256> {\n    const size: i32 = 32;\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        u256.Zero,\n        \"can't deserialize u256 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToU256(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an U128 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u128 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized U128 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU128(): Result<u128> {\n    const size: i32 = 16;\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        u128.Zero,\n        \"can't deserialize u128 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToU128(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an I128 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize i128 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized I128 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextI128(): Result<i128> {\n    const size: i32 = 16;\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        i128.Zero,\n        \"can't deserialize i128 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToI128(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an U64 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u64 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized U64 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU64(): Result<u64> {\n    const size: i32 = sizeof<u64>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize u64 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToU64(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an I64 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize i64 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized I64 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextI64(): Result<i64> {\n    const size: i32 = sizeof<i64>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize i64 from given argument: out of range\",\n      );\n    }\n\n    const value = ser.bytesToI64(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an f64 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize f64 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized f64 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   */\n  nextF64(): Result<f64> {\n    const size: i32 = sizeof<f64>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize f64 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToF64(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an F32 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize f32 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized f32 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextF32(): Result<f32> {\n    const size: i32 = sizeof<f32>();\n    if (this._offset + sizeof<f32>() > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize f32 from given argument: out of range\",\n      );\n    }\n\n    const value = ser.bytesToF32(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an u16 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u16 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized u16 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU16(): Result<u16> {\n    const size: i32 = sizeof<u16>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize u16 from given argument: out of range\",\n      );\n    }\n\n    const value = ser.bytesToU16(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an i16 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize i16 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized i16 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextI16(): Result<i16> {\n    const size: i32 = sizeof<i16>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize i16 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToI16(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an u32 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u32 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized u32 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU32(): Result<u32> {\n    const size: i32 = sizeof<u32>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize u32 from given argument: out of range\",\n      );\n    }\n\n    const value = ser.bytesToU32(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an i32 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize i32 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized i32 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextI32(): Result<i32> {\n    const size: i32 = sizeof<i32>();\n    if (this._offset + size > this.serialized.length) {\n      return new Result(\n        0,\n        \"can't deserialize i32 from given argument: out of range\",\n      );\n    }\n    const value = ser.bytesToI32(this.getNextData(size));\n    return new Result(value);\n  }\n\n  /**\n   * Deserializes an u8 from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing 0 and an error message:\n   * \"can't deserialize u8 from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized u8 starting from the current offset\n   * - Containing 0 and an error message if the deserialization failed\n   *\n   */\n  nextU8(): Result<u8> {\n    if (this._offset + sizeof<u8>() > this.serialized.length) {\n      return new Result(\n        u8(0),\n        \"can't deserialize u8 from given argument: out of range\",\n      );\n    }\n\n    return new Result(this.serialized[this._offset++]);\n  }\n\n  /**\n   * Deserializes a boolean from a serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing false and an error message:\n   * \"can't deserialize bool from given argument: out of range\".\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized boolean starting from the current offset\n   * - Containing false and an error message if the deserialization failed\n   *\n   */\n  nextBool(): Result<bool> {\n    if (this._offset + sizeof<u8>() > this.serialized.length) {\n      return new Result(\n        false,\n        \"can't deserialize bool from given argument: out of range\",\n      );\n    }\n\n    return new Result(!!this.serialized[this._offset++]);\n  }\n\n  /**\n   * Deserialize an object by calling its `deserialize` method.\n   *\n   * @remarks\n   * If the deserialization failed, it returns a Result containing the object and an error message:\n   * \"Can't deserialize object \" + type of the object.\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized object starting from the current offset\n   * - Containing the object and an error message if the deserialization failed\n   *\n   */\n  nextSerializable<T extends Serializable>(): Result<T> {\n    const object = instantiate<T>();\n    const result = object.deserialize(this.serialized, this._offset);\n    if (result.isErr()) {\n      return new Result(object, `Can't deserialize object ${typeof object}`);\n    }\n    this._offset = result.unwrap();\n    return new Result(object);\n  }\n\n  /**\n   * This function retrieves the next chunk of data from the serialized data array based on the specified size\n   * and returns it as a static array of unsigned 8-bit integers.\n   *\n   *\n   * @param size - The data size\n   *\n   * @returns the data of requested size for current offset\n   */\n  private getNextData(size: i32): StaticArray<u8> {\n    const data = changetype<StaticArray<u8>>(\n      this.serialized.slice(this._offset, this._offset + size).dataStart,\n    );\n    this._offset += size;\n    return data;\n  }\n\n  /**\n   * Deserializes the next object from the serialized array starting from the current offset.\n   *\n   * @remarks\n   * If the deserialization failed, it returns an error message:\n   * \"args doesn't know how to deserialize the given type.\"\n   *\n   * @typeParam T - The type of the object to deserialize\n   * @typeParam U - The type of the object to instantiate if the object is an array of serializable objects\n   *\n   * @returns a Result object:\n   * - Containing the next deserialized object starting from the current offset\n   * - Containing an error message if the deserialization failed\n   *\n   */\n  next<T, U = void>(): Result<T> {\n    if (isBoolean<T>()) {\n      return this.nextBool() as Result<T>;\n    } else if (isInteger<T>()) {\n      if (isSigned<T>()) {\n        if (sizeof<T>() === sizeof<i16>()) {\n          return this.nextI16() as Result<T>;\n        } else if (sizeof<T>() === sizeof<i32>()) {\n          return this.nextI32() as Result<T>;\n        } else if (sizeof<T>() === sizeof<i64>()) {\n          return this.nextI64() as Result<T>;\n        }\n      } else {\n        if (sizeof<T>() === sizeof<u8>()) {\n          return this.nextU8() as Result<T>;\n        } else if (sizeof<T>() === sizeof<u16>()) {\n          return this.nextU16() as Result<T>;\n        } else if (sizeof<T>() === sizeof<u32>()) {\n          return this.nextU32() as Result<T>;\n        } else if (sizeof<T>() === sizeof<u64>()) {\n          return this.nextU64() as Result<T>;\n        }\n      }\n    } else if (isFloat<T>()) {\n      if (sizeof<T>() === sizeof<f32>()) {\n        return this.nextF32() as Result<T>;\n      } else {\n        return this.nextF64() as Result<T>;\n      }\n    } else if (isString<T>()) {\n      return this.nextString() as Result<T>;\n    } else if (isArray<T>()) {\n      if (idof<T>() === idof<Array<u8>>()) {\n        return this.nextFixedSizeArray<u8>() as Result<T>;\n      } else if (idof<T>() === idof<Array<string>>()) {\n        return this.nextStringArray() as Result<T>;\n      } else if (idof<T>() === idof<Array<i128>>()) {\n        return this.nextFixedSizeArray<i128>() as Result<T>;\n      } else if (idof<T>() === idof<Array<u128>>()) {\n        return this.nextFixedSizeArray<u128>() as Result<T>;\n      } else if (idof<T>() === idof<Array<u256>>()) {\n        return this.nextFixedSizeArray<u256>() as Result<T>;\n      } else if (idof<T>() === idof<Array<i32>>()) {\n        return this.nextFixedSizeArray<i32>() as Result<T>;\n      } else if (idof<T>() === idof<Array<u32>>()) {\n        return this.nextFixedSizeArray<u32>() as Result<T>;\n      } else if (idof<T>() === idof<Array<i64>>()) {\n        return this.nextFixedSizeArray<i64>() as Result<T>;\n      } else if (idof<T>() === idof<Array<u64>>()) {\n        return this.nextFixedSizeArray<u64>() as Result<T>;\n      } else if (idof<T>() === idof<Array<f32>>()) {\n        return this.nextFixedSizeArray<f32>() as Result<T>;\n      } else if (idof<T>() === idof<Array<f64>>()) {\n        return this.nextFixedSizeArray<f64>() as Result<T>;\n      } else if (idof<T>() === idof<Array<bool>>()) {\n        return this.nextFixedSizeArray<bool>() as Result<T>;\n      } else {\n        const object = instantiate<U>();\n        if (object instanceof Serializable) {\n          return this.nextSerializableObjectArray<U>() as Result<T>;\n        }\n      }\n    } else if (isManaged<T>()) {\n      if (idof<T>() === idof<string>()) {\n        return this.nextString() as Result<T>;\n      } else if (idof<T>() === idof<Uint8Array>()) {\n        return this.nextUint8Array() as Result<T>;\n      } else if (idof<T>() === idof<StaticArray<u8>>()) {\n        return this.nextBytes() as Result<T>;\n      } else if (idof<T>() === idof<i128>()) {\n        return this.nextI128() as Result<T>;\n      } else if (idof<T>() === idof<u128>()) {\n        return this.nextU128() as Result<T>;\n      } else if (idof<T>() === idof<u256>()) {\n        return this.nextU256() as Result<T>;\n      } else {\n        const object = instantiate<T>();\n        if (object instanceof Serializable) {\n          return this.nextSerializable<T>() as Result<T>;\n        }\n      }\n    }\n\n    ERROR(\"args doesn't know how to deserialize the given type.\");\n  }\n\n  /**\n   * Deserialize the next object from the serialized array starting from the current offset.\n   *\n   * @typeParam T - The type of the object to deserialize\n   * @typeParam U - The type of the object to instantiate if the object is an array of serializable objects\n   *\n   * @param field - The field name of the object to deserialize\n   *\n   * @returns the next deserialized object starting from the current offset\n   *\n   * @throws an error message if the deserialization failed: \"Can't deserialize \" + field\n   */\n  mustNext<T, U = void>(field: string): T {\n    return this.next<T, U>().expect(`Can't deserialize ${field}.`);\n  }\n\n  // Setter\n\n  /**\n   * This method adds an argument to the serialized byte array if the argument is an\n   * instance of a handled type (bool, String of u32.MAX_VALUE characters maximum,\n   * Uint8Array, StaticArray<u8>, u8, u32, i32, u64, i64, f32, f64, Serializable).\n   *\n   * @remarks\n   * If the type of the object to add isn't handled, it returns an error message:\n   * \"args doesn't know how to serialize the given type.\"\n   *\n   * @param arg - the argument to add\n   * @typeParam T - The type of the object to deserialize\n   * @typeParam U - The type of the object to instantiate if the object is an array of serializable objects\n   * @returns the modified Arg instance\n   */\n  add<T, U = void>(arg: T): Args {\n    if (arg instanceof bool) {\n      this.serialized = this.serialized.concat(ser.boolToByte(<bool>arg));\n    } else if (arg instanceof String) {\n      const serialized = ser.stringToBytes(<string>arg);\n      this.add<u32>(serialized.length);\n      this.serialized = this.serialized.concat(serialized);\n    } else if (arg instanceof Uint8Array) {\n      this.add<u32>(arg.length);\n      this.serialized = this.serialized.concat(ser.unwrapStaticArray(arg));\n    } else if (arg instanceof StaticArray<u8>) {\n      this.add<u32>(arg.length);\n      this.serialized = this.serialized.concat(arg);\n    } else if (arg instanceof u8) {\n      this.serialized = this.serialized.concat(ser.u8toByte(<u8>arg));\n    } else if (arg instanceof u16 || arg instanceof i16) {\n      this.serialized = this.serialized.concat(ser.u16ToBytes(<u16>arg));\n    } else if (arg instanceof u32 || arg instanceof i32) {\n      this.serialized = this.serialized.concat(ser.u32ToBytes(<u32>arg));\n    } else if (arg instanceof u64 || arg instanceof i64) {\n      this.serialized = this.serialized.concat(ser.u64ToBytes(<u64>arg));\n    } else if (arg instanceof f32) {\n      this.serialized = this.serialized.concat(ser.f32ToBytes(<f32>arg));\n    } else if (arg instanceof f64) {\n      this.serialized = this.serialized.concat(ser.f64ToBytes(<f64>arg));\n    } else if (arg instanceof i128) {\n      this.serialized = this.serialized.concat(ser.i128ToBytes(<i128>arg));\n    } else if (arg instanceof u128) {\n      this.serialized = this.serialized.concat(ser.u128ToBytes(<u128>arg));\n    } else if (arg instanceof u256) {\n      this.serialized = this.serialized.concat(ser.u256ToBytes(<u256>arg));\n      // @ts-ignore\n    } else if (arg instanceof Serializable) {\n      this.serialized = this.serialized.concat(\n        (arg as Serializable).serialize(),\n      );\n    } else if (\n      // prettier-ignore\n      (arg instanceof Array<bool>) || (arg instanceof Array<u8>)\n      || (arg instanceof Array<u32>) || (arg instanceof Array<i32>)\n      || (arg instanceof Array<u64>) || (arg instanceof Array<i64>)\n      || (arg instanceof Array<f32>) || (arg instanceof Array<f64>)\n    ) {\n      const content = ser.nativeTypeArrayToBytes(arg);\n      this.add<u32>(content.length);\n      this.serialized = this.serialized.concat(content);\n    } else if (\n      arg instanceof Array<i128> ||\n      arg instanceof Array<u128> ||\n      arg instanceof Array<u256>\n    ) {\n      const content = ser.fixedSizeArrayToBytes(arg);\n      this.add<u32>(content.length);\n      this.serialized = this.serialized.concat(content);\n    } else if (arg instanceof Array<string>) {\n      let totalLength: u32 = 0;\n      let serialized = new StaticArray<u8>(0);\n      // serialize each string element with its length followed by its content\n      for (let i = 0; i < arg.length; i++) {\n        const strBytes = ser.stringToBytes(arg[i]);\n        serialized = serialized\n          .concat(ser.u32ToBytes(strBytes.length))\n          .concat(strBytes);\n        totalLength += <u32>sizeof<u32>() + strBytes.length;\n      }\n      this.add<u32>(totalLength);\n      this.serialized = this.serialized.concat(serialized);\n    } else if (isArray<T>()) {\n      const object = instantiate<U>();\n      if (object instanceof Serializable) {\n        return this.addSerializableObjectArray<U>(arg);\n      }\n    } else {\n      ERROR(\"args doesn't know how to serialize the given type.\");\n    }\n    return this;\n  }\n\n  /**\n   * This method adds an array of elements that implement `Serializable`.\n   *\n   * @remarks\n   * This will perform a deep copy of your objects thanks to the `serialize` method you define in your class.\n   *\n   * @see {@link Serializable}\n   *\n   * @param arg - the argument to add\n   * @returns the modified Arg instance\n   */\n  addSerializableObjectArray<T extends Serializable>(arg: T[]): Args {\n    const content = ser.serializableObjectsArrayToBytes<T>(arg);\n    this.add<u32>(content.length);\n    this.serialized = this.serialized.concat(content);\n    return this;\n  }\n}\n\nexport const NoArg: Args = new Args();\n","// This file is shared with the compiler and must remain portable\n\n/** Runtime types. */\nexport enum Runtime {\n  /** Simple bump allocator without GC. */\n  Stub = 0,\n  /** Stop the world semi-automatic GC. */\n  Minimal = 1,\n  /** incremental GC. */\n  Incremental = 2,\n}\n","import { Typeinfo, TypeinfoFlags } from \"./shared/typeinfo\";\nimport { E_INDEXOUTOFRANGE } from \"./util/error\";\nimport { ArrayBufferView } from \"./arraybuffer\";\n\n// @ts-ignore: decorator\n@builtin\nexport declare const __rtti_base: usize;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_globals(cookie: u32): void;\n\n// @ts-ignore: decorator\n@builtin @unsafe\nexport declare function __visit_members(ref: usize, cookie: u32): void;\n\n// @ts-ignore: decorator\n@unsafe\nexport function __typeinfo(id: u32): TypeinfoFlags {\n  let ptr = __rtti_base;\n  if (id > load<u32>(ptr)) throw new Error(E_INDEXOUTOFRANGE);\n  return changetype<Typeinfo>(ptr + sizeof<u32>() + id * offsetof<Typeinfo>()).flags;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newBuffer(size: usize, id: u32, data: usize = 0): usize {\n  let buffer = __new(size, id);\n  if (data) memory.copy(buffer, data, size);\n  return buffer;\n}\n\n// @ts-ignore: decorator\n@unsafe\nexport function __newArray(length: i32, alignLog2: usize, id: u32, data: usize = 0): usize {\n  let bufferSize = <usize>length << alignLog2;\n  // make sure `buffer` is tracked by the shadow stack\n  let buffer = changetype<ArrayBuffer>(__newBuffer(bufferSize, idof<ArrayBuffer>(), data));\n  // ...since allocating the array may trigger GC steps\n  let array = __new(offsetof<i32[]>(), id);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"buffer\"));\n  __link(array, changetype<usize>(buffer), false);\n  store<usize>(array, changetype<usize>(buffer), offsetof<ArrayBufferView>(\"dataStart\"));\n  store<i32>(array, bufferSize, offsetof<ArrayBufferView>(\"byteLength\"));\n  store<i32>(array, length, offsetof<i32[]>(\"length_\"));\n  return array;\n}\n\n// @ts-ignore: decorator\n@global @unsafe\nfunction __tostack(ptr: usize): usize { // eslint-disable-line\n  return ptr;\n}\n\n// These are provided by the respective implementation, included as another entry file by asc:\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __alloc(size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __realloc(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __free(ptr: usize): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __new(size: usize, id: u32): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __renew(ptr: usize, size: usize): usize;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __link(parentPtr: usize, childPtr: usize, expectMultiple: bool): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __collect(): void;\n\n// // @ts-ignore: decorator\n// @builtin @unsafe\n// export declare function __visit(ptr: usize, cookie: u32): void;\n","// Common error messages for use across the standard library. Keeping error messages compact\n// and reusing them where possible ensures minimal static data in binaries.\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INDEXOUTOFRANGE: string = \"Index out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_VALUEOUTOFRANGE: string = \"Value out of range\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDLENGTH: string = \"Invalid length\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_EMPTYARRAY: string = \"Array is empty\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_HOLEYARRAY: string = \"Element type must be nullable if array is holey\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOTIMPLEMENTED: string = \"Not implemented\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_KEYNOTFOUND: string = \"Key does not exist\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALLOCATION_TOO_LARGE: string = \"Allocation too large\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_ALREADY_PINNED: string = \"Object already pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_NOT_PINNED: string = \"Object is not pinned\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_URI_MALFORMED: string = \"URI malformed\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_INVALIDDATE: string = \"Invalid Date\";\n\n// @ts-ignore: decorator\n@lazy @inline\nexport const E_UNPAIRED_SURROGATE: string = \"Unpaired surrogate\";\n","import { compareImpl } from \"./string\";\n\ntype Comparator<T> = (a: T, b: T) => i32;\n\n// @ts-ignore: decorator\n@lazy @inline const EMPTY = u32.MAX_VALUE;\n// @ts-ignore: decorator\n@inline const INSERTION_SORT_THRESHOLD = 48;\n// @ts-ignore: decorator\n@inline const MIN_RUN_LENGTH = 32;\n\n// @ts-ignore: decorator\n@inline\nfunction log2u(n: u32): u32 {\n  return 31 - clz(n);\n}\n\n// @ts-ignore: decorator\n@inline\nexport function COMPARATOR<T>(): Comparator<T> {\n  if (isInteger<T>()) {\n    if (isSigned<T>() && sizeof<T>() <= 4) {\n      return (a, b) => i32(a) - i32(b);\n    } else {\n      return (a, b) => i32(a > b) - i32(a < b);\n    }\n  } else if (isFloat<T>()) {\n    if (sizeof<T>() == 4) {\n      return (a, b) => {\n        let ia = reinterpret<i32>(f32(a));\n        let ib = reinterpret<i32>(f32(b));\n        ia ^= ia >> 31 >>> 1;\n        ib ^= ib >> 31 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    } else {\n      return (a, b) => {\n        let ia = reinterpret<i64>(f64(a));\n        let ib = reinterpret<i64>(f64(b));\n        ia ^= ia >> 63 >>> 1;\n        ib ^= ib >> 63 >>> 1;\n        return i32(ia > ib) - i32(ia < ib);\n      };\n    }\n  } else if (isString<T>()) {\n    return (a, b) => {\n      if (\n        changetype<usize>(a) == changetype<usize>(b) ||\n        changetype<usize>(a) == 0 ||\n        changetype<usize>(b) == 0\n      ) return 0;\n      let alen = changetype<string>(a).length;\n      let blen = changetype<string>(b).length;\n      if (!(alen | blen)) return 0;\n      if (!alen) return -1;\n      if (!blen) return  1;\n      let res = compareImpl(\n        changetype<string>(a), 0,\n        changetype<string>(b), 0,\n        <usize>min(alen, blen)\n      );\n      return res ? res : alen - blen;\n    };\n  } else {\n    return (a, b) => i32(a > b) - i32(a < b);\n  }\n}\n\n// Power Sort implementation (stable) from paper \"Nearly-Optimal Mergesorts\"\n// https://arxiv.org/pdf/1805.04154.pdf\n// This method usually outperform TimSort.\n// TODO: refactor c >>> 31 to c < 0 when binaryen will support this opt\nexport function SORT<T>(\n  ptr: usize,\n  len: i32,\n  comparator: Comparator<T>\n): void {\n  if (len <= INSERTION_SORT_THRESHOLD) {\n    if (len <= 1) return;\n    if (ASC_SHRINK_LEVEL < 1) {\n      switch (len) {\n        case 3: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          a = select<T>(a, b, c);\n          b = load<T>(ptr, 2 << alignof<T>());\n          c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 1 << alignof<T>());\n          store<T>(ptr, select<T>(a, b, c), 2 << alignof<T>());\n        }\n        case 2: {\n          let a = load<T>(ptr, 0);\n          let b = load<T>(ptr, 1 << alignof<T>());\n          let c = comparator(a, b) > 0;\n          store<T>(ptr, select<T>(b, a, c), 0);\n          store<T>(ptr, select<T>(a, b, c), 1 << alignof<T>());\n          return;\n        }\n      }\n    }\n    insertionSort<T>(ptr, 0, len - 1, 0, comparator);\n    return;\n  }\n\n  let lgPlus2         = log2u(len) + 2;\n  let lgPlus2Size     = lgPlus2 << alignof<u32>();\n  let leftRunStartBuf = __alloc(lgPlus2Size << 1);\n  let leftRunEndBuf   = leftRunStartBuf + lgPlus2Size;\n\n  for (let i: u32 = 0; i < lgPlus2; ++i) {\n    store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n  }\n\n  let buffer = __alloc(len << alignof<T>());\n\n  let hi   = len - 1;\n  let endA = extendRunRight<T>(ptr, 0, hi, comparator);\n  let lenA = endA + 1;\n\n  if (lenA < MIN_RUN_LENGTH) {\n    endA = min(hi, MIN_RUN_LENGTH - 1);\n    insertionSort<T>(ptr, 0, endA, lenA, comparator);\n  }\n\n  let top: u32 = 0, startA = 0;\n  while (endA < hi) {\n    let startB = endA + 1;\n    let endB = extendRunRight<T>(ptr, startB, hi, comparator);\n    let lenB = endB - startB + 1;\n\n    if (lenB < MIN_RUN_LENGTH) {\n      endB = min(hi, startB + MIN_RUN_LENGTH - 1);\n      insertionSort<T>(ptr, startB, endB, lenB, comparator);\n    }\n\n    let k = nodePower(0, hi, startA, startB, endB);\n\n    for (let i = top; i > k; --i) {\n      let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n      if (start != EMPTY) {\n        mergeRuns<T>(\n          ptr,\n          start,\n          load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n          endA,\n          buffer,\n          comparator\n        );\n        startA = start;\n        store<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()), EMPTY);\n      }\n    }\n\n    store<u32>(leftRunStartBuf + (<usize>k << alignof<u32>()), startA);\n    store<u32>(leftRunEndBuf   + (<usize>k << alignof<u32>()), endA);\n    startA = startB;\n    endA = endB;\n    top = k;\n  }\n\n  for (let i = top; i != 0; --i) {\n    let start = load<u32>(leftRunStartBuf + (<usize>i << alignof<u32>()));\n    if (start != EMPTY) {\n      mergeRuns<T>(\n        ptr,\n        start,\n        load<u32>(leftRunEndBuf + (<usize>i << alignof<u32>())) + 1,\n        hi,\n        buffer,\n        comparator\n      );\n    }\n  }\n  // dealloc aux buffers\n  __free(buffer);\n  __free(leftRunStartBuf);\n}\n\nfunction insertionSort<T>(\n  ptr: usize,\n  left: i32,\n  right: i32,\n  presorted: i32,\n  comparator: Comparator<T>\n): void {\n  if (ASC_SHRINK_LEVEL >= 1) {\n    // slightly improved original insertion sort\n    for (let i = left + presorted; i <= right; ++i) {\n      let j = i - 1;\n      let a = load<T>(ptr + (<usize>i << alignof<T>()));\n      while (j >= left) {\n        let b = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, b) < 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), b, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>());\n    }\n  } else {\n    // even-odd two-way insertion sort which allow increase minRunLen\n    let range = right - left + 1;\n    let i = left + select(range & 1, presorted - ((range - presorted) & 1), presorted == 0);\n    for (; i <= right; i += 2) {\n      let a = load<T>(ptr + (<usize>i << alignof<T>()), 0);\n      let b = load<T>(ptr + (<usize>i << alignof<T>()), 1 << alignof<T>());\n      let min = b, max = a;\n      if (comparator(a, b) <= 0) {\n        min = a, max = b;\n      }\n      let j = i - 1;\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, max) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 2 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), max, 2 << alignof<T>());\n      while (j >= left) {\n        a = load<T>(ptr + (<usize>j << alignof<T>()));\n        if (comparator(a, min) > 0) {\n          store<T>(ptr + (<usize>j << alignof<T>()), a, 1 << alignof<T>()); --j;\n        } else break;\n      }\n      store<T>(ptr + (<usize>j << alignof<T>()), min, 1 << alignof<T>());\n    }\n  }\n}\n\nfunction nodePower(left: u32, right: u32, startA: u32, startB: u32, endB: u32): u32 {\n  let n: u64 = right - left + 1;\n  let s = startB - (left << 1);\n  let l = startA + s;\n  let r = endB   + s + 1;\n  let a = (<u64>l << 30) / n;\n  let b = (<u64>r << 30) / n;\n  return clz(<u32>(a ^ b));\n}\n\nfunction extendRunRight<T>(\n  ptr: usize,\n  i: i32,\n  right: i32,\n  comparator: Comparator<T>\n): i32 {\n  if (i == right) return i;\n  let j = i;\n  if (comparator(\n    load<T>(ptr + (<usize>  j << alignof<T>())),\n    load<T>(ptr + (<usize>++j << alignof<T>()))\n  ) > 0) {\n    while (\n      j < right &&\n      (comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >>> 31) // < 0\n    ) ++j;\n    // reverse\n    let k = j;\n    while (i < k) {\n      let tmp = load<T>(ptr + (<usize>i << alignof<T>()));\n      store<T>(ptr + (<usize>i << alignof<T>()), load<T>(ptr + (<usize>k << alignof<T>()))); ++i;\n      store<T>(ptr + (<usize>k << alignof<T>()), tmp); --k;\n    }\n  } else {\n    while (\n      j < right &&\n      comparator(\n        load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>()),\n        load<T>(ptr + (<usize>j << alignof<T>()))\n      ) >= 0\n    ) ++j;\n  }\n  return j;\n}\n\n// Merges arr[l..m - 1] and arr[m..r]\nfunction mergeRuns<T>(\n  ptr: usize,\n  l: i32,\n  m: i32,\n  r: i32,\n  buffer: usize,\n  comparator: Comparator<T>\n): void {\n  --m;\n  let i: i32, j: i32, t = r + m;\n  for (i = m + 1; i > l; --i) {\n    store<T>(\n      buffer + (<usize>(i - 1) << alignof<T>()),\n      load<T>(ptr + (<usize>(i - 1) << alignof<T>()))\n    );\n  }\n  for (j = m; j < r; ++j) {\n    store<T>(\n      buffer + (<usize>(t - j) << alignof<T>()),\n      load<T>(ptr + (<usize>j << alignof<T>()), 1 << alignof<T>())\n    );\n  }\n  for (let k = l; k <= r; ++k) {\n    let a = load<T>(buffer + (<usize>j << alignof<T>()));\n    let b = load<T>(buffer + (<usize>i << alignof<T>()));\n    if (comparator(a, b) < 0) {\n      store<T>(ptr + (<usize>k << alignof<T>()), a);\n      --j;\n    } else {\n      store<T>(ptr + (<usize>k << alignof<T>()), b);\n      ++i;\n    }\n  }\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_HOLEYARRAY } from \"./util/error\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\n\n@final\nexport class StaticArray<T> {\n  [key: number]: T;\n\n  // Note that the interface of StaticArray instances must be a semantically\n  // compatible subset of Array<T> in order for syntax highlighting to work\n  // properly, for instance when creating static arrays from array literals.\n  // The additionally provided static methods take care of dealing with static\n  // arrays exclusively, without having to convert to Array<T> first.\n\n  static fromArray<T>(source: Array<T>): StaticArray<T> {\n    let length = source.length;\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (isManaged<T>()) {\n      let sourcePtr = source.dataStart;\n      for (let i = 0; i < length; ++i) {\n        let off = <usize>i << alignof<T>();\n        let ref = load<usize>(sourcePtr + off);\n        store<usize>(changetype<usize>(out) + off, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(changetype<usize>(out), source.dataStart, outSize);\n    }\n    return out;\n  }\n\n  /** @deprecated Please use source.concat<StaticArray<T>> instead. */\n  static concat<T>(source: StaticArray<T>, other: StaticArray<T>): StaticArray<T> {\n    return source.concat<StaticArray<T>>(other);\n  }\n\n  /** @deprecated Please use source.slice<StaticArray<T>> instead. */\n  static slice<T>(source: StaticArray<T>, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    return source.slice<StaticArray<T>>(start, end);\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    let outSize = <usize>length << alignof<T>();\n    let out = changetype<StaticArray<T>>(__new(outSize, idof<StaticArray<T>>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(out), 0, outSize);\n    }\n    return out;\n  }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >>> alignof<T>();\n  }\n\n  at(index: i32): T {\n    let len = this.length;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(changetype<usize>(this) + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length) throw new RangeError(E_INDEXOUTOFRANGE);\n    this.__uset(index, value);\n  }\n\n  @unsafe @operator(\"{}=\") private __uset(index: i32, value: T): void {\n    store<T>(changetype<usize>(this) + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(changetype<usize>(this), this.length, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(changetype<usize>(this), this.length, value, start, end);\n    }\n    return this;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): StaticArray<T> {\n    let ptr = changetype<usize>(this);\n    let len = this.length;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let length = this.length;\n      if (length == 0 || fromIndex >= length) return false;\n      if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n      while (fromIndex < length) {\n        let elem = load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let length = this.length;\n    if (length == 0 || fromIndex >= length) return -1;\n    if (fromIndex < 0) fromIndex = max(length + fromIndex, 0);\n    while (fromIndex < length) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length): i32 {\n    let length = this.length;\n    if (length == 0) return -1;\n    if (fromIndex < 0) fromIndex = length + fromIndex;\n    else if (fromIndex >= length) fromIndex = length - 1;\n    while (fromIndex >= 0) {\n      if (load<T>(changetype<usize>(this) + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  concat<U extends ArrayLike<T> = Array<T>>(other: U): U {\n    let sourceLen = this.length;\n    let otherLen = other.length;\n    let outLen = sourceLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) {\n      throw new Error(E_INVALIDLENGTH);\n    }\n    let sourceSize = <usize>sourceLen << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      out = changetype<U>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      let otherStart = changetype<Array<T>>(other).dataStart;\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else if (out instanceof StaticArray<T>) {\n      out = changetype<U>(__new(<usize>outLen << alignof<T>(), idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      let otherStart = changetype<usize>(other);\n      let thisStart = changetype<usize>(this);\n\n      if (isManaged<T>()) {\n        for (let offset: usize = 0; offset < sourceSize; offset += sizeof<T>()) {\n          let ref = load<usize>(thisStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n        outStart += sourceSize;\n        let otherSize = <usize>otherLen << alignof<T>();\n        for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n          let ref = load<usize>(otherStart + offset);\n          store<usize>(outStart + offset, ref);\n          __link(changetype<usize>(out), ref, true);\n        }\n      } else {\n        memory.copy(outStart, thisStart, sourceSize);\n        memory.copy(outStart + sourceSize, otherStart, <usize>otherLen << alignof<T>());\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  slice<U extends ArrayLike<T> = Array<T>>(start: i32 = 0, end: i32 = i32.MAX_VALUE): U {\n    let length = this.length;\n    start = start < 0 ? max(start + length, 0) : min(start, length);\n    end   = end   < 0 ? max(end   + length, 0) : min(end,   length);\n    length = max(end - start, 0);\n\n    let sourceStart = changetype<usize>(this) + (<usize>start << alignof<T>());\n    let size = <usize>length << alignof<T>();\n    let out = changetype<U>(this); // FIXME: instanceof needs *some* value\n\n    if (out instanceof Array<T>) {\n      // return Array\n      out = changetype<U>(__newArray(length, alignof<T>(), idof<Array<T>>()));\n      // ^ FIXME: Function returns type U, but can't __newArray(U extends Array<T>)\n      let outStart = changetype<Array<T>>(out).dataStart;\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(changetype<usize>(out), ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else if (out instanceof StaticArray<T>) {\n      // return StaticArray\n      out = changetype<U>(__new(size, idof<StaticArray<T>>()));\n      let outStart = changetype<usize>(out);\n      if (isManaged<T>()) {\n        let off: usize = 0;\n        while (off < size) {\n          let ref = load<usize>(sourceStart + off);\n          store<usize>(outStart + off, ref);\n          __link(outStart, ref, true);\n          off += sizeof<usize>();\n        }\n      } else {\n        memory.copy(outStart, sourceStart, size);\n      }\n    } else {\n      ERROR(\"Only Array<T> and StaticArray<T> accept for 'U' parameter\");\n    }\n    return out;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: StaticArray<T>) => bool): i32 {\n    for (let i = this.length - 1; i >= 0; --i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  forEach(fn: (value: T, index: i32, array: StaticArray<T>) => void): void {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: StaticArray<T>) => U): Array<U> {\n    let len = this.length;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < len; ++i) {\n      let result = fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: StaticArray<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length; i < len; ++i) {\n      let value = load<T>(changetype<usize>(this) + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length; i < len; ++i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: StaticArray<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  every(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (!fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  some(fn: (value: T, index: i32, array: StaticArray<T>) => bool): bool {\n    for (let i = 0, len = this.length; i < len; ++i) {\n      if (fn(load<T>(changetype<usize>(this) + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): StaticArray<T> {\n    SORT<T>(changetype<usize>(this), this.length, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    if (isBoolean<T>())   return joinBooleanArray(changetype<usize>(this), this.length, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(changetype<usize>(this), this.length, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(changetype<usize>(this), this.length, separator);\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(changetype<usize>(this), this.length, separator);\n    }\n    if (isReference<T>()) return joinReferenceArray<T>(changetype<usize>(this), this.length, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  reverse(): StaticArray<T> {\n    REVERSE<T>(changetype<usize>(this), this.length);\n    return this;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = changetype<usize>(this);\n      let end = cur + changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n  }\n}\n","import { strtol, strtod, strtob } from \"./util/string\";\n\ntype auto = i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isBoolean<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isInteger<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isSigned<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFloat<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVector<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isReference<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isString<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArray<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isArrayLike<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFunction<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNullable<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isDefined(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isConstant(expression: auto): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isManaged<T>(value?: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isVoid<T>(): bool;\n\n// @ts-ignore\n@builtin\nexport declare function lengthof<T>(func?: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function clz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ctz<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function popcnt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotl<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rotr<T>(value: T, shift: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function abs<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function max<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function min<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ceil<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function floor<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function copysign<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function nearest<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function reinterpret<T>(value: number): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sqrt<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function trunc<T>(value: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function add<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sub<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function mul<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function div<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function eq<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function ne<T>(left: T, right: T): i32;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function rem<T>(left: T, right: T): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function load<T>(ptr: usize, immOffset?: usize, immAlign?: usize): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function store<T>(ptr: usize, value: auto, immOffset?: usize, immAlign?: usize): void;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function sizeof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function alignof<T>(): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function offsetof<T>(fieldName?: string): usize; // | u32 / u64\n\n// @ts-ignore: decorator\n@builtin\nexport declare function idof<T>(): u32;\n\n// @ts-ignore\n@builtin\nexport declare function nameof<T>(): string;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function select<T>(ifTrue: T, ifFalse: T, condition: bool): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unreachable(): auto;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function changetype<T>(value: auto): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function assert<T>(isTrueish: T, message?: string): T;\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function unchecked<T>(expr: T): T;\n\nexport namespace inline {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function always<T>(expr: T): T;\n}\n\n// @ts-ignore: decorator\n@unsafe @builtin\nexport declare function call_indirect<T>(index: u32, ...args: auto[]): T;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function instantiate<T>(...args: auto[]): T;\n\nexport namespace atomic {\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load<T>(ptr: usize, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store<T>(ptr: usize, value: T, immOffset?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function xchg<T>(ptr: usize, value: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function cmpxchg<T>(ptr: usize, expected: T, replacement: T, immOffset?: usize): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function wait<T>(ptr: usize, expected: T, timeout: i64): AtomicWaitResult;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function notify(ptr: usize, count: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function fence(): void;\n}\n\n// @ts-ignore: decorator\n@lazy\nexport const enum AtomicWaitResult {\n  OK = 0,\n  NOT_EQUAL = 1,\n  TIMED_OUT = 2\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8(value: auto): i8;\n\nexport namespace i8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i8 = -128;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i8 =  127;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16(value: auto): i16;\n\nexport namespace i16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i16 = -32768;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i16 =  32767;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32(value: auto): i32;\n\nexport namespace i32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i32 = -2147483648;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i32 =  2147483647;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i32 {\n    return strtol<i32>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i32, shift: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i32, right:i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i32, right: i32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u32, right: u32): u32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f32(value: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): i32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i32, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i32;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i32, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i32, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i32, immOffset?: usize): i32;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i32, replacement: i32, immOffset?: usize): i32;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64(value: auto): i64;\n\nexport namespace i64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: i64 = -9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: i64 =  9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function clz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ctz(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_s(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div_u(left: i64, right:i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_s(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32_u(ptr: usize, immOffset?: usize, immAlign?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(value: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotl(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rotr(value: i64, shift: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: i64, right:i64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_s(left: i64, right: i64): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function rem_u(left: u64, right: u64): u64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_f64(value: f64): i64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: i64, immOffset?: usize, immAlign?: usize): void;\n\n  export namespace atomic {\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load8_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load16_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load32_u(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @builtin\n    export declare function load(ptr: usize, immOffset?: usize): i64;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store8(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store16(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store32(ptr: usize, value: i64, immOffset?: usize): void;\n\n    // @ts-ignore: decorator\n    @unsafe @builtin\n    export declare function store(ptr: usize, value: i64, immOffset?: usize): void;\n\n    export namespace rmw8 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw16 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw32 {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg_u(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg_u(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n\n    export namespace rmw {\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function add(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function sub(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function and(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function or(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @builtin\n      export declare function xor(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function xchg(ptr: usize, value: i64, immOffset?: usize): i64;\n\n      // @ts-ignore: decorator\n      @unsafe @builtin\n      export declare function cmpxchg(ptr: usize, expected: i64, replacement: i64, immOffset?: usize): i64;\n    }\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isize(value: auto): isize;\n\nexport namespace isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? -2147483648\n    : <isize>-9223372036854775808;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: isize = sizeof<i32>() == sizeof<isize>()\n    ? 2147483647\n    : <isize>9223372036854775807;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u8(value: auto): u8;\n\nexport namespace u8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u8 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u8 = 255;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u16(value: auto): u16;\n\nexport namespace u16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u16 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u16 = 65535;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u32(value: auto): u32;\n\nexport namespace u32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u32 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u32 = 4294967295;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function u64(value: auto): u64;\n\nexport namespace u64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: u64 = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: u64 = 18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function usize(value: auto): usize;\n\nexport namespace usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: usize = 0;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: usize = sizeof<u32>() == sizeof<usize>()\n    ? 4294967295\n    : <usize>18446744073709551615;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function bool(value: auto): bool;\n\nexport namespace bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE: bool = false;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE: bool = true;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): bool {\n    return strtob(value);\n  }\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32(value: auto): f32;\n\nexport namespace f32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f32>(0x34000000); // 0x1p-23f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f32>(0x00000001); // 0x0.000001p+0f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f32>(0x7F7FFFFF); // 0x1.fffffep+127f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f32>(0x00800000); // 0x1p-126f\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f32 = -16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f32 =  16777215;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f32 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f32 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f32 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f32, y: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i32(value: i32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f32, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f32, right: f32): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f32, right: f32): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f32, right: f32): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64(value: auto): f64;\n\nexport namespace f64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  export const EPSILON = reinterpret<f64>(0x3CB0000000000000); // 0x1p-52\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_VALUE = reinterpret<f64>(0x0000000000000001); // 0x0.0000000000001p+0\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_VALUE = reinterpret<f64>(0x7FEFFFFFFFFFFFFF); // 0x1.fffffffffffffp+1023\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_NORMAL_VALUE = reinterpret<f64>(0x0010000000000000); // 0x1p-1022\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MIN_SAFE_INTEGER: f64 = -9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const MAX_SAFE_INTEGER: f64 =  9007199254740991;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const POSITIVE_INFINITY: f64 =  Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NEGATIVE_INFINITY: f64 = -Infinity;\n\n  // @ts-ignore: decorator\n  @lazy\n  export const NaN: f64 = 0.0 / 0.0;\n\n  // @ts-ignore: decorator\n  @inline\n  export function parse(value: string): f64 {\n    return strtod(value);\n  }\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function copysign(x: f64, y: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function reinterpret_i64(value: i64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: f64, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(value: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(left: f64, right: f64): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(left: f64, right: f64): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(left: f64, right: f64): i32;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function v128(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace v128 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat<T>(x: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane<T>(x: v128, idx: u8): T;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane<T>(x: v128, idx: u8, value: T): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle<T>(a: v128, b: v128, ...lanes: u8[]): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_ext<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_zero<TFrom>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store_lane<TFrom>(ptr: usize, vec: v128, idx: u8, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load8x8_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load16x4_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_s(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function load32x2_u(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load_splat<T>(ptr: usize, immOffset?: usize, immAlign?: usize): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_splat(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_zero(ptr: usize, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function load64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): v128;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store8_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store16_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store32_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store64_lane(ptr: usize, vec: v128, idx: u8, immOffset?: u32, immAlign?: u32): void;\n\n  // @ts-ignore: decorator\n  @unsafe @builtin\n  export declare function store(ptr: usize, value: v128, immOffset?: usize, immAlign?: usize): void;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div<T>(a: v128, b: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr<T>(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function and(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function or(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function xor(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function andnot(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function not(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitselect(v1: v128, v2: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function any_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true<T>(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask<T>(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot<T>(a: v128, b: v128): v128; // i16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr<T>(a: v128, b: v128): v128; // u8, u16 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest<T>(a: v128): v128; // f32, f64 only\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_zero<T = f64>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low<T = f32>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_zero<T>(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd<T>(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect<T>(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot<T>(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_add<T>(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i8x16(\n  a: i8, b: i8, c: i8, d: i8, e: i8, f: i8, g: i8, h: i8,\n  i: i8, j: i8, k: i8, l: i8, m: i8, n: i8, o: i8, p: i8\n): v128;\n\nexport namespace i8x16 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u8;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function popcnt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8,\n    l8: u8, l9: u8, l10: u8, l11: u8, l12: u8, l13: u8, l14: u8, l15: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function swizzle(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_swizzle(a: v128, s: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i16x8(a: i16, b: i16, c: i16, d: i16, e: i16, f: i16, g: i16, h: i16): v128;\n\nexport namespace i16x8 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_s(x: v128, idx: u8): i16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane_u(x: v128, idx: u8): u16;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i16): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function avgr_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub_sat_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function narrow_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i8x16_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function q15mulr_sat_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i8x16_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(\n    a: v128, b: v128,\n    l0: u8, l1: u8, l2: u8, l3: u8, l4: u8, l5: u8, l6: u8, l7: u8\n  ): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_q15mulr_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i32x4(a: i32, b: i32, c: i32, d: i32): v128;\n\nexport namespace i32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function dot_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc_sat_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extadd_pairwise_i16x8_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i16x8_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_s_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_trunc_f64x2_u_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_dot_i8x16_i7x16_add_s(a: v128, b: v128, c: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function i64x2(a: i64, b: i64): v128;\n\nexport namespace i64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): i64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: i64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shl(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_s(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shr_u(a: v128, b: i32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function all_true(a: v128): bool;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function bitmask(a: v128): i32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extend_high_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_low_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_s(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extmul_high_i32x4_u(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_laneselect(a: v128, b: v128, m: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f32x4(a: f32, b: f32, c: f32, d: f32): v128;\n\nexport namespace f32x4 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f32;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f32): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function demote_f64x2_zero(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8, l2: u8, l3: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n// @ts-ignore: decorator\n@builtin\nexport declare function f64x2(a: f64, b: f64): v128;\n\nexport namespace f64x2 {\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function splat(x: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function extract_lane(x: v128, idx: u8): f64;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function replace_lane(x: v128, idx: u8, value: f64): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function add(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sub(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function mul(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function div(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function neg(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function max(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmin(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function pmax(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function abs(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function sqrt(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ceil(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function floor(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function trunc(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function nearest(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function eq(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ne(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function lt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function le(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function gt(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function ge(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_s(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function convert_low_i32x4_u(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function promote_low_f32x4(a: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function shuffle(a: v128, b: v128, l0: u8, l1: u8): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_madd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_nmadd(a: v128, b: v128, c: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_min(a: v128, b: v128): v128;\n\n  // @ts-ignore: decorator\n  @builtin\n  export declare function relaxed_max(a: v128, b: v128): v128;\n}\n\n@final\nexport abstract class i31 { // FIXME: usage of 'new' requires a class :(\n\n  // @ts-ignore: decorator\n  @builtin\n  static new(value: i32): i31ref { return changetype<i31ref>(unreachable()); }\n\n  // @ts-ignore: decorator\n  @builtin\n  static get(i31expr: i31ref): i32 { return unreachable(); }\n}\n\n/* eslint-disable @typescript-eslint/no-unused-vars */\n\n// @ts-ignore: decorator\n@external(\"env\", \"abort\")\n@external.js(\"throw Error(`${message} in ${fileName}:${lineNumber}:${columnNumber}`);\")\ndeclare function abort(\n  message?: string | null,\n  fileName?: string | null,\n  lineNumber?: u32,\n  columnNumber?: u32\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"trace\")\n@external.js(\"console.log(message, ...[a0, a1, a2, a3, a4].slice(0, n));\")\ndeclare function trace(\n  message: string,\n  n?: i32,\n  a0?: f64,\n  a1?: f64,\n  a2?: f64,\n  a3?: f64,\n  a4?: f64\n): void;\n\n// @ts-ignore: decorator\n@external(\"env\", \"seed\")\n@external.js(\"return Date.now() * Math.random();\")\ndeclare function seed(): f64;\n\n/* eslint-enable @typescript-eslint/no-unused-vars */\n","export const MAX_DATASTORE_ENTRY_COUNT = u16.MAX_VALUE;\nexport const BURN_ADDRESS = 'AU1111111111111111111111111111111112m1s9K';\n","/* eslint-disable max-len */\nimport { Storage } from '../std/index';\nimport {\n  wrapStaticArray,\n  bytesToI64,\n  f64ToBytes,\n  i64ToBytes,\n  stringToBytes,\n  unwrapStaticArray,\n  boolToByte,\n  bytesToString,\n  bytesToF64,\n  byteToBool,\n  Result,\n  Serializable,\n} from '@massalabs/as-types';\n\nexport const _KEY_ELEMENT_SUFFIX = '::';\n\n/**\n * This class is one of several convenience collections built on top of the `Storage` class\n * It implements a map -- a persistent unordered map.\n *\n * To create a map\n *\n * ```ts\n * let map = new PersistentMap<string, string>(\"m\")  // choose a unique prefix per account\n * ```\n *\n * To use the map\n *\n * ```ts\n * map.set(key, value)\n * map.get(key)\n * ```\n *\n * IMPORTANT NOTES:\n *\n * (1) The Map doesn't store keys, so if you need to retrieve them, include keys in the values.\n *\n * (2) Since all data stored on the blockchain is kept in a single key-value store under the contract account,\n * you must always use a *unique storage prefix* for different collections to avoid data collision.\n *\n * @typeParam K - The generic type parameter `K` can be any [valid AssemblyScript type](https://docs.assemblyscript.org/basics/types).\n * @typeParam V - The generic type parameter `V` can be any [valid AssemblyScript type](https://docs.assemblyscript.org/basics/types).\n *\n * MISC:\n *\n * Original code from Near (https://github.com/near/near-sdk-as/blob/master/sdk-core/assembly/collections/persistentMap.ts)\n */\nexport class PersistentMap<K, V> {\n  private _elementPrefix: string;\n  private _size: usize;\n\n  /**\n   * Creates or restores a persistent map with a given storage prefix.\n   * Always use a unique storage prefix for different collections.\n   *\n   * Example\n   *\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\") // note the prefix must be unique (per Massa account)\n   * ```\n   * @param prefix - A prefix to use for every key of this map.\n   */\n  constructor(prefix: string) {\n    this._elementPrefix = prefix + _KEY_ELEMENT_SUFFIX;\n    this._size = 0;\n  }\n\n  /**\n   * @param key - Search key.\n   * @returns An internal string key for a given key of type K.\n   */\n  private _key(key: K): StaticArray<u8> {\n    // @ts-ignore: TODO: Add interface that forces all K types to have toString\n    return stringToBytes(this._elementPrefix + key.toString());\n  }\n\n  /**\n   * Checks whether the map contains a given key\n   *\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\")\n   *\n   * map.contains(\"hello\")      // false\n   * map.set(\"hello\", \"world\")\n   * map.contains(\"hello\")      // true\n   * ```\n   *\n   * @param key - Key to check.\n   * @returns True if the given key present in the map.\n   */\n  contains(key: K): bool {\n    return Storage.has(this._key(key));\n  }\n\n  /**\n   * Returns the map size\n   *\n   * @example\n   * ```ts\n   * let map = new PersistentMap<string, string> (\"m\")\n   *\n   * map.size()\n   * ```\n   * @returns the map size\n   */\n  size(): usize {\n    return this._size;\n  }\n\n  /**\n   * Removes the given key and related value from the map\n   *\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\")\n   *\n   * map.set(\"hello\", \"world\")\n   * map.delete(\"hello\")\n   * ```\n   *\n   * Removes value and the key from the map.\n   * @param key - Key to remove.\n   */\n  delete(key: K): void {\n    Storage.del(this._key(key));\n    this._decreaseSize();\n  }\n\n  /**\n   * Increases the internal map size counter\n   * @param key - Key to remove.\n   */\n  _increaseSize(key: K): void {\n    if (!this.contains(key)) {\n      this._size += 1;\n    }\n  }\n\n  /**\n   * Decreases the internal map size counter\n   */\n  _decreaseSize(): void {\n    if (this._size > 0) {\n      this._size -= 1;\n    }\n  }\n\n  /**\n   * Retrieves the related value for a given key, or uses the `defaultValue` if not key is found\n   *\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\")\n   *\n   * map.set(\"hello\", \"world\")\n   * let found = map.get(\"hello\")\n   * let notFound = map.get(\"goodbye\", \"cruel world\")\n   *\n   * assert(found == \"world\")\n   * assert(notFound == \"cruel world\")\n   * ```\n   *\n   * @param key - Key of the element.\n   * @param defaultValue - The default value if the key is not present.\n   * @returns Value for the given key or the default value.\n   */\n  get(key: K, defaultValue: V | null = null): V | null {\n    if (!this.contains(key)) {\n      return defaultValue;\n    }\n    if (isString<V>()) {\n      // @ts-ignore\n      return bytesToString(Storage.get(this._key(key)));\n    } else if (isInteger<V>()) {\n      // @ts-ignore\n      return bytesToI64(Storage.get(this._key(key)));\n    } else if (isFloat<V>()) {\n      // @ts-ignore\n      return bytesToF64(Storage.get(this._key(key)));\n    } else if (isBoolean<V>()) {\n      // @ts-ignore\n      return byteToBool(Storage.get(this._key(key)));\n    } else if (idof<V>() == idof<StaticArray<u8>>()) {\n      return Storage.get(this._key(key));\n    } else if (isArrayLike<V>()) {\n      // @ts-ignore\n      return wrapStaticArray(Storage.get(this._key(key)));\n    } else if (defaultValue instanceof Serializable) {\n      const res = defaultValue.deserialize(Storage.get(this._key(key)));\n      if (res.isOk()) {\n        return defaultValue;\n      } else {\n        return null;\n      }\n    } else {\n      // @ts-ignore\n      return null;\n    }\n  }\n\n  /**\n   * Retrieves a related value for a given key or fails assertion with \"key not found\"\n   *\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\")\n   *\n   * map.set(\"hello\", \"world\")\n   * let result = map.getSome(\"hello\")\n   * // map.getSome(\"goodbye\")  // will throw with failed assertion\n   *\n   * assert(result == \"world\")\n   * ```\n   *\n   * @param key - Key of the element.\n   * @returns Value for the given key or the default value.\n   */\n  getSome(key: K, defaultValue: V | null = null): Result<V> {\n    if (!this.contains(key)) {\n      return new Result(<V>defaultValue, 'key not found');\n    }\n\n    const res = this.get(key, defaultValue);\n    return new Result(<V>res);\n  }\n\n  /**\n   * @example\n   * ```ts\n   * let map = new PersistentMap<string, string>(\"m\")\n   *\n   * map.set(\"hello\", \"world\")\n   * ```\n   *\n   * Sets the new value for the given key.\n   * @param key - Key of the element.\n   * @param value - The new value of the element.\n   */\n  set(key: K, value: V): Result<usize> {\n    // check for map size won't overflow\n    if (this._size >= Usize.MAX_VALUE) {\n      return new Result(this.size(), 'map size overflow');\n    }\n\n    this._increaseSize(key);\n\n    if (isString<V>()) {\n      Storage.set(this._key(key), stringToBytes(value as string));\n    } else if (isInteger<V>()) {\n      Storage.set(this._key(key), i64ToBytes(value as i64));\n    } else if (isFloat<V>()) {\n      Storage.set(this._key(key), f64ToBytes(value as f64));\n    } else if (isBoolean<V>()) {\n      Storage.set(this._key(key), boolToByte(value as boolean));\n    } else if (value instanceof StaticArray<u8>) {\n      Storage.set(this._key(key), value);\n    } else if (isArrayLike<V>()) {\n      Storage.set(this._key(key), unwrapStaticArray(value as Uint8Array));\n    } else if (value instanceof Serializable) {\n      Storage.set(this._key(key), value.serialize());\n    } else {\n      // @ts-ignore\n      Storage.set(this._key(key), value.toString());\n    }\n\n    return new Result(this.size());\n  }\n}\n","import { fromBytes, toBytes } from '@massalabs/as-types';\nimport { Address, Storage } from '../std';\n\n// to move in it's dedicated file\nexport class StoragePrefixManager {\n  private prefix: u8 = 0;\n  newPrefix(): u8 {\n    return this.prefix++;\n  }\n}\n\n// Key used to store the total supply in storage.\nconst totalSupplyKey: u8 = 0x00;\n\n/**\n * Manages liquidity for tokens, with generic flexibility.\n *\n * @remarks\n * It does not implement overflow and underflow checks for operations.\n *\n * @typeParam T - The type used for liquidity amount.\n *\n * @privateRemarks\n * Balance and allowance are stored separately in storage using distinct prefixes.\n * Total supply is stored under a fixed key.\n */\nexport class LiquidityManager<T> {\n  private balancePrefix: u8;\n  private allowancePrefix: u8;\n\n  constructor(storagePrefixManager: StoragePrefixManager) {\n    this.balancePrefix = storagePrefixManager.newPrefix();\n    this.allowancePrefix = storagePrefixManager.newPrefix();\n  }\n\n  @inline\n  private _getOrNull(key: StaticArray<u8>): T {\n    return Storage.has(key) ? <T>fromBytes<T>(Storage.get(key)) : <T>0;\n  }\n\n  @inline\n  private _free(key: StaticArray<u8>): void {\n    if (Storage.has(key)) {\n      assert(\n        fromBytes<T>(Storage.get(key)) == <T>0,\n        `Storage value is not null ${fromBytes<T>(Storage.get(key))}`,\n      );\n      Storage.del(key);\n    }\n  }\n\n  @inline\n  private _getTotalSupplyKey(): StaticArray<u8> {\n    return [this.balancePrefix, totalSupplyKey];\n  }\n\n  /**\n   * Fetches the total supply of the token.\n   *\n   * @remarks\n   * By default, the total supply is 0.\n   *\n   * @returns The total token supply.\n   */\n  public getTotalSupply(): T {\n    return this._getOrNull(this._getTotalSupplyKey());\n  }\n\n  @inline\n  private _getBalanceStorageKey(user: Address): StaticArray<u8> {\n    const key = new StaticArray<u8>(1);\n    key[0] = this.balancePrefix;\n    return key.concat(user.serialize());\n  }\n\n  private _updateAmount(key: StaticArray<u8>, amount: T, increase: bool): void {\n    var newAmount = this._getOrNull(key);\n    if (increase) {\n      // @ts-ignore arithmetic operations on generic types\n      newAmount += amount;\n    } else {\n      // @ts-ignore arithmetic operations on generic types\n      newAmount -= amount;\n    }\n    Storage.set(key, toBytes(newAmount));\n  }\n\n  /**\n   * Retrieves the balance for a specified user address.\n   *\n   * @param user - The user's address.\n   *\n   * @returns User's balance, or 0 if no balance is found.\n   */\n  public getBalance(user: Address): T {\n    return this._getOrNull(this._getBalanceStorageKey(user));\n  }\n\n  /**\n   * Eliminates a user's balance from the storage. No action if the balance doesn't exist.\n   *\n   * @param user - The user's address.\n   *\n   * @throws if the user has a non-zero balance.\n   */\n  public removeBalance(user: Address): void {\n    this._free(this._getBalanceStorageKey(user));\n  }\n\n  /**\n   * Transfers an amount of liquidity from one user to another.\n   *\n   * @remarks\n   * If the receiver has no balance in the storage, a new one is created.\n   *\n   * @param from - Sender's address.\n   * @param to - Receiver's address.\n   * @param amount - Amount of liquidity to transfer.\n   *\n   * @throws if the sender's balance is insufficient.\n   */\n  public transfer(from: Address, to: Address, amount: T): void {\n    const fromKey = this._getBalanceStorageKey(from);\n    const fromBalance = this._getOrNull(fromKey);\n    assert(fromBalance >= amount, 'Not enough balance to transfer');\n    this._updateAmount(fromKey, amount, false);\n\n    const toKey = this._getBalanceStorageKey(to);\n    this._updateAmount(toKey, amount, true);\n  }\n\n  /**\n   * Mints liquidity to a user's balance and updates the total supply.\n   *\n   * @remarks\n   * If the receiver has no balance in the storage, a new one is created.\n   * mint also updates the total supply of the token.\n   *\n   * @param user - The user's address.\n   * @param amount - Amount to mint.\n   */\n  public mint(user: Address, amount: T): void {\n    const userBalance = this._getBalanceStorageKey(user);\n    this._updateAmount(userBalance, amount, true);\n    this._updateAmount(this._getTotalSupplyKey(), amount, true);\n  }\n\n  /**\n   * Burns liquidity from a user's balance and updates the total supply.\n   *\n   * @param user - The user's address.\n   * @param amount - Amount to burn.\n   *\n   * @throws if the user's balance is insufficient.\n   */\n  public burn(user: Address, amount: T): void {\n    const userBalanceKey = this._getBalanceStorageKey(user);\n    assert(\n      this._getOrNull(userBalanceKey) >= amount,\n      'Not enough balance to burn',\n    );\n\n    this._updateAmount(userBalanceKey, amount, false);\n    this._updateAmount(this._getTotalSupplyKey(), amount, false);\n  }\n\n  @inline\n  private _getAllowanceStorageKey(user: Address): StaticArray<u8> {\n    const key = new StaticArray<u8>(1);\n    key[0] = this.allowancePrefix;\n    return key.concat(user.serialize());\n  }\n\n  /**\n   * Fetches the allowed amount a spender can use from an owner's funds.\n   *\n   * @remarks\n   * If the spender has no allowance in the storage, 0 is returned.\n   *\n   * @param owner - Owner's address.\n   * @param spender - Spender's address.\n   * @returns The spender's allowance, or 0 if none is found.\n   */\n  public getAllowance(owner: Address, spender: Address): T {\n    return this._getOrNull(\n      this._getAllowanceStorageKey(owner).concat(spender.serialize()),\n    );\n  }\n\n  /**\n   * Removes the allowance of a spender to use the liquidity of an owner from the storage.\n   *\n   * @remarks\n   * If the spender has no allowance in the storage, the function does nothing.\n   *\n   * @param owner - The address of the owner.\n   * @param spender - The address of the spender.\n   *\n   * @throws if the spender has a non-null allowance.\n   */\n  public removeAllowance(owner: Address, spender: Address): void {\n    this._free(this._getAllowanceStorageKey(owner).concat(spender.serialize()));\n  }\n\n  /**\n   * Updates the allowance set for a spender by an owner.\n   *\n   * @remarks\n   * If the spender has no allowance in the storage, a new allowance is created.\n   *\n   * @param owner - Owner's address.\n   * @param spender - Spender's address.\n   * @param deltaAmount - Amount to adjust the allowance by.\n   * @param increase - Whether to increase (true) or decrease (false) the allowance.\n   *\n   * @throws if attempting to decrease allowance below available amount.\n   */\n  public updateAllowance(\n    owner: Address,\n    spender: Address,\n    deltaAmount: T,\n    increase: bool,\n  ): void {\n    const key = this._getAllowanceStorageKey(owner).concat(spender.serialize());\n    if (!increase) {\n      assert(\n        this._getOrNull(key) >= deltaAmount,\n        'Not enough allowance to decrease',\n      );\n    }\n\n    this._updateAmount(key, deltaAmount, increase);\n  }\n\n  private _useAllowance(owner: Address, spender: Address, amount: T): void {\n    const key = this._getAllowanceStorageKey(owner).concat(spender.serialize());\n    assert(this._getOrNull(key) >= amount, 'Not enough allowance to use');\n    this._updateAmount(key, amount, false);\n  }\n\n  /**\n   * Transfers liquidity using the allowance mechanism.\n   *\n   * @param owner - Owner's address.\n   * @param spender - Spender's address.\n   * @param to - Receiver's address.\n   * @param amount - Amount of liquidity to transfer.\n   *\n   * @throws if the spender's allowance is insufficient.\n   */\n  public transferFrom(\n    owner: Address,\n    spender: Address,\n    to: Address,\n    amount: T,\n  ): void {\n    this._useAllowance(owner, spender, amount);\n\n    this.transfer(owner, to, amount);\n  }\n\n  /**\n   * Burns liquidity from an owner using the allowance mechanism.\n   *\n   * @param owner - Owner's address.\n   * @param spender - Spender's address.\n   * @param amount - Amount of liquidity to burn.\n   *\n   * @throws if the spender's allowance is insufficient.\n   */\n  public burnFrom(owner: Address, spender: Address, amount: T): void {\n    this._useAllowance(owner, spender, amount);\n\n    this.burn(owner, amount);\n  }\n}\n","/**\r\n * Core data types for the Fighter Game Smart Contract\r\n * Defines all serializable structures used across the game\r\n */\r\n\r\nimport {\r\n  Args,\r\n  Serializable,\r\n  Result,\r\n} from '@massalabs/as-types';\r\n\r\n// ============================================================================\r\n// Constants\r\n// ============================================================================\r\n\r\n// Character Classes\r\nexport const CLASS_WARRIOR: u8 = 0;\r\nexport const CLASS_ASSASSIN: u8 = 1;\r\nexport const CLASS_MAGE: u8 = 2;\r\nexport const CLASS_TANK: u8 = 3;\r\nexport const CLASS_TRICKSTER: u8 = 4;\r\n\r\n// Equipment Types\r\nexport const EQUIP_WEAPON: u8 = 0;\r\nexport const EQUIP_ARMOR: u8 = 1;\r\nexport const EQUIP_ACCESSORY: u8 = 2;\r\n\r\n// Equipment Rarity\r\nexport const RARITY_COMMON: u8 = 0;\r\nexport const RARITY_RARE: u8 = 1;\r\nexport const RARITY_EPIC: u8 = 2;\r\nexport const RARITY_LEGENDARY: u8 = 3;\r\n\r\n// Battle States\r\nexport const BATTLE_STATE_PENDING: u8 = 0;\r\nexport const BATTLE_STATE_ACTIVE: u8 = 1;\r\nexport const BATTLE_STATE_WILDCARD: u8 = 2;\r\nexport const BATTLE_STATE_COMPLETED: u8 = 3;\r\n\r\n// Status Effect Bitmasks\r\nexport const STATUS_NONE: u8 = 0;\r\nexport const STATUS_POISON: u8 = 1;      // bit 0\r\nexport const STATUS_STUN: u8 = 2;        // bit 1\r\nexport const STATUS_SHIELD: u8 = 4;      // bit 2\r\nexport const STATUS_RAGE: u8 = 8;        // bit 3\r\nexport const STATUS_BURN: u8 = 16;       // bit 4\r\n\r\n// Skill IDs\r\nexport const SKILL_POWER_STRIKE: u8 = 1;\r\nexport const SKILL_HEAL: u8 = 2;\r\nexport const SKILL_POISON_STRIKE: u8 = 3;\r\nexport const SKILL_STUN_STRIKE: u8 = 4;\r\nexport const SKILL_SHIELD_WALL: u8 = 5;\r\nexport const SKILL_RAGE_MODE: u8 = 6;\r\nexport const SKILL_CRITICAL_EYE: u8 = 7;\r\nexport const SKILL_DODGE_MASTER: u8 = 8;\r\nexport const SKILL_BURN_AURA: u8 = 9;\r\nexport const SKILL_COMBO_BREAKER: u8 = 10;\r\n\r\n// Stances\r\nexport const STANCE_NEUTRAL: u8 = 0;\r\nexport const STANCE_AGGRESSIVE: u8 = 1;\r\nexport const STANCE_DEFENSIVE: u8 = 2;\r\n\r\n// Game Constants\r\nexport const MAX_LEVEL: u8 = 20;\r\nexport const MAX_ENERGY: u8 = 100;\r\nexport const ENERGY_REGEN: u8 = 20;\r\nexport const XP_PER_LEVEL: u64 = 100;\r\nexport const BASE_MMR: u64 = 1000;\r\nexport const WILDCARD_CHANCE: u8 = 10; // 10%\r\nexport const WILDCARD_DEADLINE: u64 = 10000; // 10 seconds in ms\r\n\r\n// Tournament States\r\nexport const TOURNAMENT_REGISTRATION: u8 = 0;\r\nexport const TOURNAMENT_ACTIVE: u8 = 1;\r\nexport const TOURNAMENT_COMPLETED: u8 = 2;\r\n\r\n// Achievement IDs\r\nexport const ACH_FIRST_WIN: u8 = 1;\r\nexport const ACH_10_WINS: u8 = 2;\r\nexport const ACH_50_WINS: u8 = 3;\r\nexport const ACH_100_WINS: u8 = 4;\r\nexport const ACH_TOURNAMENT_WIN: u8 = 5;\r\nexport const ACH_5_WIN_STREAK: u8 = 6;\r\nexport const ACH_COMBO_MASTER: u8 = 7;\r\nexport const ACH_SKILL_MASTER: u8 = 8;\r\nexport const ACH_LEGENDARY_EQUIP: u8 = 9;\r\nexport const ACH_MAX_LEVEL: u8 = 10;\r\n\r\n// Storage Keys Prefixes\r\nexport const KEY_CHARACTER: string = 'char_';\r\nexport const KEY_EQUIPMENT: string = 'equip_';\r\nexport const KEY_BATTLE: string = 'battle_';\r\nexport const KEY_TOURNAMENT: string = 'tourn_';\r\nexport const KEY_LEADERBOARD: string = 'lead_';\r\nexport const KEY_ACHIEVEMENTS: string = 'ach_';\r\nexport const KEY_ADMIN: string = 'admin';\r\nexport const KEY_TREASURY: string = 'treasury';\r\nexport const KEY_PAUSED: string = 'paused';\r\nexport const KEY_REENTRANCY: string = 'reentrancy';\r\n\r\n// ============================================================================\r\n// Character Structure\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class Character implements Serializable {\r\n  id: string = '';\r\n  owner: string = ''; // Address as string\r\n  name: string = '';\r\n  characterClass: u8 = 0;\r\n  level: u8 = 1;\r\n  xp: u64 = 0;\r\n\r\n  // Base Stats\r\n  hp: u16 = 100;\r\n  maxHp: u16 = 100;\r\n  damageMin: u8 = 10;\r\n  damageMax: u8 = 15;\r\n  critChance: u8 = 10;  // percentage\r\n  dodgeChance: u8 = 5;  // percentage\r\n  defense: u8 = 5;\r\n\r\n  // Equipment Slots (equipment IDs, empty string = no equipment)\r\n  weaponId: string = '';\r\n  armorId: string = '';\r\n  accessoryId: string = '';\r\n\r\n  // Skills (equipped skill IDs in slots 1-3, 0 = empty)\r\n  skillSlot1: u8 = 0;\r\n  skillSlot2: u8 = 0;\r\n  skillSlot3: u8 = 0;\r\n  learnedSkills: u16 = 0; // Bitmask of learned skills\r\n\r\n  // Stats\r\n  totalWins: u32 = 0;\r\n  totalLosses: u32 = 0;\r\n  mmr: u64 = BASE_MMR;\r\n  winStreak: u8 = 0;\r\n  createdAt: u64 = 0;\r\n\r\n  constructor(\r\n    id: string = '',\r\n    owner: string = '',\r\n    name: string = '',\r\n    characterClass: u8 = 0\r\n  ) {\r\n    this.id = id;\r\n    this.owner = owner;\r\n    this.name = name;\r\n    this.characterClass = characterClass;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.id);\r\n    args.add(this.owner);\r\n    args.add(this.name);\r\n    args.add(this.characterClass);\r\n    args.add(this.level);\r\n    args.add(this.xp);\r\n    args.add(this.hp);\r\n    args.add(this.maxHp);\r\n    args.add(this.damageMin);\r\n    args.add(this.damageMax);\r\n    args.add(this.critChance);\r\n    args.add(this.dodgeChance);\r\n    args.add(this.defense);\r\n    args.add(this.weaponId);\r\n    args.add(this.armorId);\r\n    args.add(this.accessoryId);\r\n    args.add(this.skillSlot1);\r\n    args.add(this.skillSlot2);\r\n    args.add(this.skillSlot3);\r\n    args.add(this.learnedSkills);\r\n    args.add(this.totalWins);\r\n    args.add(this.totalLosses);\r\n    args.add(this.mmr);\r\n    args.add(this.winStreak);\r\n    args.add(this.createdAt);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const idResult = args.nextString();\r\n    if (idResult.isErr()) return new Result(0, 'Failed to deserialize id');\r\n    this.id = idResult.unwrap();\r\n\r\n    const ownerResult = args.nextString();\r\n    if (ownerResult.isErr()) return new Result(0, 'Failed to deserialize owner');\r\n    this.owner = ownerResult.unwrap();\r\n\r\n    const nameResult = args.nextString();\r\n    if (nameResult.isErr()) return new Result(0, 'Failed to deserialize name');\r\n    this.name = nameResult.unwrap();\r\n\r\n    const classResult = args.nextU8();\r\n    if (classResult.isErr()) return new Result(0, 'Failed to deserialize class');\r\n    this.characterClass = classResult.unwrap();\r\n\r\n    const levelResult = args.nextU8();\r\n    if (levelResult.isErr()) return new Result(0, 'Failed to deserialize level');\r\n    this.level = levelResult.unwrap();\r\n\r\n    const xpResult = args.nextU64();\r\n    if (xpResult.isErr()) return new Result(0, 'Failed to deserialize xp');\r\n    this.xp = xpResult.unwrap();\r\n\r\n    const hpResult = args.nextU16();\r\n    if (hpResult.isErr()) return new Result(0, 'Failed to deserialize hp');\r\n    this.hp = hpResult.unwrap();\r\n\r\n    const maxHpResult = args.nextU16();\r\n    if (maxHpResult.isErr()) return new Result(0, 'Failed to deserialize maxHp');\r\n    this.maxHp = maxHpResult.unwrap();\r\n\r\n    const dmgMinResult = args.nextU8();\r\n    if (dmgMinResult.isErr()) return new Result(0, 'Failed to deserialize damageMin');\r\n    this.damageMin = dmgMinResult.unwrap();\r\n\r\n    const dmgMaxResult = args.nextU8();\r\n    if (dmgMaxResult.isErr()) return new Result(0, 'Failed to deserialize damageMax');\r\n    this.damageMax = dmgMaxResult.unwrap();\r\n\r\n    const critResult = args.nextU8();\r\n    if (critResult.isErr()) return new Result(0, 'Failed to deserialize critChance');\r\n    this.critChance = critResult.unwrap();\r\n\r\n    const dodgeResult = args.nextU8();\r\n    if (dodgeResult.isErr()) return new Result(0, 'Failed to deserialize dodgeChance');\r\n    this.dodgeChance = dodgeResult.unwrap();\r\n\r\n    const defResult = args.nextU8();\r\n    if (defResult.isErr()) return new Result(0, 'Failed to deserialize defense');\r\n    this.defense = defResult.unwrap();\r\n\r\n    const weaponResult = args.nextString();\r\n    if (weaponResult.isErr()) return new Result(0, 'Failed to deserialize weaponId');\r\n    this.weaponId = weaponResult.unwrap();\r\n\r\n    const armorResult = args.nextString();\r\n    if (armorResult.isErr()) return new Result(0, 'Failed to deserialize armorId');\r\n    this.armorId = armorResult.unwrap();\r\n\r\n    const accResult = args.nextString();\r\n    if (accResult.isErr()) return new Result(0, 'Failed to deserialize accessoryId');\r\n    this.accessoryId = accResult.unwrap();\r\n\r\n    const slot1Result = args.nextU8();\r\n    if (slot1Result.isErr()) return new Result(0, 'Failed to deserialize skillSlot1');\r\n    this.skillSlot1 = slot1Result.unwrap();\r\n\r\n    const slot2Result = args.nextU8();\r\n    if (slot2Result.isErr()) return new Result(0, 'Failed to deserialize skillSlot2');\r\n    this.skillSlot2 = slot2Result.unwrap();\r\n\r\n    const slot3Result = args.nextU8();\r\n    if (slot3Result.isErr()) return new Result(0, 'Failed to deserialize skillSlot3');\r\n    this.skillSlot3 = slot3Result.unwrap();\r\n\r\n    const learnedResult = args.nextU16();\r\n    if (learnedResult.isErr()) return new Result(0, 'Failed to deserialize learnedSkills');\r\n    this.learnedSkills = learnedResult.unwrap();\r\n\r\n    const winsResult = args.nextU32();\r\n    if (winsResult.isErr()) return new Result(0, 'Failed to deserialize totalWins');\r\n    this.totalWins = winsResult.unwrap();\r\n\r\n    const lossesResult = args.nextU32();\r\n    if (lossesResult.isErr()) return new Result(0, 'Failed to deserialize totalLosses');\r\n    this.totalLosses = lossesResult.unwrap();\r\n\r\n    const mmrResult = args.nextU64();\r\n    if (mmrResult.isErr()) return new Result(0, 'Failed to deserialize mmr');\r\n    this.mmr = mmrResult.unwrap();\r\n\r\n    const streakResult = args.nextU8();\r\n    if (streakResult.isErr()) return new Result(0, 'Failed to deserialize winStreak');\r\n    this.winStreak = streakResult.unwrap();\r\n\r\n    const createdResult = args.nextU64();\r\n    if (createdResult.isErr()) return new Result(0, 'Failed to deserialize createdAt');\r\n    this.createdAt = createdResult.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Structure\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class Equipment implements Serializable {\r\n  id: string = '';\r\n  owner: string = '';\r\n  equipmentType: u8 = 0;\r\n  rarity: u8 = 0;\r\n\r\n  // Stat Bonuses\r\n  hpBonus: u16 = 0;\r\n  damageMinBonus: u8 = 0;\r\n  damageMaxBonus: u8 = 0;\r\n  critBonus: u8 = 0;\r\n  dodgeBonus: u8 = 0;\r\n\r\n  durability: u16 = 100;\r\n  maxDurability: u16 = 100;\r\n  equippedTo: string = ''; // Character ID if equipped\r\n  createdAt: u64 = 0;\r\n\r\n  constructor(\r\n    id: string = '',\r\n    owner: string = '',\r\n    equipmentType: u8 = 0,\r\n    rarity: u8 = 0\r\n  ) {\r\n    this.id = id;\r\n    this.owner = owner;\r\n    this.equipmentType = equipmentType;\r\n    this.rarity = rarity;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.id);\r\n    args.add(this.owner);\r\n    args.add(this.equipmentType);\r\n    args.add(this.rarity);\r\n    args.add(this.hpBonus);\r\n    args.add(this.damageMinBonus);\r\n    args.add(this.damageMaxBonus);\r\n    args.add(this.critBonus);\r\n    args.add(this.dodgeBonus);\r\n    args.add(this.durability);\r\n    args.add(this.maxDurability);\r\n    args.add(this.equippedTo);\r\n    args.add(this.createdAt);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const idRes = args.nextString();\r\n    if (idRes.isErr()) return new Result(0, 'Failed to deserialize id');\r\n    this.id = idRes.unwrap();\r\n\r\n    const ownerRes = args.nextString();\r\n    if (ownerRes.isErr()) return new Result(0, 'Failed to deserialize owner');\r\n    this.owner = ownerRes.unwrap();\r\n\r\n    const typeRes = args.nextU8();\r\n    if (typeRes.isErr()) return new Result(0, 'Failed to deserialize type');\r\n    this.equipmentType = typeRes.unwrap();\r\n\r\n    const rarityRes = args.nextU8();\r\n    if (rarityRes.isErr()) return new Result(0, 'Failed to deserialize rarity');\r\n    this.rarity = rarityRes.unwrap();\r\n\r\n    const hpRes = args.nextU16();\r\n    if (hpRes.isErr()) return new Result(0, 'Failed to deserialize hpBonus');\r\n    this.hpBonus = hpRes.unwrap();\r\n\r\n    const dmgMinRes = args.nextU8();\r\n    if (dmgMinRes.isErr()) return new Result(0, 'Failed to deserialize damageMinBonus');\r\n    this.damageMinBonus = dmgMinRes.unwrap();\r\n\r\n    const dmgMaxRes = args.nextU8();\r\n    if (dmgMaxRes.isErr()) return new Result(0, 'Failed to deserialize damageMaxBonus');\r\n    this.damageMaxBonus = dmgMaxRes.unwrap();\r\n\r\n    const critRes = args.nextU8();\r\n    if (critRes.isErr()) return new Result(0, 'Failed to deserialize critBonus');\r\n    this.critBonus = critRes.unwrap();\r\n\r\n    const dodgeRes = args.nextU8();\r\n    if (dodgeRes.isErr()) return new Result(0, 'Failed to deserialize dodgeBonus');\r\n    this.dodgeBonus = dodgeRes.unwrap();\r\n\r\n    const durRes = args.nextU16();\r\n    if (durRes.isErr()) return new Result(0, 'Failed to deserialize durability');\r\n    this.durability = durRes.unwrap();\r\n\r\n    const maxDurRes = args.nextU16();\r\n    if (maxDurRes.isErr()) return new Result(0, 'Failed to deserialize maxDurability');\r\n    this.maxDurability = maxDurRes.unwrap();\r\n\r\n    const equippedRes = args.nextString();\r\n    if (equippedRes.isErr()) return new Result(0, 'Failed to deserialize equippedTo');\r\n    this.equippedTo = equippedRes.unwrap();\r\n\r\n    const createdRes = args.nextU64();\r\n    if (createdRes.isErr()) return new Result(0, 'Failed to deserialize createdAt');\r\n    this.createdAt = createdRes.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Battle Player State\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class BattlePlayer implements Serializable {\r\n  characterId: string = '';\r\n  currentHp: u16 = 0;\r\n  maxHp: u16 = 0;\r\n  energy: u8 = MAX_ENERGY;\r\n  statusEffects: u8 = STATUS_NONE;\r\n  poisonTurns: u8 = 0;\r\n  stunTurns: u8 = 0;\r\n  shieldTurns: u8 = 0;\r\n  rageTurns: u8 = 0;\r\n  burnTurns: u8 = 0;\r\n  comboCount: u8 = 0;\r\n  guaranteedCrit: bool = false;\r\n  dodgeBoost: u8 = 0;\r\n  dodgeBoostTurns: u8 = 0;\r\n\r\n  // Cooldowns (per skill, stored as turns remaining)\r\n  cooldown1: u8 = 0;\r\n  cooldown2: u8 = 0;\r\n  cooldown3: u8 = 0;\r\n  cooldown4: u8 = 0;\r\n  cooldown5: u8 = 0;\r\n  cooldown6: u8 = 0;\r\n  cooldown7: u8 = 0;\r\n  cooldown8: u8 = 0;\r\n  cooldown9: u8 = 0;\r\n  cooldown10: u8 = 0;\r\n\r\n  constructor(characterId: string = '', hp: u16 = 0, maxHp: u16 = 0) {\r\n    this.characterId = characterId;\r\n    this.currentHp = hp;\r\n    this.maxHp = maxHp;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.characterId);\r\n    args.add(this.currentHp);\r\n    args.add(this.maxHp);\r\n    args.add(this.energy);\r\n    args.add(this.statusEffects);\r\n    args.add(this.poisonTurns);\r\n    args.add(this.stunTurns);\r\n    args.add(this.shieldTurns);\r\n    args.add(this.rageTurns);\r\n    args.add(this.burnTurns);\r\n    args.add(this.comboCount);\r\n    args.add(this.guaranteedCrit);\r\n    args.add(this.dodgeBoost);\r\n    args.add(this.dodgeBoostTurns);\r\n    args.add(this.cooldown1);\r\n    args.add(this.cooldown2);\r\n    args.add(this.cooldown3);\r\n    args.add(this.cooldown4);\r\n    args.add(this.cooldown5);\r\n    args.add(this.cooldown6);\r\n    args.add(this.cooldown7);\r\n    args.add(this.cooldown8);\r\n    args.add(this.cooldown9);\r\n    args.add(this.cooldown10);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const charRes = args.nextString();\r\n    if (charRes.isErr()) return new Result(0, 'Failed');\r\n    this.characterId = charRes.unwrap();\r\n\r\n    const hpRes = args.nextU16();\r\n    if (hpRes.isErr()) return new Result(0, 'Failed');\r\n    this.currentHp = hpRes.unwrap();\r\n\r\n    const maxHpRes = args.nextU16();\r\n    if (maxHpRes.isErr()) return new Result(0, 'Failed');\r\n    this.maxHp = maxHpRes.unwrap();\r\n\r\n    const energyRes = args.nextU8();\r\n    if (energyRes.isErr()) return new Result(0, 'Failed');\r\n    this.energy = energyRes.unwrap();\r\n\r\n    const statusRes = args.nextU8();\r\n    if (statusRes.isErr()) return new Result(0, 'Failed');\r\n    this.statusEffects = statusRes.unwrap();\r\n\r\n    const poisonRes = args.nextU8();\r\n    if (poisonRes.isErr()) return new Result(0, 'Failed');\r\n    this.poisonTurns = poisonRes.unwrap();\r\n\r\n    const stunRes = args.nextU8();\r\n    if (stunRes.isErr()) return new Result(0, 'Failed');\r\n    this.stunTurns = stunRes.unwrap();\r\n\r\n    const shieldRes = args.nextU8();\r\n    if (shieldRes.isErr()) return new Result(0, 'Failed');\r\n    this.shieldTurns = shieldRes.unwrap();\r\n\r\n    const rageRes = args.nextU8();\r\n    if (rageRes.isErr()) return new Result(0, 'Failed');\r\n    this.rageTurns = rageRes.unwrap();\r\n\r\n    const burnRes = args.nextU8();\r\n    if (burnRes.isErr()) return new Result(0, 'Failed');\r\n    this.burnTurns = burnRes.unwrap();\r\n\r\n    const comboRes = args.nextU8();\r\n    if (comboRes.isErr()) return new Result(0, 'Failed');\r\n    this.comboCount = comboRes.unwrap();\r\n\r\n    const critRes = args.nextBool();\r\n    if (critRes.isErr()) return new Result(0, 'Failed');\r\n    this.guaranteedCrit = critRes.unwrap();\r\n\r\n    const dodgeBoostRes = args.nextU8();\r\n    if (dodgeBoostRes.isErr()) return new Result(0, 'Failed');\r\n    this.dodgeBoost = dodgeBoostRes.unwrap();\r\n\r\n    const dodgeTurnsRes = args.nextU8();\r\n    if (dodgeTurnsRes.isErr()) return new Result(0, 'Failed');\r\n    this.dodgeBoostTurns = dodgeTurnsRes.unwrap();\r\n\r\n    const cd1 = args.nextU8();\r\n    if (cd1.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown1 = cd1.unwrap();\r\n\r\n    const cd2 = args.nextU8();\r\n    if (cd2.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown2 = cd2.unwrap();\r\n\r\n    const cd3 = args.nextU8();\r\n    if (cd3.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown3 = cd3.unwrap();\r\n\r\n    const cd4 = args.nextU8();\r\n    if (cd4.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown4 = cd4.unwrap();\r\n\r\n    const cd5 = args.nextU8();\r\n    if (cd5.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown5 = cd5.unwrap();\r\n\r\n    const cd6 = args.nextU8();\r\n    if (cd6.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown6 = cd6.unwrap();\r\n\r\n    const cd7 = args.nextU8();\r\n    if (cd7.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown7 = cd7.unwrap();\r\n\r\n    const cd8 = args.nextU8();\r\n    if (cd8.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown8 = cd8.unwrap();\r\n\r\n    const cd9 = args.nextU8();\r\n    if (cd9.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown9 = cd9.unwrap();\r\n\r\n    const cd10 = args.nextU8();\r\n    if (cd10.isErr()) return new Result(0, 'Failed');\r\n    this.cooldown10 = cd10.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Battle Structure\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class Battle implements Serializable {\r\n  id: string = '';\r\n  player1: BattlePlayer = new BattlePlayer();\r\n  player2: BattlePlayer = new BattlePlayer();\r\n  currentTurn: u8 = 1; // 1 or 2\r\n  turnNumber: u32 = 0;\r\n  state: u8 = BATTLE_STATE_PENDING;\r\n  winnerId: string = '';\r\n  startTimestamp: u64 = 0;\r\n  lastActionTimestamp: u64 = 0;\r\n\r\n  // Wildcard state\r\n  wildcardActive: bool = false;\r\n  wildcardType: u8 = 0;\r\n  wildcardDeadline: u64 = 0;\r\n  player1WildcardDecision: u8 = 255; // 255 = no decision, 0 = reject, 1 = accept\r\n  player2WildcardDecision: u8 = 255;\r\n\r\n  // Random seed\r\n  randomSeed: u64 = 0;\r\n\r\n  constructor(id: string = '') {\r\n    this.id = id;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.id);\r\n    args.add(this.player1);\r\n    args.add(this.player2);\r\n    args.add(this.currentTurn);\r\n    args.add(this.turnNumber);\r\n    args.add(this.state);\r\n    args.add(this.winnerId);\r\n    args.add(this.startTimestamp);\r\n    args.add(this.lastActionTimestamp);\r\n    args.add(this.wildcardActive);\r\n    args.add(this.wildcardType);\r\n    args.add(this.wildcardDeadline);\r\n    args.add(this.player1WildcardDecision);\r\n    args.add(this.player2WildcardDecision);\r\n    args.add(this.randomSeed);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const idRes = args.nextString();\r\n    if (idRes.isErr()) return new Result(0, 'Failed');\r\n    this.id = idRes.unwrap();\r\n\r\n    const p1Res = args.nextSerializable<BattlePlayer>();\r\n    if (p1Res.isErr()) return new Result(0, 'Failed');\r\n    this.player1 = p1Res.unwrap();\r\n\r\n    const p2Res = args.nextSerializable<BattlePlayer>();\r\n    if (p2Res.isErr()) return new Result(0, 'Failed');\r\n    this.player2 = p2Res.unwrap();\r\n\r\n    const turnRes = args.nextU8();\r\n    if (turnRes.isErr()) return new Result(0, 'Failed');\r\n    this.currentTurn = turnRes.unwrap();\r\n\r\n    const turnNumRes = args.nextU32();\r\n    if (turnNumRes.isErr()) return new Result(0, 'Failed');\r\n    this.turnNumber = turnNumRes.unwrap();\r\n\r\n    const stateRes = args.nextU8();\r\n    if (stateRes.isErr()) return new Result(0, 'Failed');\r\n    this.state = stateRes.unwrap();\r\n\r\n    const winnerRes = args.nextString();\r\n    if (winnerRes.isErr()) return new Result(0, 'Failed');\r\n    this.winnerId = winnerRes.unwrap();\r\n\r\n    const startRes = args.nextU64();\r\n    if (startRes.isErr()) return new Result(0, 'Failed');\r\n    this.startTimestamp = startRes.unwrap();\r\n\r\n    const lastRes = args.nextU64();\r\n    if (lastRes.isErr()) return new Result(0, 'Failed');\r\n    this.lastActionTimestamp = lastRes.unwrap();\r\n\r\n    const wcActiveRes = args.nextBool();\r\n    if (wcActiveRes.isErr()) return new Result(0, 'Failed');\r\n    this.wildcardActive = wcActiveRes.unwrap();\r\n\r\n    const wcTypeRes = args.nextU8();\r\n    if (wcTypeRes.isErr()) return new Result(0, 'Failed');\r\n    this.wildcardType = wcTypeRes.unwrap();\r\n\r\n    const wcDeadRes = args.nextU64();\r\n    if (wcDeadRes.isErr()) return new Result(0, 'Failed');\r\n    this.wildcardDeadline = wcDeadRes.unwrap();\r\n\r\n    const p1DecRes = args.nextU8();\r\n    if (p1DecRes.isErr()) return new Result(0, 'Failed');\r\n    this.player1WildcardDecision = p1DecRes.unwrap();\r\n\r\n    const p2DecRes = args.nextU8();\r\n    if (p2DecRes.isErr()) return new Result(0, 'Failed');\r\n    this.player2WildcardDecision = p2DecRes.unwrap();\r\n\r\n    const seedRes = args.nextU64();\r\n    if (seedRes.isErr()) return new Result(0, 'Failed');\r\n    this.randomSeed = seedRes.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Tournament Structure\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class Tournament implements Serializable {\r\n  id: string = '';\r\n  name: string = '';\r\n  entryFee: u64 = 0;\r\n  prizePool: u64 = 0;\r\n  maxParticipants: u8 = 8;\r\n  currentRound: u8 = 0;\r\n  state: u8 = TOURNAMENT_REGISTRATION;\r\n\r\n  // Participants stored as comma-separated character IDs\r\n  participants: string = '';\r\n  // Bracket stored as comma-separated pairs for each round\r\n  bracket: string = '';\r\n\r\n  winnerId: string = '';\r\n  runnerUpId: string = '';\r\n  thirdPlaceId: string = '';\r\n\r\n  createdAt: u64 = 0;\r\n  startedAt: u64 = 0;\r\n  endedAt: u64 = 0;\r\n\r\n  constructor(id: string = '') {\r\n    this.id = id;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.id);\r\n    args.add(this.name);\r\n    args.add(this.entryFee);\r\n    args.add(this.prizePool);\r\n    args.add(this.maxParticipants);\r\n    args.add(this.currentRound);\r\n    args.add(this.state);\r\n    args.add(this.participants);\r\n    args.add(this.bracket);\r\n    args.add(this.winnerId);\r\n    args.add(this.runnerUpId);\r\n    args.add(this.thirdPlaceId);\r\n    args.add(this.createdAt);\r\n    args.add(this.startedAt);\r\n    args.add(this.endedAt);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const idRes = args.nextString();\r\n    if (idRes.isErr()) return new Result(0, 'Failed');\r\n    this.id = idRes.unwrap();\r\n\r\n    const nameRes = args.nextString();\r\n    if (nameRes.isErr()) return new Result(0, 'Failed');\r\n    this.name = nameRes.unwrap();\r\n\r\n    const feeRes = args.nextU64();\r\n    if (feeRes.isErr()) return new Result(0, 'Failed');\r\n    this.entryFee = feeRes.unwrap();\r\n\r\n    const prizeRes = args.nextU64();\r\n    if (prizeRes.isErr()) return new Result(0, 'Failed');\r\n    this.prizePool = prizeRes.unwrap();\r\n\r\n    const maxRes = args.nextU8();\r\n    if (maxRes.isErr()) return new Result(0, 'Failed');\r\n    this.maxParticipants = maxRes.unwrap();\r\n\r\n    const roundRes = args.nextU8();\r\n    if (roundRes.isErr()) return new Result(0, 'Failed');\r\n    this.currentRound = roundRes.unwrap();\r\n\r\n    const stateRes = args.nextU8();\r\n    if (stateRes.isErr()) return new Result(0, 'Failed');\r\n    this.state = stateRes.unwrap();\r\n\r\n    const partRes = args.nextString();\r\n    if (partRes.isErr()) return new Result(0, 'Failed');\r\n    this.participants = partRes.unwrap();\r\n\r\n    const bracketRes = args.nextString();\r\n    if (bracketRes.isErr()) return new Result(0, 'Failed');\r\n    this.bracket = bracketRes.unwrap();\r\n\r\n    const winRes = args.nextString();\r\n    if (winRes.isErr()) return new Result(0, 'Failed');\r\n    this.winnerId = winRes.unwrap();\r\n\r\n    const runnerRes = args.nextString();\r\n    if (runnerRes.isErr()) return new Result(0, 'Failed');\r\n    this.runnerUpId = runnerRes.unwrap();\r\n\r\n    const thirdRes = args.nextString();\r\n    if (thirdRes.isErr()) return new Result(0, 'Failed');\r\n    this.thirdPlaceId = thirdRes.unwrap();\r\n\r\n    const createdRes = args.nextU64();\r\n    if (createdRes.isErr()) return new Result(0, 'Failed');\r\n    this.createdAt = createdRes.unwrap();\r\n\r\n    const startedRes = args.nextU64();\r\n    if (startedRes.isErr()) return new Result(0, 'Failed');\r\n    this.startedAt = startedRes.unwrap();\r\n\r\n    const endedRes = args.nextU64();\r\n    if (endedRes.isErr()) return new Result(0, 'Failed');\r\n    this.endedAt = endedRes.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Leaderboard Entry\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class LeaderboardEntry implements Serializable {\r\n  characterId: string = '';\r\n  ownerAddress: string = '';\r\n  mmr: u64 = 0;\r\n  wins: u32 = 0;\r\n  losses: u32 = 0;\r\n\r\n  constructor(characterId: string = '', ownerAddress: string = '', mmr: u64 = 0) {\r\n    this.characterId = characterId;\r\n    this.ownerAddress = ownerAddress;\r\n    this.mmr = mmr;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.characterId);\r\n    args.add(this.ownerAddress);\r\n    args.add(this.mmr);\r\n    args.add(this.wins);\r\n    args.add(this.losses);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const charRes = args.nextString();\r\n    if (charRes.isErr()) return new Result(0, 'Failed');\r\n    this.characterId = charRes.unwrap();\r\n\r\n    const ownerRes = args.nextString();\r\n    if (ownerRes.isErr()) return new Result(0, 'Failed');\r\n    this.ownerAddress = ownerRes.unwrap();\r\n\r\n    const mmrRes = args.nextU64();\r\n    if (mmrRes.isErr()) return new Result(0, 'Failed');\r\n    this.mmr = mmrRes.unwrap();\r\n\r\n    const winsRes = args.nextU32();\r\n    if (winsRes.isErr()) return new Result(0, 'Failed');\r\n    this.wins = winsRes.unwrap();\r\n\r\n    const lossesRes = args.nextU32();\r\n    if (lossesRes.isErr()) return new Result(0, 'Failed');\r\n    this.losses = lossesRes.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Tracker\r\n// ============================================================================\r\n\r\n@serializable\r\nexport class AchievementTracker implements Serializable {\r\n  ownerAddress: string = '';\r\n  unlockedAchievements: u16 = 0; // Bitmask\r\n  timestamps: string = ''; // Comma-separated timestamps for each achievement\r\n\r\n  constructor(ownerAddress: string = '') {\r\n    this.ownerAddress = ownerAddress;\r\n  }\r\n\r\n  serialize(): StaticArray<u8> {\r\n    const args = new Args();\r\n    args.add(this.ownerAddress);\r\n    args.add(this.unlockedAchievements);\r\n    args.add(this.timestamps);\r\n    return args.serialize();\r\n  }\r\n\r\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\r\n    const args = new Args(data, offset);\r\n\r\n    const ownerRes = args.nextString();\r\n    if (ownerRes.isErr()) return new Result(0, 'Failed');\r\n    this.ownerAddress = ownerRes.unwrap();\r\n\r\n    const achRes = args.nextU16();\r\n    if (achRes.isErr()) return new Result(0, 'Failed');\r\n    this.unlockedAchievements = achRes.unwrap();\r\n\r\n    const tsRes = args.nextString();\r\n    if (tsRes.isErr()) return new Result(0, 'Failed');\r\n    this.timestamps = tsRes.unwrap();\r\n\r\n    return new Result(args.offset);\r\n  }\r\n}\r\n","/**\r\n * Storage helper functions for the Fighter Game Smart Contract\r\n * Handles all persistent state operations using Massa SDK v3 API\r\n */\r\n\r\nimport { Storage } from '@massalabs/massa-as-sdk';\r\nimport { Args, stringToBytes, bytesToString } from '@massalabs/as-types';\r\nimport {\r\n  Character,\r\n  Equipment,\r\n  Battle,\r\n  Tournament,\r\n  LeaderboardEntry,\r\n  AchievementTracker,\r\n  KEY_CHARACTER,\r\n  KEY_EQUIPMENT,\r\n  KEY_BATTLE,\r\n  KEY_TOURNAMENT,\r\n  KEY_LEADERBOARD,\r\n  KEY_ACHIEVEMENTS,\r\n  KEY_ADMIN,\r\n  KEY_TREASURY,\r\n  KEY_PAUSED,\r\n  KEY_REENTRANCY,\r\n} from './types';\r\n\r\n// ============================================================================\r\n// Helper Functions for Key Conversion\r\n// ============================================================================\r\n\r\nfunction toKey(key: string): StaticArray<u8> {\r\n  return stringToBytes(key);\r\n}\r\n\r\nfunction hasKey(key: string): bool {\r\n  return Storage.has(toKey(key));\r\n}\r\n\r\nfunction setString(key: string, value: string): void {\r\n  Storage.set(toKey(key), stringToBytes(value));\r\n}\r\n\r\nfunction getString(key: string): string {\r\n  if (!hasKey(key)) return '';\r\n  return bytesToString(Storage.get(toKey(key)));\r\n}\r\n\r\nfunction setBytes(key: string, value: StaticArray<u8>): void {\r\n  Storage.set(toKey(key), value);\r\n}\r\n\r\nfunction getBytes(key: string): StaticArray<u8> {\r\n  if (!hasKey(key)) return new StaticArray<u8>(0);\r\n  return Storage.get(toKey(key));\r\n}\r\n\r\nfunction delKey(key: string): void {\r\n  if (hasKey(key)) {\r\n    Storage.del(toKey(key));\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Admin & Security Storage\r\n// ============================================================================\r\n\r\nexport function setAdmin(address: string): void {\r\n  setString(KEY_ADMIN, address);\r\n}\r\n\r\nexport function getAdmin(): string {\r\n  return getString(KEY_ADMIN);\r\n}\r\n\r\nexport function isAdmin(address: string): bool {\r\n  return getAdmin() == address;\r\n}\r\n\r\nexport function setPaused(paused: bool): void {\r\n  setString(KEY_PAUSED, paused ? '1' : '0');\r\n}\r\n\r\nexport function isPaused(): bool {\r\n  return getString(KEY_PAUSED) == '1';\r\n}\r\n\r\nexport function setReentrancyLock(locked: bool): void {\r\n  setString(KEY_REENTRANCY, locked ? '1' : '0');\r\n}\r\n\r\nexport function isReentrancyLocked(): bool {\r\n  return getString(KEY_REENTRANCY) == '1';\r\n}\r\n\r\n// ============================================================================\r\n// Treasury Storage\r\n// ============================================================================\r\n\r\nexport function getTreasury(): u64 {\r\n  const data = getBytes(KEY_TREASURY);\r\n  if (data.length == 0) return 0;\r\n  const args = new Args(data);\r\n  const result = args.nextU64();\r\n  if (result.isErr()) return 0;\r\n  return result.unwrap();\r\n}\r\n\r\nexport function setTreasury(amount: u64): void {\r\n  const args = new Args();\r\n  args.add(amount);\r\n  setBytes(KEY_TREASURY, args.serialize());\r\n}\r\n\r\nexport function addToTreasury(amount: u64): void {\r\n  setTreasury(getTreasury() + amount);\r\n}\r\n\r\n// ============================================================================\r\n// Character Storage\r\n// ============================================================================\r\n\r\nexport function characterKey(id: string): string {\r\n  return KEY_CHARACTER + id;\r\n}\r\n\r\nexport function saveCharacter(character: Character): void {\r\n  setBytes(characterKey(character.id), character.serialize());\r\n}\r\n\r\nexport function loadCharacter(id: string): Character | null {\r\n  const key = characterKey(id);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const character = new Character();\r\n  const result = character.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return character;\r\n}\r\n\r\nexport function characterExists(id: string): bool {\r\n  return hasKey(characterKey(id));\r\n}\r\n\r\nexport function deleteCharacter(id: string): void {\r\n  delKey(characterKey(id));\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Storage\r\n// ============================================================================\r\n\r\nexport function equipmentKey(id: string): string {\r\n  return KEY_EQUIPMENT + id;\r\n}\r\n\r\nexport function saveEquipment(equipment: Equipment): void {\r\n  setBytes(equipmentKey(equipment.id), equipment.serialize());\r\n}\r\n\r\nexport function loadEquipment(id: string): Equipment | null {\r\n  const key = equipmentKey(id);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const equipment = new Equipment();\r\n  const result = equipment.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return equipment;\r\n}\r\n\r\nexport function equipmentExists(id: string): bool {\r\n  return hasKey(equipmentKey(id));\r\n}\r\n\r\nexport function deleteEquipment(id: string): void {\r\n  delKey(equipmentKey(id));\r\n}\r\n\r\n// ============================================================================\r\n// Battle Storage\r\n// ============================================================================\r\n\r\nexport function battleKey(id: string): string {\r\n  return KEY_BATTLE + id;\r\n}\r\n\r\nexport function saveBattle(battle: Battle): void {\r\n  setBytes(battleKey(battle.id), battle.serialize());\r\n}\r\n\r\nexport function loadBattle(id: string): Battle | null {\r\n  const key = battleKey(id);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const battle = new Battle();\r\n  const result = battle.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return battle;\r\n}\r\n\r\nexport function battleExists(id: string): bool {\r\n  return hasKey(battleKey(id));\r\n}\r\n\r\nexport function deleteBattle(id: string): void {\r\n  delKey(battleKey(id));\r\n}\r\n\r\n// ============================================================================\r\n// Tournament Storage\r\n// ============================================================================\r\n\r\nexport function tournamentKey(id: string): string {\r\n  return KEY_TOURNAMENT + id;\r\n}\r\n\r\nexport function saveTournament(tournament: Tournament): void {\r\n  setBytes(tournamentKey(tournament.id), tournament.serialize());\r\n}\r\n\r\nexport function loadTournament(id: string): Tournament | null {\r\n  const key = tournamentKey(id);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const tournament = new Tournament();\r\n  const result = tournament.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return tournament;\r\n}\r\n\r\nexport function tournamentExists(id: string): bool {\r\n  return hasKey(tournamentKey(id));\r\n}\r\n\r\n// ============================================================================\r\n// Leaderboard Storage\r\n// ============================================================================\r\n\r\nexport function leaderboardKey(rank: u32): string {\r\n  return KEY_LEADERBOARD + rank.toString();\r\n}\r\n\r\nexport function leaderboardCountKey(): string {\r\n  return KEY_LEADERBOARD + 'count';\r\n}\r\n\r\nexport function saveLeaderboardEntry(rank: u32, entry: LeaderboardEntry): void {\r\n  setBytes(leaderboardKey(rank), entry.serialize());\r\n}\r\n\r\nexport function loadLeaderboardEntry(rank: u32): LeaderboardEntry | null {\r\n  const key = leaderboardKey(rank);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const entry = new LeaderboardEntry();\r\n  const result = entry.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return entry;\r\n}\r\n\r\nexport function getLeaderboardCount(): u32 {\r\n  const data = getBytes(leaderboardCountKey());\r\n  if (data.length == 0) return 0;\r\n  const args = new Args(data);\r\n  const result = args.nextU32();\r\n  if (result.isErr()) return 0;\r\n  return result.unwrap();\r\n}\r\n\r\nexport function setLeaderboardCount(count: u32): void {\r\n  const args = new Args();\r\n  args.add(count);\r\n  setBytes(leaderboardCountKey(), args.serialize());\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Storage\r\n// ============================================================================\r\n\r\nexport function achievementKey(address: string): string {\r\n  return KEY_ACHIEVEMENTS + address;\r\n}\r\n\r\nexport function saveAchievements(tracker: AchievementTracker): void {\r\n  setBytes(achievementKey(tracker.ownerAddress), tracker.serialize());\r\n}\r\n\r\nexport function loadAchievements(address: string): AchievementTracker | null {\r\n  const key = achievementKey(address);\r\n  if (!hasKey(key)) return null;\r\n  const data = getBytes(key);\r\n  if (data.length == 0) return null;\r\n  const tracker = new AchievementTracker();\r\n  const result = tracker.deserialize(data);\r\n  if (result.isErr()) return null;\r\n  return tracker;\r\n}\r\n\r\nexport function getOrCreateAchievements(address: string): AchievementTracker {\r\n  let tracker = loadAchievements(address);\r\n  if (tracker == null) {\r\n    tracker = new AchievementTracker(address);\r\n  }\r\n  return tracker;\r\n}\r\n\r\n// ============================================================================\r\n// Helper: Character Owner Index (for lookups by owner)\r\n// ============================================================================\r\n\r\nconst KEY_OWNER_CHARS: string = 'owner_chars_';\r\n\r\nexport function ownerCharsKey(owner: string): string {\r\n  return KEY_OWNER_CHARS + owner;\r\n}\r\n\r\nexport function addCharacterToOwner(owner: string, charId: string): void {\r\n  const key = ownerCharsKey(owner);\r\n  let chars = getString(key);\r\n  if (chars.length > 0) {\r\n    chars += ',';\r\n  }\r\n  chars += charId;\r\n  setString(key, chars);\r\n}\r\n\r\nexport function getOwnerCharacters(owner: string): string[] {\r\n  const chars = getString(ownerCharsKey(owner));\r\n  if (chars.length == 0) return [];\r\n  return chars.split(',');\r\n}\r\n\r\n// ============================================================================\r\n// Helper: Equipment Owner Index\r\n// ============================================================================\r\n\r\nconst KEY_OWNER_EQUIPS: string = 'owner_equips_';\r\n\r\nexport function ownerEquipsKey(owner: string): string {\r\n  return KEY_OWNER_EQUIPS + owner;\r\n}\r\n\r\nexport function addEquipmentToOwner(owner: string, equipId: string): void {\r\n  const key = ownerEquipsKey(owner);\r\n  let equips = getString(key);\r\n  if (equips.length > 0) {\r\n    equips += ',';\r\n  }\r\n  equips += equipId;\r\n  setString(key, equips);\r\n}\r\n\r\nexport function removeEquipmentFromOwner(owner: string, equipId: string): void {\r\n  const equips = getString(ownerEquipsKey(owner)).split(',');\r\n  const newEquips: string[] = [];\r\n  for (let i = 0; i < equips.length; i++) {\r\n    if (equips[i] != equipId) {\r\n      newEquips.push(equips[i]);\r\n    }\r\n  }\r\n  setString(ownerEquipsKey(owner), newEquips.join(','));\r\n}\r\n\r\nexport function getOwnerEquipment(owner: string): string[] {\r\n  const equips = getString(ownerEquipsKey(owner));\r\n  if (equips.length == 0) return [];\r\n  return equips.split(',');\r\n}\r\n","/**\r\n * Character Management Component\r\n * Handles character creation, stats, leveling, and upgrades\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport { Args } from '@massalabs/as-types';\r\nimport {\r\n  Character,\r\n  CLASS_WARRIOR,\r\n  CLASS_ASSASSIN,\r\n  CLASS_MAGE,\r\n  CLASS_TANK,\r\n  CLASS_TRICKSTER,\r\n  MAX_LEVEL,\r\n  XP_PER_LEVEL,\r\n  BASE_MMR,\r\n} from './types';\r\nimport {\r\n  saveCharacter,\r\n  loadCharacter,\r\n  characterExists,\r\n  addCharacterToOwner,\r\n} from './storage';\r\n\r\n// ============================================================================\r\n// Class Base Stats Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize character stats based on class\r\n */\r\nexport function initializeClassStats(character: Character): void {\r\n  switch (character.characterClass) {\r\n    case CLASS_WARRIOR:\r\n      // Balanced fighter with good HP and damage\r\n      character.maxHp = 120;\r\n      character.hp = 120;\r\n      character.damageMin = 12;\r\n      character.damageMax = 18;\r\n      character.critChance = 12;\r\n      character.dodgeChance = 5;\r\n      character.defense = 8;\r\n      break;\r\n\r\n    case CLASS_ASSASSIN:\r\n      // Glass cannon with high damage and crit\r\n      character.maxHp = 80;\r\n      character.hp = 80;\r\n      character.damageMin = 15;\r\n      character.damageMax = 25;\r\n      character.critChance = 25;\r\n      character.dodgeChance = 15;\r\n      character.defense = 3;\r\n      break;\r\n\r\n    case CLASS_MAGE:\r\n      // Moderate HP with balanced damage\r\n      character.maxHp = 90;\r\n      character.hp = 90;\r\n      character.damageMin = 10;\r\n      character.damageMax = 22;\r\n      character.critChance = 15;\r\n      character.dodgeChance = 8;\r\n      character.defense = 4;\r\n      break;\r\n\r\n    case CLASS_TANK:\r\n      // Very high HP, low damage\r\n      character.maxHp = 180;\r\n      character.hp = 180;\r\n      character.damageMin = 8;\r\n      character.damageMax = 12;\r\n      character.critChance = 5;\r\n      character.dodgeChance = 3;\r\n      character.defense = 15;\r\n      break;\r\n\r\n    case CLASS_TRICKSTER:\r\n      // Jack of all trades\r\n      character.maxHp = 100;\r\n      character.hp = 100;\r\n      character.damageMin = 10;\r\n      character.damageMax = 16;\r\n      character.critChance = 15;\r\n      character.dodgeChance = 12;\r\n      character.defense = 6;\r\n      break;\r\n\r\n    default:\r\n      // Default to warrior stats\r\n      character.maxHp = 100;\r\n      character.hp = 100;\r\n      character.damageMin = 10;\r\n      character.damageMax = 15;\r\n      character.critChance = 10;\r\n      character.dodgeChance = 5;\r\n      character.defense = 5;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Character Creation\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new character\r\n * @param id - Unique character ID\r\n * @param characterClass - Class type (0-4)\r\n * @param name - Character name\r\n */\r\nexport function createCharacter(\r\n  id: string,\r\n  characterClass: u8,\r\n  name: string\r\n): Character {\r\n  // Validate class\r\n  assert(characterClass <= CLASS_TRICKSTER, 'Invalid character class');\r\n\r\n  // Check character doesn't already exist\r\n  assert(!characterExists(id), 'Character ID already exists');\r\n\r\n  // Validate name\r\n  assert(name.length > 0 && name.length <= 32, 'Name must be 1-32 characters');\r\n\r\n  const caller = Context.caller().toString();\r\n  const timestamp = Context.timestamp();\r\n\r\n  // Create character\r\n  const character = new Character(id, caller, name, characterClass);\r\n  character.level = 1;\r\n  character.xp = 0;\r\n  character.mmr = BASE_MMR;\r\n  character.createdAt = timestamp;\r\n\r\n  // Initialize class-specific stats\r\n  initializeClassStats(character);\r\n\r\n  // Save to storage\r\n  saveCharacter(character);\r\n\r\n  // Add to owner's character list\r\n  addCharacterToOwner(caller, id);\r\n\r\n  // Emit event\r\n  generateEvent(\r\n    `CHARACTER_CREATED:${id}:${caller}:${characterClass.toString()}:${name}`\r\n  );\r\n\r\n  return character;\r\n}\r\n\r\n// ============================================================================\r\n// Character Reading\r\n// ============================================================================\r\n\r\n/**\r\n * Read character data\r\n * @param id - Character ID\r\n */\r\nexport function readCharacter(id: string): Character {\r\n  const character = loadCharacter(id);\r\n  assert(character != null, 'Character not found');\r\n  return character!;\r\n}\r\n\r\n/**\r\n * Check if caller owns the character\r\n */\r\nexport function isCharacterOwner(characterId: string, address: string): bool {\r\n  const character = loadCharacter(characterId);\r\n  if (character == null) return false;\r\n  return character!.owner == address;\r\n}\r\n\r\n/**\r\n * Assert caller owns the character\r\n */\r\nexport function assertCharacterOwner(characterId: string): Character {\r\n  const character = loadCharacter(characterId);\r\n  assert(character != null, 'Character not found');\r\n  assert(\r\n    character!.owner == Context.caller().toString(),\r\n    'Not character owner'\r\n  );\r\n  return character!;\r\n}\r\n\r\n// ============================================================================\r\n// XP and Leveling\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate XP required for next level\r\n */\r\nexport function xpForLevel(level: u8): u64 {\r\n  // XP requirement increases each level\r\n  // Level 1->2: 100 XP\r\n  // Level 2->3: 200 XP\r\n  // etc.\r\n  return u64(level) * XP_PER_LEVEL;\r\n}\r\n\r\n/**\r\n * Grant XP to a character and handle level ups\r\n * @param charId - Character ID\r\n * @param amount - XP amount to grant\r\n */\r\nexport function grantXP(charId: string, amount: u64): void {\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n\r\n  let char = character!;\r\n  char.xp += amount;\r\n\r\n  // Check for level ups\r\n  while (char.level < MAX_LEVEL) {\r\n    const xpNeeded = xpForLevel(char.level);\r\n    if (char.xp >= xpNeeded) {\r\n      char.xp -= xpNeeded;\r\n      char.level += 1;\r\n\r\n      // Apply level up bonuses\r\n      applyLevelUpBonus(char);\r\n\r\n      generateEvent(\r\n        `LEVEL_UP:${charId}:${char.level.toString()}`\r\n      );\r\n    } else {\r\n      break;\r\n    }\r\n  }\r\n\r\n  // Cap XP at max level\r\n  if (char.level >= MAX_LEVEL) {\r\n    char.xp = 0;\r\n  }\r\n\r\n  saveCharacter(char);\r\n}\r\n\r\n/**\r\n * Apply stat bonuses on level up\r\n */\r\nfunction applyLevelUpBonus(character: Character): void {\r\n  // Increase max HP based on class\r\n  switch (character.characterClass) {\r\n    case CLASS_TANK:\r\n      character.maxHp += 15;\r\n      break;\r\n    case CLASS_WARRIOR:\r\n      character.maxHp += 10;\r\n      break;\r\n    case CLASS_TRICKSTER:\r\n      character.maxHp += 8;\r\n      break;\r\n    case CLASS_MAGE:\r\n      character.maxHp += 6;\r\n      break;\r\n    case CLASS_ASSASSIN:\r\n      character.maxHp += 5;\r\n      break;\r\n    default:\r\n      character.maxHp += 8;\r\n  }\r\n\r\n  // Heal to full on level up\r\n  character.hp = character.maxHp;\r\n\r\n  // Small damage increase every 3 levels\r\n  if (character.level % 3 == 0) {\r\n    character.damageMin += 1;\r\n    character.damageMax += 2;\r\n  }\r\n\r\n  // Small crit increase every 5 levels\r\n  if (character.level % 5 == 0) {\r\n    if (character.critChance < 50) {\r\n      character.critChance += 1;\r\n    }\r\n  }\r\n\r\n  // Defense increase every 4 levels\r\n  if (character.level % 4 == 0) {\r\n    character.defense += 1;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Character Healing\r\n// ============================================================================\r\n\r\n/**\r\n * Heal character to full HP\r\n * @param charId - Character ID\r\n */\r\nexport function healCharacter(charId: string): void {\r\n  const character = assertCharacterOwner(charId);\r\n  character.hp = character.maxHp;\r\n  saveCharacter(character);\r\n\r\n  generateEvent(`CHARACTER_HEALED:${charId}`);\r\n}\r\n\r\n// ============================================================================\r\n// Character Upgrades\r\n// ============================================================================\r\n\r\n// Upgrade types\r\nconst UPGRADE_HP: u8 = 0;\r\nconst UPGRADE_DAMAGE: u8 = 1;\r\nconst UPGRADE_CRIT: u8 = 2;\r\nconst UPGRADE_DODGE: u8 = 3;\r\nconst UPGRADE_DEFENSE: u8 = 4;\r\n\r\n/**\r\n * Upgrade a character stat (costs coins - implement payment separately)\r\n * @param charId - Character ID\r\n * @param upgradeType - Type of upgrade (0-4)\r\n */\r\nexport function upgradeCharacter(charId: string, upgradeType: u8): void {\r\n  const character = assertCharacterOwner(charId);\r\n\r\n  switch (upgradeType) {\r\n    case UPGRADE_HP:\r\n      character.maxHp += 10;\r\n      character.hp += 10;\r\n      break;\r\n    case UPGRADE_DAMAGE:\r\n      character.damageMin += 1;\r\n      character.damageMax += 2;\r\n      break;\r\n    case UPGRADE_CRIT:\r\n      assert(character.critChance < 50, 'Crit chance at maximum');\r\n      character.critChance += 2;\r\n      break;\r\n    case UPGRADE_DODGE:\r\n      assert(character.dodgeChance < 40, 'Dodge chance at maximum');\r\n      character.dodgeChance += 2;\r\n      break;\r\n    case UPGRADE_DEFENSE:\r\n      character.defense += 2;\r\n      break;\r\n    default:\r\n      assert(false, 'Invalid upgrade type');\r\n  }\r\n\r\n  saveCharacter(character);\r\n\r\n  generateEvent(\r\n    `CHARACTER_UPGRADED:${charId}:${upgradeType.toString()}`\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Battle Stats Updates\r\n// ============================================================================\r\n\r\n/**\r\n * Record a win for the character\r\n * @param charId - Character ID\r\n * @param xpGained - XP earned from the win\r\n */\r\nexport function recordWin(charId: string, xpGained: u64): void {\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n\r\n  character!.totalWins += 1;\r\n  character!.winStreak += 1;\r\n\r\n  saveCharacter(character!);\r\n\r\n  // Grant XP separately to handle leveling\r\n  if (xpGained > 0) {\r\n    grantXP(charId, xpGained);\r\n  }\r\n}\r\n\r\n/**\r\n * Record a loss for the character\r\n * @param charId - Character ID\r\n */\r\nexport function recordLoss(charId: string): void {\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n\r\n  character!.totalLosses += 1;\r\n  character!.winStreak = 0;\r\n\r\n  saveCharacter(character!);\r\n}\r\n\r\n/**\r\n * Update character MMR\r\n * @param charId - Character ID\r\n * @param newMMR - New MMR value\r\n */\r\nexport function updateCharacterMMR(charId: string, newMMR: u64): void {\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n\r\n  character!.mmr = newMMR;\r\n  saveCharacter(character!);\r\n}\r\n\r\n// ============================================================================\r\n// Character Stats with Equipment\r\n// ============================================================================\r\n\r\nimport { loadEquipment } from './storage';\r\n\r\n/**\r\n * Get effective stats including equipment bonuses\r\n */\r\nexport function getEffectiveStats(character: Character): Character {\r\n  // Clone base stats\r\n  let effectiveHp = character.maxHp;\r\n  let effectiveDmgMin = character.damageMin;\r\n  let effectiveDmgMax = character.damageMax;\r\n  let effectiveCrit = character.critChance;\r\n  let effectiveDodge = character.dodgeChance;\r\n\r\n  // Add weapon bonuses\r\n  if (character.weaponId.length > 0) {\r\n    const weapon = loadEquipment(character.weaponId);\r\n    if (weapon != null) {\r\n      effectiveDmgMin += weapon.damageMinBonus;\r\n      effectiveDmgMax += weapon.damageMaxBonus;\r\n      effectiveCrit += weapon.critBonus;\r\n    }\r\n  }\r\n\r\n  // Add armor bonuses\r\n  if (character.armorId.length > 0) {\r\n    const armor = loadEquipment(character.armorId);\r\n    if (armor != null) {\r\n      effectiveHp += armor.hpBonus;\r\n      effectiveDodge += armor.dodgeBonus;\r\n    }\r\n  }\r\n\r\n  // Add accessory bonuses\r\n  if (character.accessoryId.length > 0) {\r\n    const accessory = loadEquipment(character.accessoryId);\r\n    if (accessory != null) {\r\n      effectiveCrit += accessory.critBonus;\r\n      effectiveDodge += accessory.dodgeBonus;\r\n    }\r\n  }\r\n\r\n  // Create a new character with effective stats\r\n  const effective = new Character();\r\n  effective.id = character.id;\r\n  effective.owner = character.owner;\r\n  effective.name = character.name;\r\n  effective.characterClass = character.characterClass;\r\n  effective.level = character.level;\r\n  effective.maxHp = effectiveHp;\r\n  effective.hp = character.hp;\r\n  effective.damageMin = effectiveDmgMin;\r\n  effective.damageMax = effectiveDmgMax;\r\n  effective.critChance = effectiveCrit > 100 ? 100 : effectiveCrit;\r\n  effective.dodgeChance = effectiveDodge > 100 ? 100 : effectiveDodge;\r\n  effective.defense = character.defense;\r\n  effective.skillSlot1 = character.skillSlot1;\r\n  effective.skillSlot2 = character.skillSlot2;\r\n  effective.skillSlot3 = character.skillSlot3;\r\n  effective.learnedSkills = character.learnedSkills;\r\n\r\n  return effective;\r\n}\r\n\r\n/**\r\n * Get character's class name as string\r\n */\r\nexport function getClassName(classId: u8): string {\r\n  switch (classId) {\r\n    case CLASS_WARRIOR:\r\n      return 'Warrior';\r\n    case CLASS_ASSASSIN:\r\n      return 'Assassin';\r\n    case CLASS_MAGE:\r\n      return 'Mage';\r\n    case CLASS_TANK:\r\n      return 'Tank';\r\n    case CLASS_TRICKSTER:\r\n      return 'Trickster';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n","/**\r\n * Randomness Engine for the Fighter Game Smart Contract\r\n * Provides pseudo-random number generation for game mechanics\r\n *\r\n * Note: This is a prototype implementation using XORshift.\r\n * Production should use Massa's VRF or oracle-based randomness.\r\n */\r\n\r\nimport { Context } from '@massalabs/massa-as-sdk';\r\n\r\n// Global seed state for the current transaction\r\nlet _currentSeed: u64 = 0;\r\n\r\n/**\r\n * Initialize or update the random seed using blockchain data\r\n */\r\nexport function initializeSeed(salt: u64): void {\r\n  const timestamp = Context.timestamp();\r\n  const caller = Context.caller().toString();\r\n\r\n  // Create seed from multiple sources\r\n  let seed: u64 = timestamp ^ salt;\r\n\r\n  // Mix in caller address bytes\r\n  for (let i = 0; i < caller.length; i++) {\r\n    seed = seed ^ (u64(caller.charCodeAt(i)) << ((i % 8) * 8));\r\n  }\r\n\r\n  _currentSeed = seed;\r\n}\r\n\r\n/**\r\n * Get current seed value\r\n */\r\nexport function getCurrentSeed(): u64 {\r\n  return _currentSeed;\r\n}\r\n\r\n/**\r\n * Set seed directly (for battle state restoration)\r\n */\r\nexport function setSeed(seed: u64): void {\r\n  _currentSeed = seed;\r\n}\r\n\r\n/**\r\n * XORshift64 pseudo-random number generator\r\n * Fast and reasonably distributed for game purposes\r\n */\r\nexport function nextRandom(): u64 {\r\n  let x = _currentSeed;\r\n  x ^= x << 13;\r\n  x ^= x >> 7;\r\n  x ^= x << 17;\r\n  _currentSeed = x;\r\n  return x;\r\n}\r\n\r\n/**\r\n * Generate a random number in range [0, max)\r\n */\r\nexport function randomRange(max: u64): u64 {\r\n  if (max == 0) return 0;\r\n  return nextRandom() % max;\r\n}\r\n\r\n/**\r\n * Generate a random number in range [min, max] (inclusive)\r\n */\r\nexport function randomBetween(min: u64, max: u64): u64 {\r\n  if (min >= max) return min;\r\n  return min + randomRange(max - min + 1);\r\n}\r\n\r\n/**\r\n * Generate a random u8 in range [min, max] (inclusive)\r\n */\r\nexport function randomU8Between(min: u8, max: u8): u8 {\r\n  if (min >= max) return min;\r\n  return u8(min + randomRange(u64(max - min + 1)));\r\n}\r\n\r\n/**\r\n * Generate a random u16 in range [min, max] (inclusive)\r\n */\r\nexport function randomU16Between(min: u16, max: u16): u16 {\r\n  if (min >= max) return min;\r\n  return u16(min + randomRange(u64(max - min + 1)));\r\n}\r\n\r\n/**\r\n * Check if a percentage chance succeeds\r\n * @param chance - Percentage (0-100)\r\n * @returns true if the roll succeeds\r\n */\r\nexport function rollChance(chance: u8): bool {\r\n  if (chance >= 100) return true;\r\n  if (chance == 0) return false;\r\n  return randomU8Between(1, 100) <= chance;\r\n}\r\n\r\n/**\r\n * Roll for critical hit\r\n * @param critChance - Crit chance percentage\r\n * @param guaranteed - If true, always returns true\r\n */\r\nexport function rollCritical(critChance: u8, guaranteed: bool): bool {\r\n  if (guaranteed) return true;\r\n  return rollChance(critChance);\r\n}\r\n\r\n/**\r\n * Roll for dodge\r\n * @param dodgeChance - Dodge chance percentage\r\n * @param boost - Additional dodge chance from skills\r\n */\r\nexport function rollDodge(dodgeChance: u8, boost: u8): bool {\r\n  const total: i32 = i32(dodgeChance) + i32(boost);\r\n  const totalChance: u8 = total > 100 ? 100 : u8(total);\r\n  return rollChance(totalChance);\r\n}\r\n\r\n/**\r\n * Roll for wildcard event trigger\r\n * @param baseChance - Base wildcard trigger chance (default 10%)\r\n */\r\nexport function rollWildcard(baseChance: u8 = 10): bool {\r\n  return rollChance(baseChance);\r\n}\r\n\r\n/**\r\n * Generate damage roll within range\r\n * @param minDamage - Minimum damage\r\n * @param maxDamage - Maximum damage\r\n */\r\nexport function rollDamage(minDamage: u16, maxDamage: u16): u16 {\r\n  return randomU16Between(minDamage, maxDamage);\r\n}\r\n\r\n/**\r\n * Simple hash function for strings to u64\r\n * Used for creating deterministic seeds from IDs\r\n */\r\nexport function hashString(input: string): u64 {\r\n  let hash: u64 = 5381;\r\n  for (let i = 0; i < input.length; i++) {\r\n    hash = ((hash << 5) + hash) ^ u64(input.charCodeAt(i));\r\n  }\r\n  return hash;\r\n}\r\n\r\n/**\r\n * Create a battle seed from battle ID and timestamp\r\n */\r\nexport function createBattleSeed(battleId: string, timestamp: u64): u64 {\r\n  return hashString(battleId) ^ timestamp ^ (timestamp << 32);\r\n}\r\n","/**\r\n * Leaderboard and MMR Component\r\n * Handles MMR calculation, ranking, and statistics\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  LeaderboardEntry,\r\n  Character,\r\n  BASE_MMR,\r\n} from './types';\r\nimport {\r\n  saveLeaderboardEntry,\r\n  loadLeaderboardEntry,\r\n  getLeaderboardCount,\r\n  setLeaderboardCount,\r\n  loadCharacter,\r\n  saveCharacter,\r\n} from './storage';\r\nimport { recordWin, recordLoss, updateCharacterMMR } from './character';\r\n\r\n// ============================================================================\r\n// MMR Configuration\r\n// ============================================================================\r\n\r\n// K-factor for MMR calculation (higher = more volatile)\r\nconst K_FACTOR: u64 = 32;\r\n// Minimum MMR\r\nconst MIN_MMR: u64 = 100;\r\n// Maximum MMR\r\nconst MAX_MMR: u64 = 5000;\r\n// Maximum leaderboard size\r\nconst MAX_LEADERBOARD_SIZE: u32 = 100;\r\n\r\n// ============================================================================\r\n// MMR Calculation\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate expected score based on MMR difference\r\n * Uses simplified ELO formula\r\n */\r\nexport function calculateExpectedScore(playerMMR: u64, opponentMMR: u64): u64 {\r\n  // Simplified: expected = 1 / (1 + 10^((opponent - player) / 400))\r\n  // We approximate this with integer math\r\n\r\n  let diff: i64 = i64(opponentMMR) - i64(playerMMR);\r\n\r\n  // Clamp difference to prevent overflow\r\n  if (diff > 400) diff = 400;\r\n  if (diff < -400) diff = -400;\r\n\r\n  // Approximate expected score (0-100 scale)\r\n  // At equal MMR: 50\r\n  // At +400 diff: ~10\r\n  // At -400 diff: ~90\r\n  let expected: i64 = 50 - diff / 8;\r\n  if (expected < 5) expected = 5;\r\n  if (expected > 95) expected = 95;\r\n\r\n  return u64(expected);\r\n}\r\n\r\n/**\r\n * Calculate MMR change after a match\r\n * @param won - Whether the player won\r\n * @param playerMMR - Player's current MMR\r\n * @param opponentMMR - Opponent's MMR\r\n * @returns New MMR value\r\n */\r\nexport function calculateNewMMR(\r\n  won: bool,\r\n  playerMMR: u64,\r\n  opponentMMR: u64\r\n): u64 {\r\n  const expected = calculateExpectedScore(playerMMR, opponentMMR);\r\n  const actual: u64 = won ? 100 : 0;\r\n\r\n  let delta: i64;\r\n  if (actual > expected) {\r\n    delta = i64((K_FACTOR * (actual - expected)) / 100);\r\n  } else {\r\n    delta = -i64((K_FACTOR * (expected - actual)) / 100);\r\n  }\r\n\r\n  let newMMR: i64 = i64(playerMMR) + delta;\r\n\r\n  // Clamp to valid range\r\n  if (newMMR < i64(MIN_MMR)) newMMR = i64(MIN_MMR);\r\n  if (newMMR > i64(MAX_MMR)) newMMR = i64(MAX_MMR);\r\n\r\n  return u64(newMMR);\r\n}\r\n\r\n/**\r\n * Update MMR after a battle\r\n * @param winnerId - Winner's character ID\r\n * @param loserId - Loser's character ID\r\n * @param xpForWinner - XP to award winner\r\n */\r\nexport function updateBattleMMR(\r\n  winnerId: string,\r\n  loserId: string,\r\n  xpForWinner: u64\r\n): void {\r\n  const winner = loadCharacter(winnerId);\r\n  const loser = loadCharacter(loserId);\r\n\r\n  if (winner == null || loser == null) return;\r\n\r\n  const winnerOldMMR = winner.mmr;\r\n  const loserOldMMR = loser.mmr;\r\n\r\n  // Calculate new MMRs\r\n  const winnerNewMMR = calculateNewMMR(true, winnerOldMMR, loserOldMMR);\r\n  const loserNewMMR = calculateNewMMR(false, loserOldMMR, winnerOldMMR);\r\n\r\n  // Update winner\r\n  recordWin(winnerId, xpForWinner);\r\n  updateCharacterMMR(winnerId, winnerNewMMR);\r\n\r\n  // Update loser\r\n  recordLoss(loserId);\r\n  updateCharacterMMR(loserId, loserNewMMR);\r\n\r\n  // Update leaderboard\r\n  updateLeaderboardEntry(winner);\r\n  updateLeaderboardEntry(loser);\r\n\r\n  generateEvent(\r\n    `MMR_UPDATE:${winnerId}:${winnerOldMMR.toString()}:${winnerNewMMR.toString()}`\r\n  );\r\n  generateEvent(\r\n    `MMR_UPDATE:${loserId}:${loserOldMMR.toString()}:${loserNewMMR.toString()}`\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Leaderboard Management\r\n// ============================================================================\r\n\r\n/**\r\n * Update or insert a character's leaderboard entry\r\n */\r\nexport function updateLeaderboardEntry(character: Character): void {\r\n  // Reload to get latest stats\r\n  const freshChar = loadCharacter(character.id);\r\n  if (freshChar == null) return;\r\n\r\n  const entry = new LeaderboardEntry(\r\n    freshChar.id,\r\n    freshChar.owner,\r\n    freshChar.mmr\r\n  );\r\n  entry.wins = freshChar.totalWins;\r\n  entry.losses = freshChar.totalLosses;\r\n\r\n  // Find position in leaderboard\r\n  let count = getLeaderboardCount();\r\n  let insertPosition: u32 = count;\r\n\r\n  // Find where this entry should go (sorted by MMR descending)\r\n  for (let i: u32 = 0; i < count; i++) {\r\n    const existing = loadLeaderboardEntry(i);\r\n    if (existing == null) continue;\r\n\r\n    // If this is the same character, remember to remove old entry\r\n    if (existing.characterId == entry.characterId) {\r\n      // Shift all entries after this one up\r\n      for (let j: u32 = i; j < count - 1; j++) {\r\n        const next = loadLeaderboardEntry(j + 1);\r\n        if (next != null) {\r\n          saveLeaderboardEntry(j, next);\r\n        }\r\n      }\r\n      count--;\r\n      setLeaderboardCount(count);\r\n    }\r\n\r\n    // Find insert position\r\n    if (insertPosition == count && entry.mmr > existing.mmr) {\r\n      insertPosition = i;\r\n    }\r\n  }\r\n\r\n  // Insert the new entry\r\n  if (insertPosition < MAX_LEADERBOARD_SIZE) {\r\n    // Shift entries down to make room\r\n    let shiftEnd = count < MAX_LEADERBOARD_SIZE ? count : MAX_LEADERBOARD_SIZE - 1;\r\n    for (let i = shiftEnd; i > insertPosition; i--) {\r\n      const prev = loadLeaderboardEntry(i - 1);\r\n      if (prev != null) {\r\n        saveLeaderboardEntry(i, prev);\r\n      }\r\n    }\r\n\r\n    // Insert new entry\r\n    saveLeaderboardEntry(insertPosition, entry);\r\n\r\n    // Update count\r\n    if (count < MAX_LEADERBOARD_SIZE) {\r\n      setLeaderboardCount(count + 1);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Get leaderboard entries\r\n * @param topN - Number of entries to return\r\n * @returns Array of leaderboard entries\r\n */\r\nexport function getLeaderboard(topN: u32): LeaderboardEntry[] {\r\n  const count = getLeaderboardCount();\r\n  const limit = topN < count ? topN : count;\r\n  const results: LeaderboardEntry[] = [];\r\n\r\n  for (let i: u32 = 0; i < limit; i++) {\r\n    const entry = loadLeaderboardEntry(i);\r\n    if (entry != null) {\r\n      results.push(entry);\r\n    }\r\n  }\r\n\r\n  return results;\r\n}\r\n\r\n/**\r\n * Get a character's rank on the leaderboard\r\n * @param characterId - Character to find\r\n * @returns Rank (1-indexed), or 0 if not found\r\n */\r\nexport function getCharacterRank(characterId: string): u32 {\r\n  const count = getLeaderboardCount();\r\n\r\n  for (let i: u32 = 0; i < count; i++) {\r\n    const entry = loadLeaderboardEntry(i);\r\n    if (entry != null && entry.characterId == characterId) {\r\n      return i + 1; // 1-indexed rank\r\n    }\r\n  }\r\n\r\n  return 0; // Not on leaderboard\r\n}\r\n\r\n/**\r\n * Get character's leaderboard entry\r\n */\r\nexport function getCharacterLeaderboardEntry(\r\n  characterId: string\r\n): LeaderboardEntry | null {\r\n  const count = getLeaderboardCount();\r\n\r\n  for (let i: u32 = 0; i < count; i++) {\r\n    const entry = loadLeaderboardEntry(i);\r\n    if (entry != null && entry!.characterId == characterId) {\r\n      return entry;\r\n    }\r\n  }\r\n\r\n  return null;\r\n}\r\n\r\n// ============================================================================\r\n// Statistics\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate win rate for a character\r\n */\r\nexport function getWinRate(characterId: string): u8 {\r\n  const character = loadCharacter(characterId);\r\n  if (character == null) return 0;\r\n\r\n  const total = character!.totalWins + character!.totalLosses;\r\n  if (total == 0) return 0;\r\n\r\n  return u8((u64(character!.totalWins) * 100) / u64(total));\r\n}\r\n\r\n/**\r\n * Get MMR tier name\r\n */\r\nexport function getMMRTier(mmr: u64): string {\r\n  if (mmr >= 3000) return 'Grandmaster';\r\n  if (mmr >= 2500) return 'Master';\r\n  if (mmr >= 2000) return 'Diamond';\r\n  if (mmr >= 1500) return 'Platinum';\r\n  if (mmr >= 1200) return 'Gold';\r\n  if (mmr >= 1000) return 'Silver';\r\n  if (mmr >= 800) return 'Bronze';\r\n  return 'Iron';\r\n}\r\n\r\n/**\r\n * Rebuild leaderboard from all characters (admin function)\r\n * Note: This is expensive and should only be used for maintenance\r\n */\r\nexport function rebuildLeaderboard(characterIds: string[]): void {\r\n  // Clear existing leaderboard\r\n  setLeaderboardCount(0);\r\n\r\n  // Re-add all characters\r\n  for (let i = 0; i < characterIds.length; i++) {\r\n    const character = loadCharacter(characterIds[i]);\r\n    if (character != null) {\r\n      updateLeaderboardEntry(character!);\r\n    }\r\n  }\r\n\r\n  generateEvent(`LEADERBOARD_REBUILT:${characterIds.length.toString()}`);\r\n}\r\n","/**\r\n * Treasury Management Component\r\n * Handles fee collection, balance tracking, and withdrawals\r\n */\r\n\r\nimport { Context, generateEvent, transferCoins, Address, balance } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  getTreasury,\r\n  setTreasury,\r\n  addToTreasury,\r\n  isAdmin,\r\n} from './storage';\r\n\r\n// ============================================================================\r\n// Fee Configuration\r\n// ============================================================================\r\n\r\n// Battle fee (in nanoMAS)\r\nexport const BATTLE_FEE: u64 = 1_000_000_000; // 1 MAS\r\n\r\n// Character creation fee\r\nexport const CHARACTER_CREATION_FEE: u64 = 500_000_000; // 0.5 MAS\r\n\r\n// Equipment repair fee multiplier (based on rarity)\r\nexport const REPAIR_FEE_BASE: u64 = 100_000_000; // 0.1 MAS\r\n\r\n// Skill learning fee\r\nexport const SKILL_LEARNING_FEE: u64 = 200_000_000; // 0.2 MAS\r\n\r\n// Character upgrade fee\r\nexport const UPGRADE_FEE: u64 = 300_000_000; // 0.3 MAS\r\n\r\n// Treasury fee percentage from tournaments (percentage)\r\nexport const TOURNAMENT_FEE_PERCENT: u8 = 5;\r\n\r\n// ============================================================================\r\n// Fee Collection\r\n// ============================================================================\r\n\r\n/**\r\n * Collect battle fee\r\n */\r\nexport function collectBattleFee(): void {\r\n  const transferred = Context.transferredCoins();\r\n  assert(transferred >= BATTLE_FEE, 'Insufficient battle fee');\r\n\r\n  addToTreasury(BATTLE_FEE);\r\n\r\n  // Refund excess\r\n  const excess = transferred - BATTLE_FEE;\r\n  if (excess > 0) {\r\n    transferCoins(Context.caller(), excess);\r\n  }\r\n\r\n  generateEvent(`BATTLE_FEE_COLLECTED:${BATTLE_FEE.toString()}`);\r\n}\r\n\r\n/**\r\n * Collect character creation fee\r\n */\r\nexport function collectCharacterCreationFee(): void {\r\n  const transferred = Context.transferredCoins();\r\n  assert(transferred >= CHARACTER_CREATION_FEE, 'Insufficient creation fee');\r\n\r\n  addToTreasury(CHARACTER_CREATION_FEE);\r\n\r\n  // Refund excess\r\n  const excess = transferred - CHARACTER_CREATION_FEE;\r\n  if (excess > 0) {\r\n    transferCoins(Context.caller(), excess);\r\n  }\r\n\r\n  generateEvent(`CREATION_FEE_COLLECTED:${CHARACTER_CREATION_FEE.toString()}`);\r\n}\r\n\r\n/**\r\n * Collect skill learning fee\r\n */\r\nexport function collectSkillLearningFee(): void {\r\n  const transferred = Context.transferredCoins();\r\n  assert(transferred >= SKILL_LEARNING_FEE, 'Insufficient skill learning fee');\r\n\r\n  addToTreasury(SKILL_LEARNING_FEE);\r\n\r\n  // Refund excess\r\n  const excess = transferred - SKILL_LEARNING_FEE;\r\n  if (excess > 0) {\r\n    transferCoins(Context.caller(), excess);\r\n  }\r\n\r\n  generateEvent(`SKILL_FEE_COLLECTED:${SKILL_LEARNING_FEE.toString()}`);\r\n}\r\n\r\n/**\r\n * Collect upgrade fee\r\n */\r\nexport function collectUpgradeFee(): void {\r\n  const transferred = Context.transferredCoins();\r\n  assert(transferred >= UPGRADE_FEE, 'Insufficient upgrade fee');\r\n\r\n  addToTreasury(UPGRADE_FEE);\r\n\r\n  // Refund excess\r\n  const excess = transferred - UPGRADE_FEE;\r\n  if (excess > 0) {\r\n    transferCoins(Context.caller(), excess);\r\n  }\r\n\r\n  generateEvent(`UPGRADE_FEE_COLLECTED:${UPGRADE_FEE.toString()}`);\r\n}\r\n\r\n/**\r\n * Calculate repair fee based on equipment rarity\r\n * @param rarity - Equipment rarity (0-3)\r\n */\r\nexport function calculateRepairFee(rarity: u8): u64 {\r\n  // Common: 0.1 MAS, Rare: 0.2 MAS, Epic: 0.4 MAS, Legendary: 0.8 MAS\r\n  return REPAIR_FEE_BASE * u64(1 << rarity);\r\n}\r\n\r\n/**\r\n * Collect repair fee\r\n * @param rarity - Equipment rarity\r\n */\r\nexport function collectRepairFee(rarity: u8): void {\r\n  const fee = calculateRepairFee(rarity);\r\n  const transferred = Context.transferredCoins();\r\n  assert(transferred >= fee, 'Insufficient repair fee');\r\n\r\n  addToTreasury(fee);\r\n\r\n  // Refund excess\r\n  const excess = transferred - fee;\r\n  if (excess > 0) {\r\n    transferCoins(Context.caller(), excess);\r\n  }\r\n\r\n  generateEvent(`REPAIR_FEE_COLLECTED:${fee.toString()}`);\r\n}\r\n\r\n/**\r\n * Calculate tournament fee from prize pool\r\n * @param prizePool - Total prize pool\r\n */\r\nexport function calculateTournamentFee(prizePool: u64): u64 {\r\n  return (prizePool * u64(TOURNAMENT_FEE_PERCENT)) / 100;\r\n}\r\n\r\n/**\r\n * Collect tournament fee\r\n * @param prizePool - Total prize pool\r\n */\r\nexport function collectTournamentFee(prizePool: u64): void {\r\n  const fee = calculateTournamentFee(prizePool);\r\n  addToTreasury(fee);\r\n\r\n  generateEvent(`TOURNAMENT_FEE_COLLECTED:${fee.toString()}`);\r\n}\r\n\r\n// ============================================================================\r\n// Treasury Query\r\n// ============================================================================\r\n\r\n/**\r\n * Get current treasury balance\r\n */\r\nexport function getTreasuryBalance(): u64 {\r\n  return getTreasury();\r\n}\r\n\r\n/**\r\n * Get contract's actual coin balance\r\n */\r\nexport function getContractBalance(): u64 {\r\n  return balance();\r\n}\r\n\r\n// ============================================================================\r\n// Admin Withdrawals\r\n// ============================================================================\r\n\r\n/**\r\n * Withdraw from treasury (admin only)\r\n * @param amount - Amount to withdraw\r\n * @param toAddress - Destination address\r\n */\r\nexport function withdrawFromTreasury(amount: u64, toAddress: string): void {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can withdraw');\r\n\r\n  const currentBalance = getTreasury();\r\n  assert(amount <= currentBalance, 'Insufficient treasury balance');\r\n\r\n  // Update treasury\r\n  setTreasury(currentBalance - amount);\r\n\r\n  // Transfer coins\r\n  transferCoins(new Address(toAddress), amount);\r\n\r\n  generateEvent(\r\n    `TREASURY_WITHDRAWAL:${amount.toString()}:${toAddress}:${caller}`\r\n  );\r\n}\r\n\r\n/**\r\n * Emergency withdraw all funds (admin only)\r\n */\r\nexport function emergencyWithdraw(toAddress: string): void {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can emergency withdraw');\r\n\r\n  const contractBal = balance();\r\n  if (contractBal > 0) {\r\n    transferCoins(new Address(toAddress), contractBal);\r\n    setTreasury(0);\r\n\r\n    generateEvent(\r\n      `EMERGENCY_WITHDRAWAL:${contractBal.toString()}:${toAddress}:${caller}`\r\n    );\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Fee Info\r\n// ============================================================================\r\n\r\n/**\r\n * Get all fee information as formatted string\r\n */\r\nexport function getFeeInfo(): string {\r\n  return `Battle: ${BATTLE_FEE.toString()} nanoMAS, ` +\r\n    `Character Creation: ${CHARACTER_CREATION_FEE.toString()} nanoMAS, ` +\r\n    `Skill Learning: ${SKILL_LEARNING_FEE.toString()} nanoMAS, ` +\r\n    `Upgrade: ${UPGRADE_FEE.toString()} nanoMAS, ` +\r\n    `Repair Base: ${REPAIR_FEE_BASE.toString()} nanoMAS, ` +\r\n    `Tournament Fee: ${TOURNAMENT_FEE_PERCENT.toString()}%`;\r\n}\r\n","/**\n * Converts a UTF-16 string (AssemblyScript's default) to a UTF-8 encoded StaticArray<u8>.\n *\n * @remarks\n * If the string is empty, returns an empty array.\n *\n * @param str - the string to convert\n *\n * @returns A StaticArray<u8> representation of the input string.\n */\nexport function stringToBytes(str: string): StaticArray<u8> {\n  if (!str.length) {\n    return [];\n  }\n  return changetype<StaticArray<u8>>(\n    String.UTF8.encode(str, false, String.UTF8.ErrorMode.ERROR),\n  );\n}\n\n/**\n * Converts a StaticArray<u8> containing UTF-8 encoded data to a UTF-16 string (AssemblyScript's default).\n *\n * @remarks\n * If the array is empty, returns an empty string.\n *\n * @param arr - the array to convert\n *\n * @returns A UTF-16 string representation of the input array.\n */\nexport function bytesToString(arr: StaticArray<u8>): string {\n  if (!arr.length) {\n    return '';\n  }\n  return String.UTF8.decode(changetype<ArrayBuffer>(arr));\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { compareImpl, strtol, strtod, isSpace, isAscii, isFinalSigma, toLower8, toUpper8 } from \"./util/string\";\nimport { SPECIALS_UPPER, casemap, bsearch } from \"./util/casemap\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_UNPAIRED_SURROGATE } from \"./util/error\";\nimport { idof } from \"./builtins\";\nimport { Array } from \"./array\";\n\n@final export abstract class String {\n\n  @lazy static readonly MAX_LENGTH: i32 = <i32>(BLOCK_MAXSIZE >>> alignof<u16>());\n\n  static fromCharCode(unit: i32, surr: i32 = -1): String {\n    let hasSur = surr > 0;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    store<u16>(changetype<usize>(out), <u16>unit);\n    if (hasSur) store<u16>(changetype<usize>(out), <u16>surr, 2);\n    return out;\n  }\n\n  static fromCharCodes(units: Array<i32>): String {\n    let length = units.length;\n    let out = changetype<String>(__new(<usize>length << 1, idof<String>()));\n    let ptr = units.dataStart;\n    for (let i = 0; i < length; ++i) {\n      store<u16>(changetype<usize>(out) + (<usize>i << 1), load<i32>(ptr + (<usize>i << 2)));\n    }\n    return out;\n  }\n\n  static fromCodePoint(code: i32): String {\n    let hasSur = <u32>code > 0xFFFF;\n    let out = changetype<String>(__new(2 << i32(hasSur), idof<String>()));\n    if (!hasSur) {\n      store<u16>(changetype<usize>(out), <u16>code);\n    } else {\n      // Checks valid code point range\n      assert(<u32>code <= 0x10FFFF);\n      code -= 0x10000;\n      let hi = (code & 0x03FF) | 0xDC00;\n      let lo = code >>> 10 | 0xD800;\n      store<u32>(changetype<usize>(out), lo | hi << 16);\n    }\n    return out;\n  }\n\n  @builtin static raw(parts: TemplateStringsArray, ...args: unknown[]): string { return unreachable(); }\n\n  get length(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize >> 1;\n  }\n\n  at(pos: i32): String {\n    let len = this.length;\n    pos += select(0, len, pos >= 0);\n    if (<u32>pos >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let out = __new(2, idof<String>());\n    store<u16>(out, load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return changetype<String>(out); // retains\n  }\n\n  @operator(\"[]\") charAt(pos: i32): String {\n    if (<u32>pos >= <u32>this.length) return changetype<String>(\"\");\n    let out = changetype<String>(__new(2, idof<String>()));\n    store<u16>(changetype<usize>(out), load<u16>(changetype<usize>(this) + (<usize>pos << 1)));\n    return out;\n  }\n\n  charCodeAt(pos: i32): i32 {\n    if (<u32>pos >= <u32>this.length) return -1; // (NaN)\n    return load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n  }\n\n  codePointAt(pos: i32): i32 {\n    let len = this.length;\n    if (<u32>pos >= <u32>len) return -1; // (undefined)\n    let first = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1));\n    if ((first & 0xFC00) != 0xD800 || pos + 1 == len) return first;\n    let second = <i32>load<u16>(changetype<usize>(this) + (<usize>pos << 1), 2);\n    if ((second & 0xFC00) != 0xDC00) return first;\n    return (first - 0xD800 << 10) + (second - 0xDC00) + 0x10000;\n  }\n\n  @operator(\"+\") private static __concat(left: String, right: String): String {\n    return left.concat(right);\n  }\n\n  concat(other: String): String {\n    let thisSize: isize = this.length << 1;\n    let otherSize: isize = other.length << 1;\n    let outSize: usize = thisSize + otherSize;\n    if (outSize == 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(outSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(other), otherSize);\n    return out;\n  }\n\n  endsWith(search: String, end: i32 = String.MAX_LENGTH): bool {\n    end = min(max(end, 0), this.length);\n    let searchLength = <isize>search.length;\n    let searchStart = <isize>end - searchLength;\n    if (searchStart < 0) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  @operator(\"==\") private static __eq(left: String | null, right: String | null): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return true;\n    if (changetype<usize>(left) == 0 || changetype<usize>(right) == 0) return false;\n    let leftLength = changetype<string>(left).length;\n    if (leftLength != changetype<string>(right).length) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(left, 0, right, 0, leftLength);\n  }\n\n  @operator.prefix(\"!\")\n  private static __not(str: String | null): bool {\n    return changetype<usize>(str) == 0 || !changetype<string>(str).length;\n  }\n\n  @operator(\"!=\")\n  private static __ne(left: String | null, right: String | null): bool {\n    return !this.__eq(left, right);\n  }\n\n  @operator(\">\") private static __gt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return false;\n    let rightLength = right.length;\n    if (!rightLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res > 0 : leftLength > rightLength;\n  }\n\n  @operator(\">=\") private static __gte(left: String, right: String): bool {\n    return !this.__lt(left, right);\n  }\n\n  @operator(\"<\") private static __lt(left: String, right: String): bool {\n    if (changetype<usize>(left) == changetype<usize>(right)) return false;\n    let rightLength = right.length;\n    if (!rightLength) return false;\n    let leftLength  = left.length;\n    if (!leftLength) return true;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(left, 0, right, 0, min(leftLength, rightLength));\n    return res ? res < 0 : leftLength < rightLength;\n  }\n\n  @operator(\"<=\") private static __lte(left: String, right: String): bool {\n    return !this.__gt(left, right);\n  }\n\n  includes(search: String, start: i32 = 0): bool {\n    return this.indexOf(search, start) != -1;\n  }\n\n  indexOf(search: String, start: i32 = 0): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return 0;\n    let len = <isize>this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), len);\n    for (len -= searchLen; searchStart <= len; ++searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  lastIndexOf(search: String, start: i32 = i32.MAX_VALUE): i32 {\n    let searchLen = <isize>search.length;\n    if (!searchLen) return this.length;\n    let len = this.length;\n    if (!len) return -1;\n    let searchStart = min(max(<isize>start, 0), <isize>len - searchLen);\n    for (; searchStart >= 0; --searchStart) {\n      // @ts-ignore: string <-> String\n      if (!compareImpl(this, searchStart, search, 0, searchLen)) return <i32>searchStart;\n    }\n    return -1;\n  }\n\n  // TODO: implement full locale comparison with locales and Collator options\n  localeCompare(other: String): i32 {\n    if (changetype<usize>(other) == changetype<usize>(this)) return 0;\n    let alen = this.length;\n    let blen = other.length;\n    // @ts-ignore: string <-> String\n    let res = compareImpl(this, 0, other, 0, <usize>min(alen, blen));\n    res = res ? res : alen - blen;\n    // normalize to [-1, 1] range\n    return i32(res > 0) - i32(res < 0);\n  }\n\n  startsWith(search: String, start: i32 = 0): bool {\n    let len = <isize>this.length;\n    let searchStart = min(max(<isize>start, 0), len);\n    let searchLength = <isize>search.length;\n    if (searchLength + searchStart > len) return false;\n    // @ts-ignore: string <-> String\n    return !compareImpl(this, searchStart, search, 0, searchLength);\n  }\n\n  substr(start: i32, length: i32 = i32.MAX_VALUE): String { // legacy\n    let intStart: isize = start;\n    let end: isize = length;\n    let len: isize = this.length;\n    if (intStart < 0) intStart = max(len + intStart, 0);\n    let size = min(max(end, 0), len - intStart) << 1;\n    if (size <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (intStart << 1), size);\n    return out;\n  }\n\n  substring(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len: isize = this.length;\n    let finalStart = min<isize>(max(start, 0), len);\n    let finalEnd = min<isize>(max(end, 0), len);\n    let fromPos = min<isize>(finalStart, finalEnd) << 1;\n    let toPos = max<isize>(finalStart, finalEnd) << 1;\n    let size = toPos - fromPos;\n    if (!size) return changetype<String>(\"\");\n    if (!fromPos && toPos == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + fromPos, size);\n    return out;\n  }\n\n  trim(): String {\n    let len = this.length;\n    let size: usize = len << 1;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2; size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (!offset && size == len << 1) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  @inline\n  trimLeft(): String {\n    return this.trimStart();\n  }\n\n  @inline\n  trimRight(): String {\n    return this.trimEnd();\n  }\n\n  trimStart(): String {\n    let size = <usize>this.length << 1;\n    let offset: usize = 0;\n    while (offset < size && isSpace(load<u16>(changetype<usize>(this) + offset))) {\n      offset += 2;\n    }\n    if (!offset) return this;\n    size -= offset;\n    if (!size) return changetype<String>(\"\");\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + offset, size);\n    return out;\n  }\n\n  trimEnd(): String {\n    let originalSize = <usize>this.length << 1;\n    let size = originalSize;\n    while (size && isSpace(load<u16>(changetype<usize>(this) + size - 2))) {\n      size -= 2;\n    }\n    if (!size) return changetype<String>(\"\");\n    if (size == originalSize) return this;\n    let out = changetype<String>(__new(size, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), size);\n    return out;\n  }\n\n  padStart(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let prependSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    if (prependSize > padSize) {\n      let repeatCount = (prependSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = prependSize - restBase;\n      memory.repeat(changetype<usize>(out), changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out), changetype<usize>(pad), prependSize);\n    }\n    memory.copy(changetype<usize>(out) + prependSize, changetype<usize>(this), thisSize);\n    return out;\n  }\n\n  padEnd(length: i32, pad: string = \" \"): String {\n    let thisSize = <usize>this.length << 1;\n    let targetSize = <usize>length << 1;\n    let padSize = <usize>pad.length << 1;\n    if (targetSize < thisSize || !padSize) return this;\n    let appendSize = targetSize - thisSize;\n    let out = changetype<String>(__new(targetSize, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this), thisSize);\n    if (appendSize > padSize) {\n      let repeatCount = (appendSize - 2) / padSize;\n      let restBase = repeatCount * padSize;\n      let restSize = appendSize - restBase;\n      memory.repeat(changetype<usize>(out) + thisSize, changetype<usize>(pad), padSize, repeatCount);\n      memory.copy(changetype<usize>(out) + thisSize + restBase, changetype<usize>(pad), restSize);\n    } else {\n      memory.copy(changetype<usize>(out) + thisSize, changetype<usize>(pad), appendSize);\n    }\n    return out;\n  }\n\n  repeat(count: i32 = 0): String {\n    let length = this.length;\n\n    // Most browsers can't handle strings 1 << 28 chars or longer\n    if (count < 0 || <u64>length * count > (1 << 28)) {\n      throw new RangeError(E_INVALIDLENGTH);\n    }\n\n    if (count == 0 || !length) return changetype<String>(\"\");\n    if (count == 1) return this;\n    let out = changetype<String>(__new((length * count) << 1, idof<String>()));\n    memory.repeat(changetype<usize>(out), changetype<usize>(this), <usize>length << 1, count);\n    return out;\n  }\n\n  replace(search: String, replacement: String): String {\n    let len: usize = this.length;\n    let slen: usize = search.length;\n    if (len <= slen) {\n      return len < slen ? this : select<String>(replacement, this, search == this);\n    }\n    let index: isize = this.indexOf(search);\n    if (~index) {\n      let rlen: usize = replacement.length;\n      len -= slen;\n      let olen = len + rlen;\n      if (olen) {\n        let out = changetype<String>(__new(olen << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this), index << 1);\n        memory.copy(\n          changetype<usize>(out) + (index << 1),\n          changetype<usize>(replacement),\n          rlen << 1\n        );\n        memory.copy(\n          changetype<usize>(out) + ((index + rlen) << 1),\n          changetype<usize>(this) + ((index + slen) << 1),\n          (len - index) << 1\n        );\n        return out;\n      }\n    }\n    return this;\n  }\n\n  replaceAll(search: String, replacement: String): String {\n    let thisLen: usize = this.length;\n    let searchLen: usize = search.length;\n    if (thisLen <= searchLen) {\n      return thisLen < searchLen\n        ? this\n        : select<String>(replacement, this, search == this);\n    }\n    let replaceLen: usize = replacement.length;\n    if (!searchLen) {\n      if (!replaceLen) return this;\n      // Special case: 'abc'.replaceAll('', '-') -> '-a-b-c-'\n      let out = changetype<String>(__new((thisLen + (thisLen + 1) * replaceLen) << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(replacement), replaceLen << 1);\n      let offset = replaceLen;\n      for (let i: usize = 0; i < thisLen; ++i) {\n        store<u16>(\n          changetype<usize>(out) + (offset++ << 1),\n          load<u16>(changetype<usize>(this) + (i << 1))\n        );\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(replacement),\n          replaceLen << 1\n        );\n        offset += replaceLen;\n      }\n      return out;\n    }\n    let prev: isize = 0, next: isize = 0;\n    if (searchLen == replaceLen) {\n      // Fast path when search and replacement have same length\n      let outSize = thisLen << 1;\n      let out = changetype<String>(__new(outSize, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this), outSize);\n      while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n        memory.copy(changetype<usize>(out) + (next << 1), changetype<usize>(replacement), replaceLen << 1);\n        prev = next + searchLen;\n      }\n      return out;\n    }\n    let out: String | null = null, offset: usize = 0, outSize = thisLen;\n    while (~(next = <isize>this.indexOf(search, <i32>prev))) {\n      if (!out) out = changetype<String>(__new(thisLen << 1, idof<String>()));\n      let chunk = next - prev;\n      if (offset + chunk + replaceLen > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(this) + (prev << 1),\n        chunk << 1\n      );\n      offset += chunk;\n      memory.copy(\n        changetype<usize>(out) + (offset << 1),\n        changetype<usize>(replacement),\n        replaceLen << 1\n      );\n      offset += replaceLen;\n      prev = next + searchLen;\n    }\n    if (out) {\n      let rest = thisLen - prev;\n      if (offset + rest > outSize) {\n        outSize <<= 1;\n        out = changetype<String>(__renew(changetype<usize>(out), outSize << 1));\n      }\n      if (rest) {\n        memory.copy(\n          changetype<usize>(out) + (offset << 1),\n          changetype<usize>(this) + (prev << 1),\n          rest << 1\n        );\n      }\n      rest += offset;\n      if (outSize > rest) {\n        out = changetype<String>(__renew(changetype<usize>(out), rest << 1));\n      }\n      return out;\n    }\n    return this;\n  }\n\n  slice(start: i32, end: i32 = i32.MAX_VALUE): String {\n    let len = this.length;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end,   len);\n    len   = end - start;\n    if (len <= 0) return changetype<String>(\"\");\n    let out = changetype<String>(__new(len << 1, idof<String>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n    return out;\n  }\n\n  split(separator: String | null = null, limit: i32 = i32.MAX_VALUE): String[] {\n    if (!limit) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    if (changetype<usize>(separator) == 0) return [ this ];\n    let length: isize = this.length;\n    let sepLen = changetype<string>(separator).length;\n    if (limit < 0) limit = i32.MAX_VALUE;\n    if (!sepLen) {\n      if (!length) return changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n      // split by chars\n      length = min<isize>(length, <isize>limit);\n      let result = changetype<String[]>(__newArray(<i32>length, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      let resultStart = result.dataStart as usize;\n      for (let i: isize = 0; i < length; ++i) {\n        let charStr = changetype<String>(__new(2, idof<String>()));\n        store<u16>(changetype<usize>(charStr), load<u16>(changetype<usize>(this) + (<usize>i << 1)));\n        store<usize>(resultStart + (<usize>i << alignof<usize>()), changetype<usize>(charStr)); // result[i] = charStr\n        __link(changetype<usize>(result), changetype<usize>(charStr), true);\n      }\n      return result;\n    } else if (!length) {\n      let result = changetype<String[]>(__newArray(1, alignof<String>(), idof<Array<String>>()));\n      // @ts-ignore: cast\n      store<usize>(result.dataStart as usize, changetype<usize>(\"\")); // static \"\"\n      return result;\n    }\n    let result = changetype<String[]>(__newArray(0, alignof<String>(), idof<Array<String>>()));\n    let end = 0, start = 0, i = 0;\n    while (~(end = this.indexOf(changetype<string>(separator), start))) {\n      let len = end - start;\n      if (len > 0) {\n        let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n        memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n        result.push(out);\n      } else {\n        result.push(changetype<String>(\"\"));\n      }\n      if (++i == limit) return result;\n      start = end + sepLen;\n    }\n    if (!start) { // also means: loop above didn't do anything\n      result.push(this);\n      return result;\n    }\n    let len = length - start;\n    if (len > 0) {\n      let out = changetype<String>(__new(<usize>len << 1, idof<String>()));\n      memory.copy(changetype<usize>(out), changetype<usize>(this) + (<usize>start << 1), <usize>len << 1);\n      result.push(out);\n    } else {\n      result.push(changetype<String>(\"\")); // static \"\"\n    }\n    return result;\n  }\n\n  toLowerCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 2 * 2, idof<String>()));\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toLower8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // check special casing for lower table. It has one ently so instead lookup we just inline this.\n        if (c == 0x0130) {\n          // 0x0130 -> [0x0069, 0x0307]\n          store<u32>(changetype<usize>(codes) + (j << 1), (0x0307 << 16) | 0x0069);\n          ++j;\n        } else if (c == 0x03A3) { // ''\n          //  maps to  but except at the end of a word where it maps to \n          let sigma = 0x03C3; // \n          if (len > 1 && isFinalSigma(changetype<usize>(this), i, len)) {\n            sigma = 0x03C2; // \n          }\n          store<u16>(changetype<usize>(codes) + (j << 1), sigma);\n        } else if (c - 0x24B6 <= 0x24CF - 0x24B6) {\n          // Range 0x24B6 <= c <= 0x24CF not covered by casemap and require special early handling\n          store<u16>(changetype<usize>(codes) + (j << 1), c + 26);\n        } else {\n          let code = casemap(c, 0) & 0x1FFFFF;\n          if (code < 0x10000) {\n            store<u16>(changetype<usize>(codes) + (j << 1), code);\n          } else {\n            // store as surrogare pair\n            code -= 0x10000;\n            let lo = (code >>> 10) | 0xD800;\n            let hi = (code & 0x03FF) | 0xDC00;\n            store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n            ++j;\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toUpperCase(): String {\n    let len = <usize>this.length;\n    if (!len) return this;\n    let codes = changetype<String>(__new(len * 3 * 2, idof<String>()));\n    let specialsPtr = changetype<usize>(SPECIALS_UPPER);\n    let specialsLen = SPECIALS_UPPER.length;\n    let j: usize = 0;\n    for (let i: usize = 0; i < len; ++i, ++j) {\n      let c = <u32>load<u16>(changetype<usize>(this) + (i << 1));\n      if (isAscii(c)) {\n        store<u16>(changetype<usize>(codes) + (j << 1), toUpper8(c));\n      } else {\n        // check and read surrogate pair\n        if ((c - 0xD7FF < 0xDC00 - 0xD7FF) && i < len - 1) {\n          let c1 = <u32>load<u16>(changetype<usize>(this) + (i << 1), 2);\n          if (c1 - 0xDBFF < 0xE000 - 0xDBFF) {\n            let c0 = c;\n            c = (((c & 0x03FF) << 10) | (c1 & 0x03FF)) + 0x10000;\n            ++i;\n            if (c >= 0x20000) {\n              store<u32>(changetype<usize>(codes) + (j << 1), c0 | (c1 << 16));\n              ++j;\n              continue;\n            }\n          }\n        }\n        // Range 0x24D0 <= c <= 0x24E9 not covered by casemap and require special early handling\n        if (c - 0x24D0 <= 0x24E9 - 0x24D0) {\n          // monkey patch\n          store<u16>(changetype<usize>(codes) + (j << 1), c - 26);\n        } else {\n          let index: usize = -1;\n          // Fast range check. See first and last rows in specialsUpper table\n          if (c - 0x00DF <= 0xFB17 - 0x00DF) {\n            index = <usize>bsearch(c, specialsPtr, specialsLen);\n          }\n          if (~index) {\n            // load next 3 code points from row with `index` offset for specialsUpper table\n            let ab = load<u32>(specialsPtr + (index << 1), 2);\n            let cc = load<u16>(specialsPtr + (index << 1), 6);\n            store<u32>(changetype<usize>(codes) + (j << 1), ab, 0);\n            store<u16>(changetype<usize>(codes) + (j << 1), cc, 4);\n            j += 1 + usize(cc != 0);\n          } else {\n            let code = casemap(c, 1) & 0x1FFFFF;\n            if (code < 0x10000) {\n              store<u16>(changetype<usize>(codes) + (j << 1), code);\n            } else {\n              // store as surrogare pair\n              code -= 0x10000;\n              let lo = (code >>> 10) | 0xD800;\n              let hi = (code & 0x03FF) | 0xDC00;\n              store<u32>(changetype<usize>(codes) + (j << 1), lo | (hi << 16));\n              ++j;\n            }\n          }\n        }\n      }\n    }\n    return changetype<String>(__renew(changetype<usize>(codes), j << 1));\n  }\n\n  toString(): String {\n    return this;\n  }\n}\n\n// @ts-ignore: nolib\nexport type string = String;\n\nexport function parseInt(str: string, radix: i32 = 0): f64 {\n  return strtol<f64>(str, radix);\n}\n\nexport function parseFloat(str: string): f64 {\n  return strtod(str);\n}\n\n// Encoding helpers\nexport namespace String {\n\n  export namespace UTF8 {\n\n    export const enum ErrorMode {\n      WTF8,\n      REPLACE,\n      ERROR\n    }\n\n    export function byteLength(str: string, nullTerminated: bool = false): i32 {\n      let strOff = changetype<usize>(str);\n      let strEnd = strOff + <usize>changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n      let bufLen = i32(nullTerminated);\n      while (strOff < strEnd) {\n        let c1 = <u32>load<u16>(strOff);\n        if (c1 < 128) {\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) break;\n          bufLen += 1;\n        } else if (c1 < 2048) {\n          bufLen += 2;\n        } else {\n          if ((c1 & 0xFC00) == 0xD800 && strOff + 2 < strEnd) {\n            if ((<u32>load<u16>(strOff, 2) & 0xFC00) == 0xDC00) {\n              bufLen += 4; strOff += 4;\n              continue;\n            }\n          }\n          bufLen += 3;\n        }\n        strOff += 2;\n      }\n      return bufLen;\n    }\n\n    export function encode(str: string, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str, nullTerminated), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf), nullTerminated, errorMode);\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize, nullTerminated: bool = false, errorMode: ErrorMode = ErrorMode.WTF8): usize {\n      let strEnd = str + (<usize>len << 1);\n      let bufOff = buf;\n      while (str < strEnd) {\n        let c1 = <u32>load<u16>(str);\n        if (c1 < 128) {\n          store<u8>(bufOff, c1);\n          bufOff++;\n          // @ts-ignore: cast\n          if (nullTerminated & !c1) return bufOff - buf;\n        } else if (c1 < 2048) {\n          let b0 = c1 >> 6 | 192;\n          let b1 = c1 & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          bufOff += 2;\n        } else {\n          // D800: 11011 0 0000000000 Lead\n          // DBFF: 11011 0 1111111111\n          // DC00: 11011 1 0000000000 Trail\n          // DFFF: 11011 1 1111111111\n          // F800: 11111 0 0000000000 Mask\n          // FC00: 11111 1 0000000000\n          if ((c1 & 0xF800) == 0xD800) {\n            if (c1 < 0xDC00 && str + 2 < strEnd) {\n              let c2 = <u32>load<u16>(str, 2);\n              if ((c2 & 0xFC00) == 0xDC00) {\n                c1 = 0x10000 + ((c1 & 0x03FF) << 10) | (c2 & 0x03FF);\n                let b0 = c1 >> 18 | 240;\n                let b1 = c1 >> 12 & 63 | 128;\n                let b2 = c1 >> 6  & 63 | 128;\n                let b3 = c1       & 63 | 128;\n                store<u32>(bufOff, b3 << 24 | b2 << 16 | b1 << 8 | b0);\n                bufOff += 4; str += 4;\n                continue;\n              }\n            }\n            if (errorMode != ErrorMode.WTF8) { // unlikely\n              if (errorMode == ErrorMode.ERROR) throw new Error(E_UNPAIRED_SURROGATE);\n              c1 = 0xFFFD;\n            }\n          }\n          let b0 = c1 >> 12 | 224;\n          let b1 = c1 >> 6  & 63 | 128;\n          let b2 = c1       & 63 | 128;\n          store<u16>(bufOff, b1 << 8 | b0);\n          store<u8>(bufOff, b2, 2);\n          bufOff += 3;\n        }\n        str += 2;\n      }\n      if (nullTerminated) {\n        store<u8>(bufOff++, 0);\n      }\n      return bufOff - buf;\n    }\n\n    export function decode(buf: ArrayBuffer, nullTerminated: bool = false): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength, nullTerminated);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize, nullTerminated: bool = false): String {\n      let bufOff = buf;\n      let bufEnd = buf + len;\n      assert(bufEnd >= bufOff); // guard wraparound\n      let str = changetype<String>(__new(len << 1, idof<String>())); // max is one u16 char per u8 byte\n      let strOff = changetype<usize>(str);\n      while (bufOff < bufEnd) {\n        let u0 = <u32>load<u8>(bufOff); ++bufOff;\n        if (!(u0 & 128)) {\n          // @ts-ignore: cast\n          if (nullTerminated & !u0) break;\n          store<u16>(strOff, u0);\n        } else {\n          if (bufEnd == bufOff) break;\n          let u1 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n          if ((u0 & 224) == 192) {\n            store<u16>(strOff, (u0 & 31) << 6 | u1);\n          } else {\n            if (bufEnd == bufOff) break;\n            let u2 = <u32>load<u8>(bufOff) & 63; ++bufOff;\n            if ((u0 & 240) == 224) {\n              u0 = (u0 & 15) << 12 | u1 << 6 | u2;\n            } else {\n              if (bufEnd == bufOff) break;\n              u0 = (u0 & 7) << 18 | u1 << 12 | u2 << 6 | <u32>load<u8>(bufOff) & 63;\n              ++bufOff;\n            }\n            if (u0 < 0x10000) {\n              store<u16>(strOff, u0);\n            } else {\n              u0 -= 0x10000;\n              let lo = u0 >> 10 | 0xD800;\n              let hi = (u0 & 0x03FF) | 0xDC00;\n              store<u32>(strOff, lo | (hi << 16));\n              strOff += 2;\n            }\n          }\n        }\n        strOff += 2;\n      }\n      return changetype<String>(__renew(changetype<usize>(str), strOff - changetype<usize>(str)));\n    }\n  }\n\n  export namespace UTF16 {\n\n    export function byteLength(str: string): i32 {\n      return changetype<OBJECT>(changetype<usize>(str) - TOTAL_OVERHEAD).rtSize;\n    }\n\n    export function encode(str: string): ArrayBuffer {\n      let buf = changetype<ArrayBuffer>(__new(<usize>byteLength(str), idof<ArrayBuffer>()));\n      encodeUnsafe(changetype<usize>(str), str.length, changetype<usize>(buf));\n      return buf;\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function encodeUnsafe(str: usize, len: i32, buf: usize): usize {\n      let size = <usize>len << 1;\n      memory.copy(buf, changetype<usize>(str), size);\n      return size;\n    }\n\n    export function decode(buf: ArrayBuffer): String {\n      return decodeUnsafe(changetype<usize>(buf), buf.byteLength);\n    }\n\n    // @ts-ignore: decorator\n    @unsafe\n    export function decodeUnsafe(buf: usize, len: usize): String {\n      let str = changetype<String>(__new(len &= ~1, idof<String>()));\n      memory.copy(changetype<usize>(str), buf, len);\n      return str;\n    }\n  }\n}\n\nexport class TemplateStringsArray extends Array<string> {\n  readonly raw: string[];\n}\n","/**\n * This module contains functions for interacting with the key-value datastore, which is used for persistent storage of\n * data on the blockchain.\n *\n * The supported value types for the datastore include `string`, `Args` and `StaticArray<u8>`.\n *\n * This module also provides functions for setting the executable bytecode of a smart contract address.\n *\n * @remarks\n * The datastore is used to store data that is expected to persist between contract executions, such as contract\n * state or user information.\n *\n * The {@link set}, {@link get}, {@link has}, and {@link del} functions are used to manipulate the data in the\n * datastore of the current address, while the {@link setOf}, {@link getOf}, {@link hasOf}, and {@link deleteOf}\n * functions are used to manipulate the data in the datastore of a different address.\n *\n * The {@link setOf}, {@link deleteOf} and {@link appendOf} functions can only be called at smart contract generation\n * time by the parent smart contract to write to or delete data from the child's datastore. These functions allow the\n * parent smart contract to manipulate the child smart contract's datastore during the smart contract execution time\n * where {@link createSC} is called, but not after.\n *\n * It is not possible in AssemblyScript to catch thrown exceptions.\n * All exceptions thrown by functions in this module will stop the execution of the smart contract.\n *\n * You can see that your smart contract execution is stopped by looking at the events.\n *\n * @privateRemarks\n * AssemblyScript does not currently support union types, so we must manually check the compatibility of generic types\n * in some of the functions.\n *\n * The `ERROR` function is used to stop the compilation and inform the developer that one of the passed generic types is\n * not compatible with the expected type. Unfortunately, the `ERROR` function does not offer a way to pass the actual\n * generic type or the compilation context, except for the line where the error function was called. Therefore, it is\n * recommended to use the `ERROR` function as early as possible in the call process, and to avoid using sub-functions\n * called in the process in order to preserve the error context.\n *\n * @module\n */\n\nimport { env } from '../env';\nimport { Address } from './address';\nimport { Args, bytesToString, stringToBytes } from '@massalabs/as-types';\nimport { derKeys } from './op-datastore';\n\n/**\n * Converts the given value to a StaticArray<u8> to match the expected format for datastore operations.\n *\n * @remarks\n * This function supports converting values of type `string`, `StaticArray<u8>`, or  `Args` to\n * the appropriate format for datastore operations. If the given value is not one of these supported types,\n * an error will be thrown and the compilation will stop.\n *\n * @typeParam T - the type of the value to convert, which must be one of `string`, `StaticArray<u8>`, or `Args`\n *\n * @param value - the value to convert to the appropriate format for datastore operations\n *\n * @returns a StaticArray<u8> that represents the given value in the appropriate format for datastore operations\n *\n * @throws\n * - [compilation only] if the given value is not one of the supported types\n */\nfunction toDatastoreFormat<T>(value: T): StaticArray<u8> {\n  if (idof<T>() == idof<StaticArray<u8>>()) {\n    return changetype<StaticArray<u8>>(value);\n  }\n\n  if (isString<T>()) {\n    return stringToBytes(changetype<string>(value));\n  }\n\n  if (idof<T>() == idof<Args>()) {\n    return changetype<Args>(value).serialize();\n  }\n\n  // If the value is not one of the supported types, throw an error and stop the compilation\n  ERROR('Generic type must be one of string, StaticArray<u8>, or Args.');\n\n  // This return statement is not strictly necessary, but it is included to avoid a misleading error message\n  // in cases where the compilation would otherwise fail due to the lack of a return value for a non-void function\n  return new StaticArray<u8>(0);\n}\n\n/**\n * Converts the given datastore retrieved value to the desired format.\n *\n * @remarks\n * This function supports converting values of type `StaticArray<u8>` to either `string`, `Args`, or\n * `StaticArray<u8>`.\n * - If the desired output type is not one of these supported types, an error will be\n * thrown and the compilation will stop.\n *\n * @typeParam T - the desired output type, which must be one of `string`, `Args`, or `StaticArray<u8>`\n *\n * @param value - the datastore retrieved value to be converted, of type `StaticArray<u8>`\n *\n * @returns the converted value in the desired format, of type `T`\n *\n * @throws\n * - [compilation only] if the desired output type is not one of the supported types\n */\nfunction fromDatastoreFormat<T>(value: StaticArray<u8>): T {\n  if (idof<T>() == idof<StaticArray<u8>>()) {\n    return changetype<T>(value);\n  }\n\n  if (isString<T>()) {\n    return changetype<T>(bytesToString(value));\n  }\n\n  if (idof<T>() == idof<Args>()) {\n    return changetype<T>(new Args(value));\n  }\n\n  // If the desired output type is not one of the supported types, throw an error and stop the compilation\n  ERROR('Generic type must be one of string, StaticArray<u8>, or Args.');\n\n  // This return statement is not strictly necessary, but it is included to avoid a misleading error message\n  // in cases where the compilation would otherwise fail due to the lack of a return value for a non-void function\n  return changetype<T>(0);\n}\n\n/**\n * Sets a key-value pair in the current contract's datastore. Existing entries are overwritten and missing\n * ones are created.\n *\n * @typeParam T - Can be either `string`, `StaticArray<u8>`, or `Args`.\n *\n * @param key - The key to set in the datastore.\n * @param value - The value to associate with the key in the datastore.\n *\n * @throws\n * - [compilation only] if the `key` and `value` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function set<T>(key: T, value: T): void {\n  env.set(toDatastoreFormat<T>(key), toDatastoreFormat<T>(value));\n}\n\n/**\n * Sets a key-value pair in the datastore of the given address. Existing entries are overwritten and missing\n * ones are created.\n *\n * @remarks Can only be called at smart contract generation time by the parent smart contract to the child's address.\n *\n * @typeParam T - Can be either string, Args, or StaticArray<u8>.\n *\n * @param address - The child smart contract `address`.\n * @param key - The key to set in the datastore.\n * @param value - The value to associate with the key in the datastore.\n *\n * @throws\n * - if the given address is not a valid address.\n * - [compilation only] if the `key` and `value` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function setOf<T>(address: Address, key: T, value: T): void {\n  env.setOf(\n    address.toString(),\n    toDatastoreFormat(key),\n    toDatastoreFormat(value),\n  );\n}\n\n/**\n * Returns the value associated with the given `key` in the current contract's datastore.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param key - The key whose associated value is to be retrieved from the datastore.\n *\n * @returns The value associated with the given `key` in the datastore.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function get<T>(key: T): T {\n  const value: StaticArray<u8> = env.get(toDatastoreFormat(key));\n\n  return fromDatastoreFormat<T>(value);\n}\n\n/**\n * Returns the value associated with the given `key` in the datastore of the contract at the specified `address`.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param address - The targeted smart contract `address`.\n * @param key - The key whose associated value is to be retrieved from the datastore.\n *\n * @returns The value associated with the given `key` in the datastore of the specified contract.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - if the datastore at the given `address` does not exist.\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n *\n */\nexport function getOf<T>(address: Address, key: T): T {\n  const value: StaticArray<u8> = env.getOf(\n    address.toString(),\n    toDatastoreFormat(key),\n  );\n\n  return fromDatastoreFormat<T>(value);\n}\n\n/**\n * Removes the key-value pair associated with the given `key` from the current contract's datastore.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param key - The `key` to delete from the datastore.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n *\n */\nexport function del<T>(key: T): void {\n  env.del(toDatastoreFormat(key));\n}\n\n/**\n * Removes the key-value pair associated with the given `key` from the datastore of the specified `address`.\n *\n * @remarks Can only be called at smart contract generation time by the parent smart contract to the child's address.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param address - The child smart contract `address`.\n * @param key - The `key` to delete from the datastore.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - if the contract at the given `address` does not exist\n * - if the caller is not authorized to modify the datastore.\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function deleteOf<T>(address: Address, key: T): void {\n  env.deleteOf(address.toString(), toDatastoreFormat(key));\n}\n\n/**\n * Appends the given `value` to the existing value associated with the given `key` of the current contract.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param key - The key whose data the `value` will be appended to.\n * @param value - The data that will be appended to the existing data associated with the `key`.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - [compilation only] if the `key` and `value` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function append<T>(key: T, value: T): void {\n  env.append(toDatastoreFormat(key), toDatastoreFormat(value));\n}\n\n/**\n * Appends the given `value` to the existing value associated with the given `key` of the specified `address`.\n *\n * @remarks Can only be called at smart contract generation time by the parent smart contract to the child's address.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param address - The child smart contract `address`.\n * @param key - The key whose data the `value` will be appended to.\n * @param value - The data that will be appended to the existing data associated with the `key`.\n *\n * @throws\n * - if the `key` does not exist in the datastore.\n * - if the contract at the given `address` does not exist\n * - if the caller is not authorized to modify the datastore.\n * - [compilation only] if the `key` and `value` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function appendOf<T>(address: Address, key: T, value: T): void {\n  env.appendOf(\n    address.toString(),\n    toDatastoreFormat(key),\n    toDatastoreFormat(value),\n  );\n}\n\n/**\n * Checks if the key-value pair exists in the datastore of the current contract.\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param key - The key to check for existence in the datastore.\n *\n * @returns A boolean value indicating whether the key-value pair exists in the datastore or not.\n *\n * @throws\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function has<T>(key: T): bool {\n  return env.has(toDatastoreFormat(key));\n}\n\n/**\n * Checks if the key-value pair exists in the datastore of the target address.\n *\n *\n * @typeParam T - Can be either `string`, `Args`, or `StaticArray<u8>`.\n *\n * @param address - The child smart contract `address`.\n * @param key - The key to check for existence in the datastore.\n *\n * @returns A boolean value indicating whether the key-value pair exists in the datastore or not.\n *\n * @throws\n * - if the contract at the given `address` does not exist\n * - [compilation only] if the `key` type are neither `string`, `StaticArray<u8>`, or `Args`.\n */\nexport function hasOf<T>(address: Address, key: T): bool {\n  return env.hasOf(address.toString(), toDatastoreFormat(key));\n}\n\n/**\n * Retrieves all the keys from the datastore.\n *\n * @param prefix - the serialized prefix to filter the keys (optional)\n *\n * @returns - a list of keys (e.g. a list of byte array)\n *\n */\nexport function getKeys(\n  prefix: StaticArray<u8> = new StaticArray<u8>(0),\n): Array<StaticArray<u8>> {\n  let keysSer = env.getKeys(prefix);\n  return derKeys(keysSer);\n}\n\n/**\n * Retrieves all the keys from the datastore from a remote address.\n *\n * @param address - the address in the datastore\n * @param prefix - the prefix to filter the keys (optional)\n *\n * @returns - a list of key (e.g. a list of byte array)\n *\n */\nexport function getKeysOf(\n  address: string,\n  prefix: StaticArray<u8> = new StaticArray<u8>(0),\n): Array<StaticArray<u8>> {\n  let keysSer = env.getKeysOf(address, prefix);\n  return derKeys(keysSer);\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { OBJECT, BLOCK_MAXSIZE, TOTAL_OVERHEAD } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { idof } from \"./builtins\";\nimport { E_INVALIDLENGTH } from \"./util/error\";\n\nexport abstract class ArrayBufferView {\n\n  readonly buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  readonly byteLength: i32;\n\n  get byteOffset(): i32 {\n    return <i32>(this.dataStart - changetype<usize>(this.buffer));\n  }\n\n  protected constructor(length: i32, alignLog2: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(length = length << alignLog2, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = length;\n  }\n}\n\n@final export class ArrayBuffer {\n\n  static isView<T>(value: T): bool {\n    if (isNullable<T>()) {\n      if (changetype<usize>(value) == 0) return false;\n    }\n    if (value instanceof Int8Array) return true;\n    if (value instanceof Uint8Array) return true;\n    if (value instanceof Uint8ClampedArray) return true;\n    if (value instanceof Int16Array) return true;\n    if (value instanceof Uint16Array) return true;\n    if (value instanceof Int32Array) return true;\n    if (value instanceof Uint32Array) return true;\n    if (value instanceof Int64Array) return true;\n    if (value instanceof Uint64Array) return true;\n    if (value instanceof Float32Array) return true;\n    if (value instanceof Float64Array) return true;\n    if (value instanceof DataView) return true;\n    return false;\n  }\n\n  constructor(length: i32) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE) throw new RangeError(E_INVALIDLENGTH);\n    let buffer = changetype<ArrayBuffer>(__new(<usize>length, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, <usize>length);\n    }\n    return buffer;\n  }\n\n  get byteLength(): i32 {\n    return changetype<OBJECT>(changetype<usize>(this) - TOTAL_OVERHEAD).rtSize;\n  }\n\n  slice(begin: i32 = 0, end: i32 = BLOCK_MAXSIZE): ArrayBuffer {\n    let length = this.byteLength;\n    begin = begin < 0 ? max(length + begin, 0) : min(begin, length);\n    end   = end   < 0 ? max(length + end  , 0) : min(end  , length);\n    let outSize = <usize>max(end - begin, 0);\n    let out = changetype<ArrayBuffer>(__new(outSize, idof<ArrayBuffer>()));\n    memory.copy(changetype<usize>(out), changetype<usize>(this) + <usize>begin, outSize);\n    return out;\n  }\n\n  toString(): string {\n    return \"[object ArrayBuffer]\";\n  }\n}\n","/**\r\n * Fighter Game Smart Contract - Main Entry Point\r\n * PvP Fighting Game on Massa Blockchain\r\n *\r\n * This contract implements a turn-based combat game with:\r\n * - Character classes and progression\r\n * - Equipment NFT system\r\n * - Skill-based combat with energy management\r\n * - Status effects and combo system\r\n * - Tournament system\r\n * - MMR-based matchmaking and leaderboards\r\n * - Achievement tracking\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport { Args, Serializable } from '@massalabs/as-types';\r\n\r\n// Import types\r\nimport {\r\n  Character,\r\n  Equipment,\r\n  Battle,\r\n  Tournament,\r\n  LeaderboardEntry,\r\n  AchievementTracker,\r\n} from './types';\r\n\r\n// Import storage\r\nimport {\r\n  setAdmin,\r\n  getAdmin,\r\n  isAdmin,\r\n  setPaused,\r\n  isPaused,\r\n  setReentrancyLock,\r\n  isReentrancyLocked,\r\n  loadCharacter,\r\n  loadEquipment,\r\n  loadBattle,\r\n  loadTournament,\r\n} from './storage';\r\n\r\n// Import components\r\nimport {\r\n  createCharacter as _createCharacter,\r\n  readCharacter,\r\n  healCharacter as _healCharacter,\r\n  upgradeCharacter as _upgradeCharacter,\r\n  grantXP as _grantXP,\r\n} from './character';\r\n\r\nimport {\r\n  createEquipment as _createEquipment,\r\n  adminMintEquipment as _adminMintEquipment,\r\n  readEquipment,\r\n  transferEquipment as _transferEquipment,\r\n  equipItem as _equipItem,\r\n  unequipItem as _unequipItem,\r\n  repairEquipment as _repairEquipment,\r\n} from './equipment';\r\n\r\nimport {\r\n  learnSkill as _learnSkill,\r\n  equipSkill as _equipSkill,\r\n} from './skills';\r\n\r\nimport {\r\n  createBattle as _createBattle,\r\n  executeTurn as _executeTurn,\r\n  decideWildcard as _decideWildcard,\r\n  finalizeBattle as _finalizeBattle,\r\n  timeoutWildcard as _timeoutWildcard,\r\n  getBattle,\r\n  isBattleActive,\r\n} from './battle';\r\n\r\nimport {\r\n  createTournament as _createTournament,\r\n  registerForTournament as _registerForTournament,\r\n  recordTournamentMatch as _recordTournamentMatch,\r\n  advanceTournamentRound as _advanceTournamentRound,\r\n  forceFinalizeTournament as _forceFinalizeTournament,\r\n} from './tournament';\r\n\r\nimport {\r\n  updateBattleMMR,\r\n  getLeaderboard as _getLeaderboard,\r\n  getCharacterRank,\r\n  getWinRate,\r\n  getMMRTier,\r\n} from './leaderboard';\r\n\r\nimport {\r\n  getPlayerAchievements,\r\n  checkAllAchievements as _checkAllAchievements,\r\n  getUnlockedAchievementsString,\r\n  getCompletionPercentage,\r\n} from './achievements';\r\n\r\nimport {\r\n  collectBattleFee,\r\n  collectCharacterCreationFee,\r\n  collectSkillLearningFee,\r\n  collectUpgradeFee,\r\n  collectRepairFee,\r\n  getTreasuryBalance,\r\n  getContractBalance,\r\n  withdrawFromTreasury as _withdrawFromTreasury,\r\n  emergencyWithdraw as _emergencyWithdraw,\r\n  getFeeInfo,\r\n  BATTLE_FEE,\r\n  CHARACTER_CREATION_FEE,\r\n} from './treasury';\r\n\r\n// ============================================================================\r\n// Modifiers (Security)\r\n// ============================================================================\r\n\r\nfunction requireNotPaused(): void {\r\n  assert(!isPaused(), 'Contract is paused');\r\n}\r\n\r\nfunction requireAdmin(): void {\r\n  assert(isAdmin(Context.caller().toString()), 'Admin only');\r\n}\r\n\r\nfunction requireNoReentrancy(): void {\r\n  assert(!isReentrancyLocked(), 'Reentrancy detected');\r\n  setReentrancyLock(true);\r\n}\r\n\r\nfunction releaseReentrancy(): void {\r\n  setReentrancyLock(false);\r\n}\r\n\r\n// ============================================================================\r\n// Contract Initialization\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize the contract (called on deployment)\r\n * @param binaryArgs - Serialized Args containing admin address\r\n */\r\nexport function constructor(binaryArgs: StaticArray<u8>): void {\r\n  // Only allow initialization once\r\n  assert(getAdmin() == '', 'Already initialized');\r\n\r\n  const args = new Args(binaryArgs);\r\n  const adminAddress = args.nextString().expect('Admin address required');\r\n\r\n  setAdmin(adminAddress);\r\n  setPaused(false);\r\n\r\n  generateEvent(`CONTRACT_INITIALIZED:${adminAddress}`);\r\n}\r\n\r\n// ============================================================================\r\n// Admin Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Pause the contract\r\n */\r\nexport function game_pause(_: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  setPaused(true);\r\n  generateEvent('CONTRACT_PAUSED');\r\n}\r\n\r\n/**\r\n * Unpause the contract\r\n */\r\nexport function game_unpause(_: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  setPaused(false);\r\n  generateEvent('CONTRACT_UNPAUSED');\r\n}\r\n\r\n/**\r\n * Transfer admin role\r\n */\r\nexport function game_transferAdmin(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const newAdmin = args.nextString().expect('New admin address required');\r\n  setAdmin(newAdmin);\r\n  generateEvent(`ADMIN_TRANSFERRED:${newAdmin}`);\r\n}\r\n\r\n// ============================================================================\r\n// Character Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new character\r\n * @param binaryArgs - Serialized: id (string), classId (u8), name (string)\r\n */\r\nexport function game_createCharacter(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  // Collect creation fee\r\n  collectCharacterCreationFee();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const id = args.nextString().expect('Character ID required');\r\n  const classId = args.nextU8().expect('Class ID required');\r\n  const name = args.nextString().expect('Name required');\r\n\r\n  const character = _createCharacter(id, classId, name);\r\n\r\n  releaseReentrancy();\r\n  return character.serialize();\r\n}\r\n\r\n/**\r\n * Read character data\r\n * @param binaryArgs - Serialized: id (string)\r\n */\r\nexport function game_readCharacter(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const id = args.nextString().expect('Character ID required');\r\n  return readCharacter(id).serialize();\r\n}\r\n\r\n/**\r\n * Heal character to full HP\r\n * @param binaryArgs - Serialized: charId (string)\r\n */\r\nexport function game_healCharacter(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const charId = args.nextString().expect('Character ID required');\r\n  _healCharacter(charId);\r\n}\r\n\r\n/**\r\n * Upgrade character stat\r\n * @param binaryArgs - Serialized: charId (string), upgradeType (u8)\r\n */\r\nexport function game_upgradeCharacter(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  collectUpgradeFee();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const charId = args.nextString().expect('Character ID required');\r\n  const upgradeType = args.nextU8().expect('Upgrade type required');\r\n\r\n  _upgradeCharacter(charId, upgradeType);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Admin grant XP to character\r\n */\r\nexport function game_grantXP(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const charId = args.nextString().expect('Character ID required');\r\n  const amount = args.nextU64().expect('Amount required');\r\n  _grantXP(charId, amount);\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Admin mint equipment\r\n */\r\nexport function game_createEquipment(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const equipmentId = args.nextString().expect('Equipment ID required');\r\n  const owner = args.nextString().expect('Owner address required');\r\n  const equipType = args.nextU8().expect('Equipment type required');\r\n  const rarity = args.nextU8().expect('Rarity required');\r\n\r\n  const equipment = _adminMintEquipment(equipmentId, owner, equipType, rarity);\r\n  return equipment.serialize();\r\n}\r\n\r\n/**\r\n * Read equipment data\r\n */\r\nexport function game_readEquipment(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const id = args.nextString().expect('Equipment ID required');\r\n  return readEquipment(id).serialize();\r\n}\r\n\r\n/**\r\n * Transfer equipment to another address\r\n */\r\nexport function game_transferEquipment(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const equipmentId = args.nextString().expect('Equipment ID required');\r\n  const toAddr = args.nextString().expect('Destination address required');\r\n  _transferEquipment(equipmentId, toAddr);\r\n}\r\n\r\n/**\r\n * Equip item to character\r\n */\r\nexport function game_equipItem(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const charId = args.nextString().expect('Character ID required');\r\n  const equipmentId = args.nextString().expect('Equipment ID required');\r\n  _equipItem(charId, equipmentId);\r\n}\r\n\r\n/**\r\n * Unequip item from character\r\n */\r\nexport function game_unequipItem(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const charId = args.nextString().expect('Character ID required');\r\n  const equipmentId = args.nextString().expect('Equipment ID required');\r\n  _unequipItem(charId, equipmentId);\r\n}\r\n\r\n/**\r\n * Repair equipment\r\n */\r\nexport function game_repairEquipment(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const equipmentId = args.nextString().expect('Equipment ID required');\r\n\r\n  // Get equipment to determine rarity\r\n  const equipment = readEquipment(equipmentId);\r\n  collectRepairFee(equipment.rarity);\r\n\r\n  _repairEquipment(equipmentId);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n// ============================================================================\r\n// Skill Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Learn a skill\r\n */\r\nexport function game_learnSkill(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  collectSkillLearningFee();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const characterId = args.nextString().expect('Character ID required');\r\n  const skillId = args.nextU8().expect('Skill ID required');\r\n\r\n  _learnSkill(characterId, skillId);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Equip a skill to slot\r\n */\r\nexport function game_equipSkill(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const characterId = args.nextString().expect('Character ID required');\r\n  const skillId = args.nextU8().expect('Skill ID required');\r\n  const slot = args.nextU8().expect('Slot required');\r\n  _equipSkill(characterId, skillId, slot);\r\n}\r\n\r\n// ============================================================================\r\n// Battle Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new battle\r\n */\r\nexport function game_createBattle(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  collectBattleFee();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  const char1Id = args.nextString().expect('Character 1 ID required');\r\n  const char2Id = args.nextString().expect('Character 2 ID required');\r\n  const startTs = Context.timestamp();\r\n\r\n  const battle = _createBattle(battleId, char1Id, char2Id, startTs);\r\n\r\n  releaseReentrancy();\r\n  return battle.serialize();\r\n}\r\n\r\n/**\r\n * Execute a turn in battle\r\n */\r\nexport function game_executeTurn(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  const attackerCharId = args.nextString().expect('Attacker ID required');\r\n  const stance = args.nextU8().expect('Stance required');\r\n  const useSpecial = args.nextBool().expect('Use special required');\r\n  const skillSlot = args.nextU8().expect('Skill slot required');\r\n\r\n  _executeTurn(battleId, attackerCharId, stance, useSpecial, skillSlot);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Submit wildcard decision\r\n */\r\nexport function game_decideWildcard(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  const accept = args.nextBool().expect('Decision required');\r\n  const playerCharId = args.nextString().expect('Player character ID required');\r\n  _decideWildcard(battleId, accept, playerCharId);\r\n}\r\n\r\n/**\r\n * Finalize battle (for timeout)\r\n */\r\nexport function game_finalizeBattle(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  _finalizeBattle(battleId);\r\n}\r\n\r\n/**\r\n * Timeout wildcard decision\r\n */\r\nexport function game_timeoutWildcard(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  _timeoutWildcard(battleId);\r\n}\r\n\r\n/**\r\n * Read battle data\r\n */\r\nexport function game_readBattle(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const id = args.nextString().expect('Battle ID required');\r\n  return getBattle(id).serialize();\r\n}\r\n\r\n/**\r\n * Process battle results (updates MMR and achievements)\r\n */\r\nexport function game_processBattleResults(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n  const xpForWinner = args.nextU64().expect('XP amount required');\r\n\r\n  const battle = getBattle(battleId);\r\n  assert(battle.winnerId.length > 0, 'Battle not completed');\r\n\r\n  const loserId = battle.player1.characterId == battle.winnerId\r\n    ? battle.player2.characterId\r\n    : battle.player1.characterId;\r\n\r\n  updateBattleMMR(battle.winnerId, loserId, xpForWinner);\r\n}\r\n\r\n// ============================================================================\r\n// Tournament Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Create tournament (admin)\r\n */\r\nexport function game_createTournament(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const tournamentId = args.nextString().expect('Tournament ID required');\r\n  const name = args.nextString().expect('Name required');\r\n  const entryFee = args.nextU64().expect('Entry fee required');\r\n  const maxParticipants = args.nextU8().expect('Max participants required');\r\n\r\n  const tournament = _createTournament(tournamentId, name, entryFee, maxParticipants);\r\n  return tournament.serialize();\r\n}\r\n\r\n/**\r\n * Register for tournament\r\n */\r\nexport function game_registerForTournament(binaryArgs: StaticArray<u8>): void {\r\n  requireNotPaused();\r\n  requireNoReentrancy();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const tournamentId = args.nextString().expect('Tournament ID required');\r\n  const characterId = args.nextString().expect('Character ID required');\r\n\r\n  _registerForTournament(tournamentId, characterId);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Record tournament match result (admin)\r\n */\r\nexport function game_recordTournamentMatch(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const tournamentId = args.nextString().expect('Tournament ID required');\r\n  const winnerId = args.nextString().expect('Winner ID required');\r\n  const loserId = args.nextString().expect('Loser ID required');\r\n  _recordTournamentMatch(tournamentId, winnerId, loserId);\r\n}\r\n\r\n/**\r\n * Advance tournament round (admin)\r\n */\r\nexport function game_advanceTournamentRound(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  const args = new Args(binaryArgs);\r\n  const tournamentId = args.nextString().expect('Tournament ID required');\r\n  _advanceTournamentRound(tournamentId);\r\n}\r\n\r\n/**\r\n * Read tournament data\r\n */\r\nexport function game_readTournament(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const id = args.nextString().expect('Tournament ID required');\r\n  const tournament = loadTournament(id);\r\n  assert(tournament != null, 'Tournament not found');\r\n  return tournament!.serialize();\r\n}\r\n\r\n// ============================================================================\r\n// Leaderboard Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get leaderboard\r\n */\r\nexport function game_getLeaderboard(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const topN = args.nextU32().expect('Top N required');\r\n\r\n  const entries = _getLeaderboard(topN);\r\n  const result = new Args();\r\n  result.add(u32(entries.length));\r\n  for (let i = 0; i < entries.length; i++) {\r\n    result.add(entries[i]);\r\n  }\r\n  return result.serialize();\r\n}\r\n\r\n/**\r\n * Get character rank\r\n */\r\nexport function game_getCharacterRank(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const characterId = args.nextString().expect('Character ID required');\r\n\r\n  const rank = getCharacterRank(characterId);\r\n  const result = new Args();\r\n  result.add(rank);\r\n  return result.serialize();\r\n}\r\n\r\n/**\r\n * Get character MMR tier\r\n */\r\nexport function game_getMMRTier(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const characterId = args.nextString().expect('Character ID required');\r\n\r\n  const character = loadCharacter(characterId);\r\n  assert(character != null, 'Character not found');\r\n\r\n  const tier = getMMRTier(character!.mmr);\r\n  const result = new Args();\r\n  result.add(tier);\r\n  return result.serialize();\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get player achievements\r\n */\r\nexport function game_getAchievements(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const ownerAddress = args.nextString().expect('Owner address required');\r\n  return getPlayerAchievements(ownerAddress).serialize();\r\n}\r\n\r\n/**\r\n * Check all achievements for player\r\n */\r\nexport function game_checkAllAchievements(binaryArgs: StaticArray<u8>): void {\r\n  const args = new Args(binaryArgs);\r\n  const ownerAddress = args.nextString().expect('Owner address required');\r\n  _checkAllAchievements(ownerAddress);\r\n}\r\n\r\n// ============================================================================\r\n// Treasury Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get treasury balance\r\n */\r\nexport function game_getTreasuryBalance(_: StaticArray<u8>): StaticArray<u8> {\r\n  const result = new Args();\r\n  result.add(getTreasuryBalance());\r\n  return result.serialize();\r\n}\r\n\r\n/**\r\n * Withdraw from treasury (admin)\r\n */\r\nexport function game_withdrawFromTreasury(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  requireNoReentrancy();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const amount = args.nextU64().expect('Amount required');\r\n  const toAddress = args.nextString().expect('Destination address required');\r\n\r\n  _withdrawFromTreasury(amount, toAddress);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Emergency withdraw (admin)\r\n */\r\nexport function game_emergencyWithdraw(binaryArgs: StaticArray<u8>): void {\r\n  requireAdmin();\r\n  requireNoReentrancy();\r\n\r\n  const args = new Args(binaryArgs);\r\n  const toAddress = args.nextString().expect('Destination address required');\r\n\r\n  _emergencyWithdraw(toAddress);\r\n\r\n  releaseReentrancy();\r\n}\r\n\r\n/**\r\n * Get fee information\r\n */\r\nexport function game_getFeeInfo(_: StaticArray<u8>): StaticArray<u8> {\r\n  const result = new Args();\r\n  result.add(getFeeInfo());\r\n  return result.serialize();\r\n}\r\n\r\n// ============================================================================\r\n// Query Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Check if contract is paused\r\n */\r\nexport function game_isPaused(_: StaticArray<u8>): StaticArray<u8> {\r\n  const result = new Args();\r\n  result.add(isPaused());\r\n  return result.serialize();\r\n}\r\n\r\n/**\r\n * Get admin address\r\n */\r\nexport function game_getAdmin(_: StaticArray<u8>): StaticArray<u8> {\r\n  const result = new Args();\r\n  result.add(getAdmin());\r\n  return result.serialize();\r\n}\r\n\r\n/**\r\n * Check if battle is active\r\n */\r\nexport function game_isBattleActive(binaryArgs: StaticArray<u8>): StaticArray<u8> {\r\n  const args = new Args(binaryArgs);\r\n  const battleId = args.nextString().expect('Battle ID required');\r\n\r\n  const result = new Args();\r\n  result.add(isBattleActive(battleId));\r\n  return result.serialize();\r\n}\r\n","/**\n * This module aim's to provide number variable types serialization and conversion helper functions.\n *\n * @remarks\n * This module is part of the {@link serialization} module.\n *\n * Some of the functions are generic templated functions, therefore you must use them with care\n * because they accept only specific type params. Otherwise the compiler will throw an error.\n *\n */\n\n/**\n * Converts a u8 in a StaticArray<u8>.\n *\n * @remarks\n * This function creates a new StaticArray<u8> of size 1, and sets the first element to the passed u8 value.\n *\n * @param val - the number to convert\n *\n * @returns the converted StaticArray<u8>\n */\n// @ts-ignore: decorator\n@inline\nexport function u8toByte(val: u8): StaticArray<u8> {\n  const arr = new StaticArray<u8>(1);\n  arr[0] = val;\n  return arr;\n}\n\n/**\n * Converts a StaticArray<u8> into a u8.\n *\n * @remarks\n * This is done by returning the value at index 0 of the passed StaticArray<u8>.\n *\n * @param arr - the array to convert\n *\n * @returns the converted u8\n */\n// @ts-ignore: decorator\n@inline\nexport function byteToU8(arr: StaticArray<u8>): u8 {\n  return arr[0];\n}\n\n/**\n * Converts an integer number to StaticArray<u8>\n *\n * @remarks\n * Won't compile if the type param is not an integer.\n * @see {@link isInteger}\n *\n * @typeParam T - the type of the number to convert (it must be an integer type, such as i32, u32, i64, or u64)\n *\n * @param val - the number to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function toBytes<T>(val: T): StaticArray<u8> {\n  if (!isInteger<T>()) {\n    ERROR('input must be a integer');\n  }\n  const arr = new StaticArray<u8>(sizeof<T>());\n  store<T>(changetype<usize>(arr), val);\n  return arr;\n}\n\n/**\n * Converts a StaticArray<u8> to number\n *\n * @remarks\n * Won't compile if the type param is not an integer.\n * @see {@link isInteger}\n *\n *  * @typeParam T - the type of the number result (it must be an integer type, such as i32, u32, i64, or u64)\n *\n * @param arr - the array to convert\n *\n * @returns the converted number\n */\nexport function fromBytes<T>(arr: StaticArray<u8>): T {\n  if (!isInteger<T>()) {\n    ERROR('output must be a integer');\n  }\n  return load<T>(changetype<usize>(arr), 0);\n}\n\n/**\n * Converts a u16 in a StaticArray<u8>.\n *\n * @param val - the number to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function u16ToBytes(val: u16): StaticArray<u8> {\n  return toBytes(val);\n}\n\n/**\n * Converts a StaticArray<u8> into a u16.\n *\n * @param arr - the array to convert\n *\n * @returns the converted u16\n */\nexport function bytesToU16(arr: StaticArray<u8>): u16 {\n  return fromBytes<u16>(arr);\n}\n\n/**\n * Converts a u32 in a StaticArray<u8>.\n *\n * @param val - the number to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function u32ToBytes(val: u32): StaticArray<u8> {\n  return toBytes(val);\n}\n\n/**\n * Converts a StaticArray<u8> into a u32.\n *\n * @param arr - the array to convert\n *\n * @returns the converted u32\n */\nexport function bytesToU32(arr: StaticArray<u8>): u32 {\n  return fromBytes<u32>(arr);\n}\n\n/**\n * Converts a f32 in a StaticArray<u8>.\n *\n * @param val - the decimal number to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function f32ToBytes(val: f32): StaticArray<u8> {\n  return u32ToBytes(reinterpret<u32>(val));\n}\n\n/**\n * Converts a StaticArray<u8> into a f32.\n *\n * @param arr - the array to convert\n *\n * @returns the converted f32\n */\nexport function bytesToF32(arr: StaticArray<u8>): f32 {\n  return reinterpret<f32>(bytesToU32(arr));\n}\n\n/**\n * Converts a i16 in a StaticArray<u8>.\n *\n * @param val - the integer to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function i16ToBytes(val: i16): StaticArray<u8> {\n  return u16ToBytes(val as u16);\n}\n\n/**\n * Converts a StaticArray<u8> into a i16.\n *\n * @param arr - the array to convert\n *\n * @returns the converted i16\n */\nexport function bytesToI16(arr: StaticArray<u8>): i16 {\n  return bytesToU16(arr) as i16;\n}\n\n/**\n * Converts a i32 in a StaticArray<u8>.\n *\n * @param val - the integer to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function i32ToBytes(val: i32): StaticArray<u8> {\n  return u32ToBytes(val as u32);\n}\n\n/**\n * Converts a StaticArray<u8> into a i32.\n *\n * @param arr - the array to convert\n *\n * @returns the converted i32\n */\nexport function bytesToI32(arr: StaticArray<u8>): i32 {\n  return changetype<i32>(bytesToU32(arr));\n}\n\n/**\n * Converts a u64 in a StaticArray<u8>.\n *\n * @param val - the integer to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function u64ToBytes(val: u64): StaticArray<u8> {\n  return toBytes(val);\n}\n\n/**\n * Converts a StaticArray<u8> into a u64.\n *\n * @param arr - the array to convert\n *\n * @returns the converted u64\n */\nexport function bytesToU64(arr: StaticArray<u8>): u64 {\n  return fromBytes<u64>(arr);\n}\n\n/**\n * Converts a i64 in a StaticArray<u8>.\n *\n * @param val - the integer to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function i64ToBytes(val: i64): StaticArray<u8> {\n  return u64ToBytes(val as u64);\n}\n\n/**\n * Converts a StaticArray<u8> into a i64.\n *\n * @param arr - the array to convert\n *\n * @returns the converted i64\n */\nexport function bytesToI64(arr: StaticArray<u8>): i64 {\n  return changetype<i64>(bytesToU64(arr));\n}\n\n/**\n * Converts a f64 in a StaticArray<u8>.\n *\n * @param val - the number to convert\n *\n * @returns the converted StaticArray<u8>\n */\nexport function f64ToBytes(val: f64): StaticArray<u8> {\n  return u64ToBytes(reinterpret<u64>(val));\n}\n\n/**\n * Converts a StaticArray<u8> into a f64.\n *\n * @param arr - the array to convert\n *\n * @returns the converted f64\n */\nexport function bytesToF64(arr: StaticArray<u8>): f64 {\n  return reinterpret<f64>(bytesToU64(arr));\n}\n","/**\n * This module contains the 'Result' class, which represents wrapper for a value that can be either\n * a success or an error.\n *\n * The 'Result' class provides methods to {@link unwrap} the value, {@link expect} a value\n * or {@link isOk} or {@link isErr} to check if the result is successful.\n *\n */\n\nexport class Result<T> {\n  /**\n   * Initializes a Result object.\n   *\n   * @param value - expected value for passing case\n   * @param error - error message for non-passing case\n   *\n   */\n  constructor(private value: T, public error: string | null = null) {}\n\n  /**\n   * Determines if the `Result` represents a successful outcome.\n   *\n   * @returns true if the Result is okay, false otherwise.\n   */\n  @inline\n  isOk(): bool {\n    return !this.error;\n  }\n\n  /**\n   * Determines if the `Result` represents a failed outcome.\n   *\n   * @returns true if the Result is not okay, false otherwise.\n   */\n  @inline\n  isErr(): bool {\n    return !this.isOk();\n  }\n\n  /**\n   * Returns the value if the `Result` is successful. Throws an assertion error if not.\n   *\n   * @param msg - The message to be displayed if the `Result` has failed.\n   *\n   * @returns The value if the `Result` is successful.\n   *\n   * @throws If there is an error in the result, it throws an assertion error with the given message.\n   */\n  @inline\n  expect(msg: string): NonNullable<T> {\n    if (this.isErr()) {\n      assert(false, `${msg}: ${this.error!}`);\n    }\n\n    return this.getValue();\n  }\n\n  /**\n   * Get the value of the Result.\n   *\n   * @remarks This method panics if the Result is an error.\n   *\n   * @returns The value of the `Result` if successful.\n   *\n   * @throws If there is an error in the result, it throws an assertion error with the given message.\n   */\n  @inline\n  unwrap(): NonNullable<T> {\n    if (!this.isOk()) {\n      assert(false, this.error!);\n    }\n\n    return this.getValue();\n  }\n\n  /**\n   * Gets the value of the Result or returns the generic type default value.\n   *\n   * @returns The value of the Result if it is successful, otherwise returns the default value of the generic type.\n   */\n  unwrapOrDefault(): NonNullable<T> {\n    return this.getValue();\n  }\n\n  /**\n   * Get the value of the Result\n   *\n   * @remarks This method retrieves the value of the Result and also handles nullable types.\n   *\n   * @returns the value of the Result\n   */\n  @inline\n  private getValue(): NonNullable<T> {\n    if (isNullable<T>()) {\n      return this.value!;\n    } else {\n      // @ts-ignore: not nullable\n      return this.value;\n    }\n  }\n}\n","import { encode } from 'as-base64/assembly';\nimport { env } from '../../env';\nimport { staticArrayToUint8Array } from '@massalabs/as-types';\n\n/**\n * Generates an event that is then emitted by the blockchain.\n *\n * @param event - The string event to emit.\n *\n */\nexport function generateEvent(event: string): void {\n  env.generateEvent(event);\n}\n\n/**\n * Wrap the generateEvent function to emit a raw event.\n *\n * @remarks This function encodes the StaticArray<u8> as a base64 string.\n *\n * Example:\n * ```ts\n * const num: u64 = 8767;\n * const event = new Args().add(num).serialize();\n * generateRawEvent(event);\n * ```\n * @param event - The static array event to emit.\n *\n */\nexport function generateRawEvent(event: StaticArray<u8>): void {\n  generateEvent(encode(staticArrayToUint8Array(event)));\n}\n\n/**\n * Constructs a pretty formatted event with given key and arguments.\n *\n * @remarks\n * The result is meant to be used with the {@link generateEvent} function.\n * It is useful to generate events from an array.\n *\n * @param key - the string event key.\n *\n * @param args - the string array arguments.\n *\n * @returns the stringified event.\n *\n */\nexport function createEvent(key: string, args: Array<string>): string {\n  return `${key}:`.concat(args.join(','));\n}\n","/**\n * This module provides functions for interacting with the execution context of a smart contract on the Massa\n * blockchain.\n *\n * The functions in this module allow you to retrieve information about the current execution context, such as the\n * caller and callee of the current smart contract, the call stack, the amount of transferred coins, the remaining gas,\n * and the timestamp.\n *\n * @remarks\n * The execution context is important for understanding the current state of the smart contract, such as who called\n * the contract, the current contract address, and the transaction creator.\n *\n * Functions such as {@link ownedAddresses}, {@link addressStack}, {@link caller}, {@link callee},\n * {@link transactionCreator}, {@link transferredCoins}, {@link timestamp}, {@link remainingGas},\n * {@link currentThread} and {@link currentPeriod} provide access to important context information\n * during smart contract execution.\n *\n * It is not possible in AssemblyScript to catch thrown exceptions.\n * All exceptions thrown by functions in this module will stop the execution of the smart contract.\n *\n * You can see that your smart contract execution is stopped by looking at the events.\n *\n * @privateRemarks\n * The `json2Address` function is used to parse a JSON-encoded string of addresses and return an array of `Address`\n * objects. This function is used internally by other functions in this module to convert string representations of\n * addresses into a more usable format.\n *\n * @module\n */\n\nimport { env } from '../env/index';\nimport { Address } from './address';\nimport { callerHasWriteAccess, Context, json2Address } from '.';\n\n/**\n * Determines whether the smart contract is currently being deployed.\n *\n * @remarks\n * This method is typically used in the constructor to ensure a one-time deployment\n * and initialization, usually by the creator of the contract. Under the hood, this method\n * verifies that the account calling this function (either the user creating the operation\n * or an upper contract) has write access to the data of the current account\n *\n * @returns true if the contract is currently being deployed, false otherwise.\n */\n@inline\nexport function isDeployingContract(): bool {\n  return callerHasWriteAccess() && Context.callee().notEqual(Context.caller());\n}\n\n/**\n * Returns the addresses that the current execution context has write access to.\n *\n * @remarks\n * Returned addresses include the current address itself, as well as any addresses that\n * were created by the current call to allow initializing them.\n *\n * @returns An array of `Address` objects owned by the current execution context.\n *\n */\nexport function ownedAddresses(): Array<Address> {\n  return json2Address(env.ownedAddresses());\n}\n\n/**\n * Returns the current call stack of smart contract execution.\n *\n * @remarks\n * The first element of this list is the originator (creator of the transaction)\n * and the last is the address of the current smart-contract.\n *\n * When executing the ExecuteSC function, the list is composed of only one entry:\n * the initiator, the caller and the callee having with the same address.\n *\n * Here is a list of the different cases in the Massa stack system:\n *\n * **ExecuteSC**: when an account A sends an ExecuteSC operation, the stack at the\n * beginning of that execution is: bottom [ A ] top.\n *\n * **CallSC**: when an account A sends a CallSC operation to call a function in a smart\n * contract B, the stack at the beginning of the execution of that function is:\n * bottom [ A, B ] top. Note: A and B can be the same.\n *\n * **Call**: from one smart contract to another: when a function F from smart contract C\n * is being executed with the stack [A, B, C] and calls a function on a smart\n * contract D, the stack at the beginning of the execution of Ds function becomes:\n * bottom [A, B, C, D] top. When Ds function finishes, the stack becomes bottom [A, B, C]\n * top and the execution of F resumes.\n *\n * **Autonomous SC**: a message sent at a moment when the stack was [A, B, C] and calling a target\n * function F of a smart contract D, will yield the following stack at the beginning\n * of the execution of the target function: bottom [C, D] top. Note: C and D can be the same.\n *\n * **Local execution**: local executions dont change the stack, they allow executing foreign code\n * in the current context.\n *\n * @returns An array of `Address` objects representing the call stack.\n */\nexport function addressStack(): Array<Address> {\n  return json2Address(env.callStack());\n}\n\n/**\n * Returns the `address` of the `caller` of the currently executing smart contract.\n *\n * @remarks\n * The caller is the person or the smart contract that directly called\n * the pending function.\n *\n * @returns The `address` of the caller of the currently executing smart contract.\n */\nexport function caller(): Address {\n  const a = addressStack();\n  return a.length < 2 ? callee() : a[a.length - 2];\n}\n\n/**\n * Returns the address of the currently executing smart contract.\n *\n * @remarks\n * The \"callee\" refers to the contract that is currently being executed.\n *\n * @returns The `address` of the currently executing smart contract.\n */\nexport function callee(): Address {\n  const a = addressStack();\n  return a[a.length - 1];\n}\n\n/**\n * Returns the address of the initial transaction creator (originator).\n *\n * @returns The `address` of the initial transaction creator.\n */\nexport function transactionCreator(): Address {\n  return addressStack()[0];\n}\n\n/**\n * Returns the amount transferred in the current call.\n *\n * @remarks\n * The returned value is related to the `coins` argument sent along the call.\n * It is not related to the transferCoins or transferCoinsOf functions.\n *\n * @returns The value in the smallest unit.\n */\nexport function transferredCoins(): u64 {\n  return env.callCoins();\n}\n\n/**\n * Returns the slot Unix timestamp in milliseconds.\n *\n * @returns The slot Unix timestamp in milliseconds.\n *\n */\nexport function timestamp(): u64 {\n  return env.time();\n}\n\n/**\n * Returns the remaining gas for the current smart contract execution.\n *\n * @remarks\n * Gas is a measure of the computational resources required to execute a transaction on the blockchain.\n * When there is no more gas, the execution of the smart contract is interrupted and all the transactions are reversed.\n *\n * @returns The amount of remaining gas for the current transaction.\n *\n */\nexport function remainingGas(): u64 {\n  return env.remainingGas();\n}\n\n/**\n * Retrieves the current period of the network.\n *\n * @returns the current period.\n *\n */\nexport function currentPeriod(): u64 {\n  return env.currentPeriod();\n}\n\n/**\n * Retrieves the current thread of the execution context.\n *\n * @returns the current thread.\n *\n */\nexport function currentThread(): u8 {\n  return env.currentThread();\n}\n\n/**\n * Retrieve the current chain id\n *\n * @returns the current chain id.\n */\nexport function chainId(): u64 {\n  return env.chainId();\n}\n\nexport class Slot {\n  public period: u64;\n  public thread: u8;\n  public constructor(period: u64, thread: u8) {\n    this.period = period;\n    this.thread = thread;\n  }\n}\n","import { env } from '../../env';\nimport { Address } from '../address';\nimport { getBytecodeOf } from '../contract';\n\n/**\n * Retrieves an 'Address' object from the given public key.\n *\n * @param pubKey - Base58check encoded public key of the address\n *\n * @returns the fetched address as an 'Address' object.\n *\n * @throws\n * - if the public key is invalid\n *\n */\nexport function publicKeyToAddress(pubKey: string): Address {\n  return new Address(env.publicKeyToAddress(pubKey));\n}\n\n/**\n * Checks if the given address is valid.\n *\n * @param address - the string address to validate.\n *\n * @returns 'true' if the address is valid, 'false' otherwise.\n *\n */\nexport function validateAddress(address: string): bool {\n  return env.validateAddress(address);\n}\n\n/**\n * Checks if the given address is a user or a contract address.\n *\n * @param address - the string address to identify.\n *\n * @returns 'true' if the address is a user address, 'false' otherwise.\n */\nexport function isAddressEoa(address: string): bool {\n  return env.isAddressEoa(address);\n}\n\n/**\n * Returns an array of addresses.\n *\n * Parses a JSON-encoded string of addresses and returns an array of `Address` objects.\n *\n * @remarks\n * This function takes a string containing a JSON-encoded array of addresses\n * (ex: \"[address1,address2,...,addressN]\") and returns an array of `Address`\n * objects.\n *\n * @param str - A string containing a JSON-encoded array of addresses.\n *\n * @returns An array of `Address` objects, one for each address in the input string.\n */\nexport function json2Address(str: string): Array<Address> {\n  str = str.substring(1, str.length - 1);\n\n  const a = str.split(',');\n  return a.map<Address>((x) => new Address(x.substring(1, x.length - 1)));\n}\n\n/**\n * Asserts that the given address is an already deployed non-destroyed contract.\n *\n * @param address - The address to check.\n *\n * @throws\n * If the address is not a valid smart contract address.\n * If no bytecode is found at the address.\n */\nexport function assertIsSmartContract(address: string): void {\n  // Check if it's a valid smart contract address\n  assert(validateAddress(address), `${address} is not a valid Address`);\n  assert(\n    address.startsWith('AS'),\n    `${address} is not a smart contract Address`,\n  );\n  // Throw if no contract has been deployed at this address\n  const bytecode = getBytecodeOf(new Address(address));\n  // Check if the contract has been destroyed\n  assert(bytecode.length > 0, `No bytecode found at address: ${address}`);\n}\n","/// <reference path=\"./rt/index.d.ts\" />\n\nimport { BLOCK_MAXSIZE } from \"./rt/common\";\nimport { Runtime } from \"shared/runtime\";\nimport { COMPARATOR, SORT } from \"./util/sort\";\nimport { REVERSE, FILL } from \"./util/bytes\";\nimport { joinBooleanArray, joinIntegerArray, joinFloatArray, joinStringArray, joinReferenceArray } from \"./util/string\";\nimport { idof, isArray as builtin_isArray } from \"./builtins\";\nimport { E_INDEXOUTOFRANGE, E_INVALIDLENGTH, E_EMPTYARRAY, E_HOLEYARRAY } from \"./util/error\";\n\n// @ts-ignore: decorator\n@inline @lazy const MIN_SIZE: usize = 8;\n\n/** Ensures that the given array has _at least_ the specified backing size. */\nfunction ensureCapacity(array: usize, newSize: usize, alignLog2: u32, canGrow: bool = true): void {\n  // Depends on the fact that Arrays mimic ArrayBufferView\n  let oldCapacity = <usize>changetype<ArrayBufferView>(array).byteLength;\n  if (newSize > oldCapacity >>> alignLog2) {\n    if (newSize > BLOCK_MAXSIZE >>> alignLog2) throw new RangeError(E_INVALIDLENGTH);\n    let oldData = changetype<usize>(changetype<ArrayBufferView>(array).buffer);\n    // Grows old capacity by factor of two.\n    // Make sure we don't reach BLOCK_MAXSIZE for new growed capacity.\n    let newCapacity = max(newSize, MIN_SIZE) << alignLog2;\n    if (canGrow) newCapacity = max(min(oldCapacity << 1, BLOCK_MAXSIZE), newCapacity);\n    let newData = __renew(oldData, newCapacity);\n    // __new / __renew already init memory range as zeros in Incremental runtime.\n    // So try to avoid this.\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(newData + oldCapacity, 0, newCapacity - oldCapacity);\n    }\n    if (newData != oldData) { // oldData has been free'd\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"buffer\"));\n      store<usize>(array, newData, offsetof<ArrayBufferView>(\"dataStart\"));\n      __link(array, changetype<usize>(newData), false);\n    }\n    store<u32>(array, <u32>newCapacity, offsetof<ArrayBufferView>(\"byteLength\"));\n  }\n}\n\nexport class Array<T> {\n  [key: number]: T;\n\n  // Mimicking ArrayBufferView isn't strictly necessary here but is done to allow glue code\n  // to work with typed and normal arrays interchangeably. Technically, normal arrays do not need\n  // `dataStart` (equals `buffer`) and `byteLength` (equals computed `buffer.byteLength`), but the\n  // block is 16 bytes anyway so it's fine to have a couple extra fields in there.\n\n  private buffer: ArrayBuffer;\n  @unsafe readonly dataStart: usize;\n  private byteLength: i32; // Uses here as capacity\n\n  // Also note that Array<T> with non-nullable T must guard against uninitialized null values\n  // whenever an element is accessed. Otherwise, the compiler wouldn't be able to guarantee\n  // type-safety anymore. For lack of a better word, such an array is \"holey\".\n\n  private length_: i32;\n\n  static isArray<U>(value: U): bool {\n    return isReference<U>() ? changetype<usize>(value) != 0 && builtin_isArray(value) : false;\n  }\n\n  static create<T>(capacity: i32 = 0): Array<T> {\n    WARNING(\"'Array.create' is deprecated. Use 'new Array' instead, making sure initial elements are initialized.\");\n    let array = new Array<T>(capacity);\n    array.length = 0;\n    return array;\n  }\n\n  constructor(length: i32 = 0) {\n    if (<u32>length > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new RangeError(E_INVALIDLENGTH);\n    // reserve capacity for at least MIN_SIZE elements\n    let bufferSize = max(<usize>length, MIN_SIZE) << alignof<T>();\n    let buffer = changetype<ArrayBuffer>(__new(bufferSize, idof<ArrayBuffer>()));\n    if (ASC_RUNTIME != Runtime.Incremental) {\n      memory.fill(changetype<usize>(buffer), 0, bufferSize);\n    }\n    this.buffer = buffer; // links\n    this.dataStart = changetype<usize>(buffer);\n    this.byteLength = <i32>bufferSize;\n    this.length_ = length;\n  }\n\n  get length(): i32 {\n    return this.length_;\n  }\n\n  set length(newLength: i32) {\n    ensureCapacity(changetype<usize>(this), newLength, alignof<T>(), false);\n    this.length_ = newLength;\n  }\n\n  every(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (!fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return false;\n    }\n    return true;\n  }\n\n  findIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  findLastIndex(fn: (value: T, index: i32, array: Array<T>) => bool): i32 {\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return i;\n    }\n    return -1;\n  }\n\n  @operator(\"[]\") private __get(index: i32): T {\n    if (<u32>index >= <u32>this.length_) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  @unsafe @operator(\"{}\") private __uget(index: i32): T {\n    return load<T>(this.dataStart + (<usize>index << alignof<T>()));\n  }\n\n  @operator(\"[]=\") private __set(index: i32, value: T): void {\n    if (<u32>index >= <u32>this.length_) {\n      if (index < 0) throw new RangeError(E_INDEXOUTOFRANGE);\n      ensureCapacity(changetype<usize>(this), index + 1, alignof<T>());\n      this.length_ = index + 1;\n    }\n    store<T>(this.dataStart + (<usize>index << alignof<T>()), value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n  }\n\n  at(index: i32): T {\n    let len = this.length_;\n    index += select(0, len, index >= 0);\n    if (<u32>index >= <u32>len) throw new RangeError(E_INDEXOUTOFRANGE);\n    let value = load<T>(this.dataStart + (<usize>index << alignof<T>()));\n    if (isReference<T>()) {\n      if (!isNullable<T>()) {\n        if (!changetype<usize>(value)) throw new Error(E_HOLEYARRAY);\n      }\n    }\n    return value;\n  }\n\n  fill(value: T, start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    if (isManaged<T>()) {\n      FILL<usize>(this.dataStart, this.length_, changetype<usize>(value), start, end);\n      __link(changetype<usize>(this), changetype<usize>(value), false);\n    } else {\n      FILL<T>(this.dataStart, this.length_, value, start, end);\n    }\n    return this;\n  }\n\n  includes(value: T, fromIndex: i32 = 0): bool {\n    if (isFloat<T>()) {\n      let len = this.length_;\n      if (len == 0 || fromIndex >= len) return false;\n      if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n      let ptr = this.dataStart;\n      while (fromIndex < len) {\n        let elem = load<T>(ptr + (<usize>fromIndex << alignof<T>()));\n        // @ts-ignore\n        if (elem == value || isNaN(elem) & isNaN(value)) return true;\n        ++fromIndex;\n      }\n      return false;\n    } else {\n      return this.indexOf(value, fromIndex) >= 0;\n    }\n  }\n\n  indexOf(value: T, fromIndex: i32 = 0): i32 {\n    let len = this.length_;\n    if (len == 0 || fromIndex >= len) return -1;\n    if (fromIndex < 0) fromIndex = max(len + fromIndex, 0);\n    let ptr = this.dataStart;\n    while (fromIndex < len) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      ++fromIndex;\n    }\n    return -1;\n  }\n\n  lastIndexOf(value: T, fromIndex: i32 = this.length_): i32 {\n    let len = this.length_;\n    if (len == 0) return -1;\n    if (fromIndex < 0) fromIndex = len + fromIndex;\n    else if (fromIndex >= len) fromIndex = len - 1;\n    let ptr = this.dataStart;\n    while (fromIndex >= 0) {\n      if (load<T>(ptr + (<usize>fromIndex << alignof<T>())) == value) return fromIndex;\n      --fromIndex;\n    }\n    return -1;\n  }\n\n  push(value: T): i32 {\n    let oldLen = this.length_;\n    let len = oldLen + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    if (isManaged<T>()) {\n      store<usize>(this.dataStart + (<usize>oldLen << alignof<T>()), changetype<usize>(value));\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    } else {\n      store<T>(this.dataStart + (<usize>oldLen << alignof<T>()), value);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  concat(other: Array<T>): Array<T> {\n    let thisLen = this.length_;\n    let otherLen = other.length_;\n    let outLen = thisLen + otherLen;\n    if (<u32>outLen > <u32>BLOCK_MAXSIZE >>> alignof<T>()) throw new Error(E_INVALIDLENGTH);\n    let out = changetype<Array<T>>(__newArray(outLen, alignof<T>(), idof<Array<T>>()));\n    let outStart = out.dataStart;\n    let thisSize = <usize>thisLen << alignof<T>();\n    if (isManaged<T>()) {\n      let thisStart = this.dataStart;\n      for (let offset: usize = 0; offset < thisSize; offset += sizeof<T>()) {\n        let ref = load<usize>(thisStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n      outStart += thisSize;\n      let otherStart = other.dataStart;\n      let otherSize = <usize>otherLen << alignof<T>();\n      for (let offset: usize = 0; offset < otherSize; offset += sizeof<T>()) {\n        let ref = load<usize>(otherStart + offset);\n        store<usize>(outStart + offset, ref);\n        __link(changetype<usize>(out), ref, true);\n      }\n    } else {\n      memory.copy(outStart, this.dataStart, thisSize);\n      memory.copy(outStart + thisSize, other.dataStart, <usize>otherLen << alignof<T>());\n    }\n    return out;\n  }\n\n  copyWithin(target: i32, start: i32, end: i32 = i32.MAX_VALUE): Array<T> {\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    end = min<i32>(end, len);\n\n    let to    = target < 0 ? max(len + target, 0) : min(target, len);\n    let from  = start < 0 ? max(len + start, 0) : min(start, len);\n    let last  = end < 0 ? max(len + end, 0) : min(end, len);\n    let count = min(last - from, len - to);\n\n    memory.copy( // is memmove\n      ptr + (<usize>to << alignof<T>()),\n      ptr + (<usize>from << alignof<T>()),\n      <usize>count << alignof<T>()\n    );\n    return this;\n  }\n\n  pop(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let val = load<T>(this.dataStart + (<usize>(--len) << alignof<T>()));\n    this.length_ = len;\n    return val;\n  }\n\n  forEach(fn: (value: T, index: i32, array: Array<T>) => void): void {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n  }\n\n  map<U>(fn: (value: T, index: i32, array: Array<T>) => U): Array<U> {\n    let len = this.length_;\n    let out = changetype<Array<U>>(__newArray(len, alignof<U>(), idof<Array<U>>()));\n    let outStart = out.dataStart;\n    for (let i = 0; i < min(len, this.length_); ++i) {\n      let result = fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n      store<U>(outStart + (<usize>i << alignof<U>()), result);\n      if (isManaged<U>()) {\n        __link(changetype<usize>(out), changetype<usize>(result), true);\n      }\n    }\n    return out;\n  }\n\n  filter(fn: (value: T, index: i32, array: Array<T>) => bool): Array<T> {\n    let result = changetype<Array<T>>(__newArray(0, alignof<T>(), idof<Array<T>>()));\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      let value = load<T>(this.dataStart + (<usize>i << alignof<T>()));\n      if (fn(value, i, this)) result.push(value);\n    }\n    return result;\n  }\n\n  reduce<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  reduceRight<U>(\n    fn: (previousValue: U, currentValue: T, currentIndex: i32, array: Array<T>) => U,\n    initialValue: U\n  ): U {\n    let acc = initialValue;\n    for (let i = this.length_ - 1; i >= 0; --i) {\n      acc = fn(acc, load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this);\n    }\n    return acc;\n  }\n\n  shift(): T {\n    let len = this.length_;\n    if (len < 1) throw new RangeError(E_EMPTYARRAY);\n    let base = this.dataStart;\n    let element = load<T>(base);\n    let lastIndex = len - 1;\n    memory.copy(\n      base,\n      base + sizeof<T>(),\n      <usize>lastIndex << alignof<T>()\n    );\n    if (isReference<T>()) {\n      store<usize>(base + (<usize>lastIndex << alignof<T>()), 0);\n    } else {\n      // @ts-ignore\n      store<T>(base + (<usize>lastIndex << alignof<T>()), <T>0);\n    }\n    this.length_ = lastIndex;\n    return element;\n  }\n\n  some(fn: (value: T, index: i32, array: Array<T>) => bool): bool {\n    for (let i = 0, len = this.length_; i < min(len, this.length_); ++i) {\n      if (fn(load<T>(this.dataStart + (<usize>i << alignof<T>())), i, this)) return true;\n    }\n    return false;\n  }\n\n  unshift(value: T): i32 {\n    let len = this.length_ + 1;\n    ensureCapacity(changetype<usize>(this), len, alignof<T>());\n    let ptr = this.dataStart;\n    memory.copy(\n      ptr + sizeof<T>(),\n      ptr,\n      <usize>(len - 1) << alignof<T>()\n    );\n    store<T>(ptr, value);\n    if (isManaged<T>()) {\n      __link(changetype<usize>(this), changetype<usize>(value), true);\n    }\n    this.length_ = len;\n    return len;\n  }\n\n  slice(start: i32 = 0, end: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start = start < 0 ? max(start + len, 0) : min(start, len);\n    end   = end   < 0 ? max(end   + len, 0) : min(end  , len);\n    len = max(end - start, 0);\n    let slice = changetype<Array<T>>(__newArray(len, alignof<T>(), idof<Array<T>>()));\n    let sliceBase = slice.dataStart;\n    let thisBase = this.dataStart + (<usize>start << alignof<T>());\n    if (isManaged<T>()) {\n      let off = <usize>0;\n      let end = <usize>len << alignof<usize>();\n      while (off < end) {\n        let ref = load<usize>(thisBase + off);\n        store<usize>(sliceBase + off, ref);\n        __link(changetype<usize>(slice), ref, true);\n        off += sizeof<usize>();\n      }\n    } else {\n      memory.copy(sliceBase, thisBase, len << alignof<T>());\n    }\n    return slice;\n  }\n\n  splice(start: i32, deleteCount: i32 = i32.MAX_VALUE): Array<T> {\n    let len = this.length_;\n    start       = start < 0 ? max<i32>(len + start, 0) : min<i32>(start, len);\n    deleteCount = max<i32>(min<i32>(deleteCount, len - start), 0);\n    let result  = changetype<Array<T>>(__newArray(deleteCount, alignof<T>(), idof<Array<T>>()));\n    let resultStart = result.dataStart;\n    let thisStart = this.dataStart;\n    let thisBase  = thisStart + (<usize>start << alignof<T>());\n    memory.copy(\n      resultStart,\n      thisBase,\n      <usize>deleteCount << alignof<T>()\n    );\n    let offset = start + deleteCount;\n    if (len != offset) {\n      memory.copy(\n        thisBase,\n        thisStart + (<usize>offset << alignof<T>()),\n        <usize>(len - offset) << alignof<T>()\n      );\n    }\n    this.length_ = len - deleteCount;\n    return result;\n  }\n\n  reverse(): Array<T> {\n    REVERSE<T>(this.dataStart, this.length_);\n    return this;\n  }\n\n  sort(comparator: (a: T, b: T) => i32 = COMPARATOR<T>()): Array<T> {\n    SORT<T>(this.dataStart, this.length_, comparator);\n    return this;\n  }\n\n  join(separator: string = \",\"): string {\n    let ptr = this.dataStart;\n    let len = this.length_;\n    if (isBoolean<T>())   return joinBooleanArray(ptr, len, separator);\n    if (isInteger<T>())   return joinIntegerArray<T>(ptr, len, separator);\n    if (isFloat<T>())     return joinFloatArray<T>(ptr, len, separator);\n\n    if (ASC_SHRINK_LEVEL < 1) {\n      if (isString<T>())  return joinStringArray(ptr, len, separator);\n    }\n    // For rest objects and arrays use general join routine\n    if (isReference<T>()) return joinReferenceArray<T>(ptr, len, separator);\n    ERROR(\"unspported element type\");\n    return <string>unreachable();\n  }\n\n  flat(): T {\n    if (!isArray<T>()) {\n      ERROR(\"Cannot call flat() on Array<T> where T is not an Array.\");\n    }\n    // Get the length and data start values\n    let ptr = this.dataStart;\n    let len = this.length_;\n\n    // calculate the end size with an initial pass\n    let size = 0;\n    for (let i = 0; i < len; ++i) {\n      let child = load<usize>(ptr + (i << alignof<T>()));\n      size += child == 0 ? 0 : load<i32>(child, offsetof<T>(\"length_\"));\n    }\n\n    // calculate the byteLength of the resulting backing ArrayBuffer\n    const align = alignof<valueof<T>>();\n    let byteLength = <usize>size << align;\n    let outBuffer = changetype<ArrayBuffer>(__new(byteLength, idof<ArrayBuffer>()));\n\n    // create the return value and initialize it\n    let outArray = changetype<T>(__new(offsetof<T>(), idof<T>()));\n    store<i32>(changetype<usize>(outArray), size, offsetof<T>(\"length_\"));\n\n    // byteLength, dataStart, and buffer are all readonly\n    store<i32>(changetype<usize>(outArray), byteLength, offsetof<T>(\"byteLength\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"dataStart\"));\n    store<usize>(changetype<usize>(outArray), changetype<usize>(outBuffer), offsetof<T>(\"buffer\"));\n    __link(changetype<usize>(outArray), changetype<usize>(outBuffer), false);\n\n    // set the elements\n    let resultOffset: usize = 0;\n    for (let i = 0; i < len; ++i) { // for each child\n      let child = load<usize>(ptr + (<usize>i << alignof<T>()));\n\n      // ignore null arrays\n      if (!child) continue;\n\n      // copy the underlying buffer data to the result buffer\n      let childDataLength = <usize>load<i32>(child, offsetof<T>(\"length_\")) << align;\n      memory.copy(\n        changetype<usize>(outBuffer) + resultOffset,\n        load<usize>(child, offsetof<T>(\"dataStart\")),\n        childDataLength\n      );\n\n      // advance the result length\n      resultOffset += childDataLength;\n    }\n\n    // if the `valueof<T>` type is managed, we must link each reference\n    if (isManaged<valueof<T>>()) {\n      for (let i = 0; i < size; ++i) {\n        let ref = load<usize>(changetype<usize>(outBuffer) + (<usize>i << usize(alignof<valueof<T>>())));\n        __link(changetype<usize>(outBuffer), ref, true);\n      }\n    }\n\n    return outArray;\n  }\n\n  toString(): string {\n    return this.join();\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    if (isManaged<T>()) {\n      let cur = this.dataStart;\n      let end = cur + (<usize>this.length_ << alignof<T>());\n      while (cur < end) {\n        let val = load<usize>(cur);\n        if (val) __visit(val, cookie);\n        cur += sizeof<usize>();\n      }\n    }\n    __visit(changetype<usize>(this.buffer), cookie);\n  }\n}\n","/**\n * This module contains the 'Address' class, which represents a Massa blockchain address and provides helper features\n * for easier manipulation and management of addresses.\n *\n * The 'Address' class provides methods to {@link serialize} and {@link deserialize} an address, as well\n * as to convert it to a string with {@link toString}.\n * It also provides overloading methods to test if two addresses are {@link equals} or {@link notEqual}.\n *\n * @module\n */\n\nimport { Serializable, Args, Result } from '@massalabs/as-types';\nimport { validateAddress } from './utils';\n\n/**\n * Represents a Massa blockchain address.\n */\nexport class Address implements Serializable {\n  /**\n   * Creates a new Address;\n   *\n   * @param _value - A byte string that represents the address data.\n   */\n  constructor(private _value: string = '') {}\n\n  /**\n   * Serialize the address.\n   *\n   * @remarks\n   * This method is used to serialize an Address object into a byte array,\n   * which can be passed as an argument to another smart contract's method,\n   * or stored in persistent storage.\n   *\n   * @privateRemarks\n   * Addresses base58check encoded are not fixed-size, so the first bytes are the size as a\n   * i32, then the address string is encoded.\n   *\n   * @returns The serialized byte string of the address.\n   */\n  serialize(): StaticArray<u8> {\n    return new Args().add(this._value).serialize();\n  }\n\n  /**\n   * Deserialize the address.\n   *\n   * TODO: explain why we need this method\n   *\n   * @remarks\n   * This method deserializes a byte array into an `Address` object.\n   * Caller can test if the deserialization is successful by checking the\n   * [Result](https://as-types.docs.massa.net/classes/Result.html) wrapping the offset value.\n   * This offset can be used to identify where the next element starts in the byte array, if any.\n   *\n   * @privateRemarks\n   * This method constructs a new instance of the `Args` class using the `data` and `offset` parameters.\n   *\n   * @param data - The byte string to deserialize.\n   * @param offset - The offset of the current serialized address object in the byte array.\n   *\n   * @returns The offset of the next serialized object in the byte array wrapped in a `Result`.\n   */\n  deserialize(data: StaticArray<u8>, offset: i32 = 0): Result<i32> {\n    const args = new Args(data, offset);\n    const result = args.nextString();\n    if (result.isErr()) {\n      return new Result(0, \"Can't deserialize address.\");\n    }\n    this._value = result.unwrap();\n    return new Result(args.offset);\n  }\n\n  /**\n   * Convert the address to a string.\n   *\n   * @returns A string representation of the address.\n   */\n  toString(): string {\n    return this._value;\n  }\n\n  /**\n   * Tests if two addresses are identical.\n   *\n   * @remarks\n   * This method compares the string representation of the current `Address` object to another `Address`\n   * object to determine if they are identical.\n   *\n   * @param address - The address object to compare.\n   *\n   * @returns `true` if the addresses are identical, `false` otherwise.\n   */\n\n  @operator('==')\n  equals(address: Address): boolean {\n    return this._value == address.toString();\n  }\n\n  /**\n   * Tests if two addresses are different.\n   *\n   * @remarks\n   * This method compares the string representation of the current `Address` object to another `Address`\n   * object to determine if they are different.\n   *\n   * @param address - The address object to compare.\n   *\n   * @returns `true` if the addresses are different, `false` otherwise.\n   */\n  @operator('!=')\n  notEqual(address: Address): boolean {\n    return !(this == address);\n  }\n\n  /**\n   * Checks if the address is valid.\n   *\n   * @returns `true` if the address is valid, `false` otherwise.\n   */\n  isValid(): bool {\n    return validateAddress(this._value);\n  }\n\n  /**\n   * Checks if the address is a smart contract.\n   *\n   * @param address - The address to check.\n   *\n   * @returns `true` if the address is a smart contract, `false` otherwise.\n   */\n  @inline\n  isSmartContract(): bool {\n    return this._value.startsWith('AS') && this.isValid();\n  }\n\n  /**\n   * Checks if the address is an External owned account address.\n   *\n   * @returns `true` if the address is a Eoa address, `false` otherwise.\n   */\n  @inline\n  isEoa(): bool {\n    return this._value.startsWith('AU') && this.isValid();\n  }\n}\n","import { env } from '../../env';\nimport { Address } from '../address';\n\n/**\n * Transfers coins from the current address 'to' a given address.\n *\n * @param to - the address to send coins to.\n * @param amount - value in the smallest unit.\n * @see [massa units standard](https://github.com/massalabs/massa-standards/blob/main/units.md)\n *\n * @throws\n * - if the given address is not a valid address.\n * - if the balance of the current address is insufficient to make the transaction.\n *\n */\nexport function transferCoins(to: Address, amount: u64): void {\n  env.transferCoins(to.toString(), amount);\n}\n\n/**\n * Transfers coins 'from' an address 'to' another address.\n *\n * @remarks\n * The transfer can only be done if the caller has write access to the sender's address.\n * @see {@link callerHasWriteAccess}\n *\n * @param from - the sender address.\n * @param to - the address to send coins to.\n * @param amount - value in the smallest unit.\n * @see [massa units standard](https://github.com/massalabs/massa-standards/blob/main/units.md)\n *\n * @throws\n * - if the sender's or the receiver address is not a valid address.\n * - if the balance of the sender's address is insufficient to make the transaction.\n *\n */\nexport function transferCoinsOf(from: Address, to: Address, amount: u64): void {\n  env.transferCoinsOf(from.toString(), to.toString(), amount);\n}\n","import { itoa32, utoa32, itoa64, utoa64, dtoa } from \"./util/number\";\nimport { strtol, strtod } from \"./util/string\";\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const NaN: f64 = 0 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin @inline\nexport const Infinity: f64 = 1 / 0; // context-aware\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isNaN<T extends number>(value: T): bool;\n\n// @ts-ignore: decorator\n@builtin\nexport declare function isFinite<T extends number>(value: T): bool;\n\n@final @unmanaged\nexport abstract class I8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i8 = i8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i8 = i8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i8 {\n    return <i8>strtol<i32>(value, radix);\n  }\n\n  toString(this: i8, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i16 = i16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i16 = i16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i16 {\n    return <i16>strtol<i32>(value, radix);\n  }\n\n  toString(this: i16, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i32 = i32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i32 = i32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i32 {\n    return <i32>strtol<i32>(value, radix);\n  }\n\n  toString(this: i32, radix: i32 = 10): String {\n    return itoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class I64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: i64 = i64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: i64 = i64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): i64 {\n    return strtol<i64>(value, radix);\n  }\n\n  toString(this: i64, radix: i32 = 10): String {\n    return itoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Isize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: isize = isize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: isize = isize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): isize {\n    return <isize>strtol<i64>(value, radix);\n  }\n\n  toString(this: isize, radix: i32 = 10): String {\n    if (sizeof<isize>() == 4) {\n      return itoa32(<i32>this, radix);\n    } else {\n      return itoa64(<i64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class U8 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u8 = u8.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u8 = u8.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u8 {\n    return <u8>strtol<i32>(value, radix);\n  }\n\n  toString(this: u8, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U16 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u16 = u16.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u16 = u16.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u16 {\n    return <u16>strtol<i32>(value, radix);\n  }\n\n  toString(this: u16, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u32 = u32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u32 = u32.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u32 {\n    return <u32>strtol<i32>(value, radix);\n  }\n\n  toString(this: u32, radix: i32 = 10): String {\n    return utoa32(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class U64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: u64 = u64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: u64 = u64.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): u64 {\n    return <u64>strtol<i64>(value, radix);\n  }\n\n  toString(this: u64, radix: i32 = 10): String {\n    return utoa64(this, radix);\n  }\n}\n\n@final @unmanaged\nexport abstract class Usize {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: usize = usize.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: usize = usize.MAX_VALUE;\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): usize {\n    return <usize>strtol<i64>(value, radix);\n  }\n\n  toString(this: usize, radix: i32 = 10): String {\n    if (sizeof<usize>() == 4) {\n      return utoa32(<u32>this, radix);\n    } else {\n      return utoa64(<u64>this, radix);\n    }\n  }\n}\n\n@final @unmanaged\nexport abstract class Bool {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: bool = bool.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: bool = bool.MAX_VALUE;\n\n  toString(this: bool, radix: i32 = 0): String {\n    return this ? \"true\" : \"false\";\n  }\n}\n\nexport { Bool as Boolean };\n\n@final @unmanaged\nexport abstract class F32 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f32 = f32.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f32 = f32.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f32 = f32.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f32 = f32.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f32 = f32.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f32 = f32.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f32 = f32.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f32 = f32.NaN;\n\n  static isNaN(value: f32): bool {\n    return isNaN<f32>(value);\n  }\n\n  static isFinite(value: f32): bool {\n    return isFinite<f32>(value);\n  }\n\n  static isSafeInteger(value: f32): bool {\n    return abs<f32>(value) <= f32.MAX_SAFE_INTEGER && trunc<f32>(value) == value;\n  }\n\n  static isInteger(value: f32): bool {\n    return isFinite<f32>(value) && trunc<f32>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f32 {\n    return <f32>strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f32 {\n    return <f32>strtod(value);\n  }\n\n  toString(this: f32, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\n@final @unmanaged\nexport abstract class F64 {\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly EPSILON: f64 = f64.EPSILON;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_VALUE: f64 = f64.MIN_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_VALUE: f64 = f64.MAX_VALUE;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MIN_SAFE_INTEGER: f64 = f64.MIN_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly MAX_SAFE_INTEGER: f64 = f64.MAX_SAFE_INTEGER;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly POSITIVE_INFINITY: f64 = f64.POSITIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NEGATIVE_INFINITY: f64 = f64.NEGATIVE_INFINITY;\n\n  // @ts-ignore: decorator\n  @lazy\n  static readonly NaN: f64 = f64.NaN;\n\n  static isNaN(value: f64): bool {\n    return isNaN<f64>(value);\n  }\n\n  static isFinite(value: f64): bool {\n    return isFinite<f64>(value);\n  }\n\n  static isSafeInteger(value: f64): bool {\n    return abs<f64>(value) <= f64.MAX_SAFE_INTEGER && trunc<f64>(value) == value;\n  }\n\n  static isInteger(value: f64): bool {\n    return isFinite<f64>(value) && trunc<f64>(value) == value;\n  }\n\n  /** @deprecated */\n  static parseInt(value: string, radix: i32 = 0): f64 {\n    return strtol<f64>(value, radix);\n  }\n\n  /** @deprecated */\n  static parseFloat(value: string): f64 {\n    return strtod(value);\n  }\n\n  toString(this: f64, radix: i32 = 0): String {\n    return dtoa(this);\n  }\n}\n\nexport { F64 as Number };\n","/**\r\n * Equipment NFT Component\r\n * Handles equipment creation, transfers, and equipping\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  Equipment,\r\n  Character,\r\n  EQUIP_WEAPON,\r\n  EQUIP_ARMOR,\r\n  EQUIP_ACCESSORY,\r\n  RARITY_COMMON,\r\n  RARITY_RARE,\r\n  RARITY_EPIC,\r\n  RARITY_LEGENDARY,\r\n} from './types';\r\nimport {\r\n  saveEquipment,\r\n  loadEquipment,\r\n  equipmentExists,\r\n  saveCharacter,\r\n  loadCharacter,\r\n  addEquipmentToOwner,\r\n  removeEquipmentFromOwner,\r\n  isAdmin,\r\n} from './storage';\r\n\r\n// ============================================================================\r\n// Rarity Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Initialize equipment stats based on rarity\r\n */\r\nexport function initializeRarityStats(equipment: Equipment): void {\r\n  switch (equipment.rarity) {\r\n    case RARITY_COMMON:\r\n      equipment.hpBonus = 10;\r\n      equipment.damageMinBonus = 1;\r\n      equipment.damageMaxBonus = 2;\r\n      equipment.critBonus = 2;\r\n      equipment.dodgeBonus = 1;\r\n      equipment.durability = 100;\r\n      equipment.maxDurability = 100;\r\n      break;\r\n\r\n    case RARITY_RARE:\r\n      equipment.hpBonus = 25;\r\n      equipment.damageMinBonus = 3;\r\n      equipment.damageMaxBonus = 5;\r\n      equipment.critBonus = 5;\r\n      equipment.dodgeBonus = 3;\r\n      equipment.durability = 200;\r\n      equipment.maxDurability = 200;\r\n      break;\r\n\r\n    case RARITY_EPIC:\r\n      equipment.hpBonus = 50;\r\n      equipment.damageMinBonus = 5;\r\n      equipment.damageMaxBonus = 10;\r\n      equipment.critBonus = 10;\r\n      equipment.dodgeBonus = 5;\r\n      equipment.durability = 300;\r\n      equipment.maxDurability = 300;\r\n      break;\r\n\r\n    case RARITY_LEGENDARY:\r\n      equipment.hpBonus = 100;\r\n      equipment.damageMinBonus = 10;\r\n      equipment.damageMaxBonus = 20;\r\n      equipment.critBonus = 15;\r\n      equipment.dodgeBonus = 10;\r\n      equipment.durability = 500;\r\n      equipment.maxDurability = 500;\r\n      break;\r\n\r\n    default:\r\n      // Default to common stats\r\n      equipment.hpBonus = 10;\r\n      equipment.damageMinBonus = 1;\r\n      equipment.damageMaxBonus = 2;\r\n      equipment.critBonus = 2;\r\n      equipment.dodgeBonus = 1;\r\n      equipment.durability = 100;\r\n      equipment.maxDurability = 100;\r\n  }\r\n\r\n  // Adjust stats based on equipment type\r\n  applyEquipmentTypeModifiers(equipment);\r\n}\r\n\r\n/**\r\n * Apply modifiers based on equipment slot type\r\n */\r\nfunction applyEquipmentTypeModifiers(equipment: Equipment): void {\r\n  switch (equipment.equipmentType) {\r\n    case EQUIP_WEAPON:\r\n      // Weapons focus on damage and crit\r\n      equipment.damageMinBonus = u8(equipment.damageMinBonus * 2);\r\n      equipment.damageMaxBonus = u8(equipment.damageMaxBonus * 2);\r\n      equipment.critBonus = u8(equipment.critBonus * 150 / 100);\r\n      equipment.hpBonus = 0; // Weapons don't give HP\r\n      equipment.dodgeBonus = 0; // Weapons don't give dodge\r\n      break;\r\n\r\n    case EQUIP_ARMOR:\r\n      // Armor focuses on HP and dodge\r\n      equipment.hpBonus = u16(equipment.hpBonus * 2);\r\n      equipment.dodgeBonus = u8(equipment.dodgeBonus * 150 / 100);\r\n      equipment.damageMinBonus = 0;\r\n      equipment.damageMaxBonus = 0;\r\n      equipment.critBonus = 0;\r\n      break;\r\n\r\n    case EQUIP_ACCESSORY:\r\n      // Accessories give balanced bonuses\r\n      equipment.critBonus = u8(equipment.critBonus * 150 / 100);\r\n      equipment.dodgeBonus = u8(equipment.dodgeBonus * 150 / 100);\r\n      equipment.hpBonus = u16(equipment.hpBonus / 2);\r\n      equipment.damageMinBonus = u8(equipment.damageMinBonus / 2);\r\n      equipment.damageMaxBonus = u8(equipment.damageMaxBonus / 2);\r\n      break;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Creation\r\n// ============================================================================\r\n\r\n/**\r\n * Create new equipment (admin only or through game rewards)\r\n * @param equipmentId - Unique equipment ID\r\n * @param owner - Owner address\r\n * @param equipmentType - Type (weapon, armor, accessory)\r\n * @param rarity - Rarity tier\r\n */\r\nexport function createEquipment(\r\n  equipmentId: string,\r\n  owner: string,\r\n  equipmentType: u8,\r\n  rarity: u8\r\n): Equipment {\r\n  // Validate equipment doesn't exist\r\n  assert(!equipmentExists(equipmentId), 'Equipment ID already exists');\r\n\r\n  // Validate type\r\n  assert(equipmentType <= EQUIP_ACCESSORY, 'Invalid equipment type');\r\n\r\n  // Validate rarity\r\n  assert(rarity <= RARITY_LEGENDARY, 'Invalid rarity');\r\n\r\n  const timestamp = Context.timestamp();\r\n\r\n  // Create equipment\r\n  const equipment = new Equipment(equipmentId, owner, equipmentType, rarity);\r\n  equipment.createdAt = timestamp;\r\n\r\n  // Initialize stats based on rarity and type\r\n  initializeRarityStats(equipment);\r\n\r\n  // Save to storage\r\n  saveEquipment(equipment);\r\n\r\n  // Add to owner's equipment list\r\n  addEquipmentToOwner(owner, equipmentId);\r\n\r\n  // Emit event\r\n  generateEvent(\r\n    `EQUIPMENT_CREATED:${equipmentId}:${owner}:${equipmentType.toString()}:${rarity.toString()}`\r\n  );\r\n\r\n  return equipment;\r\n}\r\n\r\n/**\r\n * Admin function to mint equipment for a player\r\n */\r\nexport function adminMintEquipment(\r\n  equipmentId: string,\r\n  toAddress: string,\r\n  equipmentType: u8,\r\n  rarity: u8\r\n): Equipment {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can mint equipment');\r\n\r\n  return createEquipment(equipmentId, toAddress, equipmentType, rarity);\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Reading\r\n// ============================================================================\r\n\r\n/**\r\n * Read equipment data\r\n */\r\nexport function readEquipment(id: string): Equipment {\r\n  const equipment = loadEquipment(id);\r\n  assert(equipment != null, 'Equipment not found');\r\n  return equipment!;\r\n}\r\n\r\n/**\r\n * Check if caller owns the equipment\r\n */\r\nexport function isEquipmentOwner(equipmentId: string, address: string): bool {\r\n  const equipment = loadEquipment(equipmentId);\r\n  if (equipment == null) return false;\r\n  return equipment!.owner == address;\r\n}\r\n\r\n/**\r\n * Assert caller owns the equipment\r\n */\r\nexport function assertEquipmentOwner(equipmentId: string): Equipment {\r\n  const equipment = loadEquipment(equipmentId);\r\n  assert(equipment != null, 'Equipment not found');\r\n  assert(\r\n    equipment!.owner == Context.caller().toString(),\r\n    'Not equipment owner'\r\n  );\r\n  return equipment!;\r\n}\r\n\r\n// ============================================================================\r\n// Equipment Transfer (NFT functionality)\r\n// ============================================================================\r\n\r\n/**\r\n * Transfer equipment to another address\r\n * @param equipmentId - Equipment ID\r\n * @param toAddr - Destination address\r\n */\r\nexport function transferEquipment(equipmentId: string, toAddr: string): void {\r\n  const equipment = assertEquipmentOwner(equipmentId);\r\n\r\n  // Cannot transfer equipped items\r\n  assert(\r\n    equipment.equippedTo.length == 0,\r\n    'Cannot transfer equipped equipment'\r\n  );\r\n\r\n  const fromAddr = equipment.owner;\r\n\r\n  // Update ownership\r\n  removeEquipmentFromOwner(fromAddr, equipmentId);\r\n  addEquipmentToOwner(toAddr, equipmentId);\r\n\r\n  equipment.owner = toAddr;\r\n  saveEquipment(equipment);\r\n\r\n  // Emit transfer event\r\n  generateEvent(\r\n    `EQUIPMENT_TRANSFERRED:${equipmentId}:${fromAddr}:${toAddr}`\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Equip/Unequip Operations\r\n// ============================================================================\r\n\r\n/**\r\n * Equip an item to a character\r\n * @param charId - Character ID\r\n * @param equipmentId - Equipment ID to equip\r\n */\r\nexport function equipItem(charId: string, equipmentId: string): void {\r\n  const caller = Context.caller().toString();\r\n\r\n  // Verify ownership of both character and equipment\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n  assert(character!.owner == caller, 'Not character owner');\r\n\r\n  const equipment = loadEquipment(equipmentId);\r\n  assert(equipment != null, 'Equipment not found');\r\n  assert(equipment!.owner == caller, 'Not equipment owner');\r\n\r\n  // Ensure equipment is not already equipped\r\n  assert(\r\n    equipment!.equippedTo.length == 0,\r\n    'Equipment already equipped to another character'\r\n  );\r\n\r\n  // Unequip existing item in the slot\r\n  unequipSlot(character!, equipment!.equipmentType);\r\n\r\n  // Equip the new item\r\n  switch (equipment!.equipmentType) {\r\n    case EQUIP_WEAPON:\r\n      character!.weaponId = equipmentId;\r\n      break;\r\n    case EQUIP_ARMOR:\r\n      character!.armorId = equipmentId;\r\n      break;\r\n    case EQUIP_ACCESSORY:\r\n      character!.accessoryId = equipmentId;\r\n      break;\r\n  }\r\n\r\n  equipment!.equippedTo = charId;\r\n\r\n  // Save both\r\n  saveCharacter(character!);\r\n  saveEquipment(equipment!);\r\n\r\n  generateEvent(\r\n    `ITEM_EQUIPPED:${charId}:${equipmentId}:${equipment!.equipmentType.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Unequip an item from a character\r\n * @param charId - Character ID\r\n * @param equipmentId - Equipment ID to unequip\r\n */\r\nexport function unequipItem(charId: string, equipmentId: string): void {\r\n  const caller = Context.caller().toString();\r\n\r\n  const character = loadCharacter(charId);\r\n  assert(character != null, 'Character not found');\r\n  assert(character!.owner == caller, 'Not character owner');\r\n\r\n  const equipment = loadEquipment(equipmentId);\r\n  assert(equipment != null, 'Equipment not found');\r\n  assert(equipment!.equippedTo == charId, 'Equipment not equipped to this character');\r\n\r\n  // Remove from character slot\r\n  switch (equipment!.equipmentType) {\r\n    case EQUIP_WEAPON:\r\n      character!.weaponId = '';\r\n      break;\r\n    case EQUIP_ARMOR:\r\n      character!.armorId = '';\r\n      break;\r\n    case EQUIP_ACCESSORY:\r\n      character!.accessoryId = '';\r\n      break;\r\n  }\r\n\r\n  equipment!.equippedTo = '';\r\n\r\n  // Save both\r\n  saveCharacter(character!);\r\n  saveEquipment(equipment!);\r\n\r\n  generateEvent(`ITEM_UNEQUIPPED:${charId}:${equipmentId}`);\r\n}\r\n\r\n/**\r\n * Helper to unequip current item in a slot\r\n */\r\nfunction unequipSlot(character: Character, slotType: u8): void {\r\n  let currentEquipId = '';\r\n\r\n  switch (slotType) {\r\n    case EQUIP_WEAPON:\r\n      currentEquipId = character.weaponId;\r\n      character.weaponId = '';\r\n      break;\r\n    case EQUIP_ARMOR:\r\n      currentEquipId = character.armorId;\r\n      character.armorId = '';\r\n      break;\r\n    case EQUIP_ACCESSORY:\r\n      currentEquipId = character.accessoryId;\r\n      character.accessoryId = '';\r\n      break;\r\n  }\r\n\r\n  if (currentEquipId.length > 0) {\r\n    const equipment = loadEquipment(currentEquipId);\r\n    if (equipment != null) {\r\n      equipment.equippedTo = '';\r\n      saveEquipment(equipment);\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Durability Management\r\n// ============================================================================\r\n\r\n/**\r\n * Reduce equipment durability after battle\r\n * @param equipmentId - Equipment ID\r\n * @param amount - Durability loss\r\n */\r\nexport function reduceDurability(equipmentId: string, amount: u16): void {\r\n  const equipment = loadEquipment(equipmentId);\r\n  if (equipment == null) return;\r\n\r\n  if (equipment!.durability <= amount) {\r\n    equipment!.durability = 0;\r\n    // Equipment is broken - could implement breaking mechanics here\r\n    generateEvent(`EQUIPMENT_BROKEN:${equipmentId}`);\r\n  } else {\r\n    equipment!.durability -= amount;\r\n  }\r\n\r\n  saveEquipment(equipment!);\r\n}\r\n\r\n/**\r\n * Repair equipment (implement payment separately)\r\n * @param equipmentId - Equipment ID\r\n */\r\nexport function repairEquipment(equipmentId: string): void {\r\n  const equipment = assertEquipmentOwner(equipmentId);\r\n\r\n  equipment.durability = equipment.maxDurability;\r\n  saveEquipment(equipment);\r\n\r\n  generateEvent(`EQUIPMENT_REPAIRED:${equipmentId}`);\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get equipment type name\r\n */\r\nexport function getEquipmentTypeName(typeId: u8): string {\r\n  switch (typeId) {\r\n    case EQUIP_WEAPON:\r\n      return 'Weapon';\r\n    case EQUIP_ARMOR:\r\n      return 'Armor';\r\n    case EQUIP_ACCESSORY:\r\n      return 'Accessory';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Get rarity name\r\n */\r\nexport function getRarityName(rarity: u8): string {\r\n  switch (rarity) {\r\n    case RARITY_COMMON:\r\n      return 'Common';\r\n    case RARITY_RARE:\r\n      return 'Rare';\r\n    case RARITY_EPIC:\r\n      return 'Epic';\r\n    case RARITY_LEGENDARY:\r\n      return 'Legendary';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n","/**\r\n * Skill System Component\r\n * Handles skill learning, equipping, energy management, and cooldowns\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  Character,\r\n  BattlePlayer,\r\n  SKILL_POWER_STRIKE,\r\n  SKILL_HEAL,\r\n  SKILL_POISON_STRIKE,\r\n  SKILL_STUN_STRIKE,\r\n  SKILL_SHIELD_WALL,\r\n  SKILL_RAGE_MODE,\r\n  SKILL_CRITICAL_EYE,\r\n  SKILL_DODGE_MASTER,\r\n  SKILL_BURN_AURA,\r\n  SKILL_COMBO_BREAKER,\r\n  MAX_ENERGY,\r\n  ENERGY_REGEN,\r\n  STATUS_POISON,\r\n  STATUS_STUN,\r\n  STATUS_SHIELD,\r\n  STATUS_RAGE,\r\n  STATUS_BURN,\r\n} from './types';\r\nimport { saveCharacter, loadCharacter } from './storage';\r\n\r\n// ============================================================================\r\n// Skill Configuration\r\n// ============================================================================\r\n\r\n/**\r\n * Get energy cost for a skill\r\n */\r\nexport function getSkillEnergyCost(skillId: u8): u8 {\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n      return 30;\r\n    case SKILL_HEAL:\r\n      return 40;\r\n    case SKILL_POISON_STRIKE:\r\n      return 25;\r\n    case SKILL_STUN_STRIKE:\r\n      return 50;\r\n    case SKILL_SHIELD_WALL:\r\n      return 30;\r\n    case SKILL_RAGE_MODE:\r\n      return 40;\r\n    case SKILL_CRITICAL_EYE:\r\n      return 60;\r\n    case SKILL_DODGE_MASTER:\r\n      return 50;\r\n    case SKILL_BURN_AURA:\r\n      return 35;\r\n    case SKILL_COMBO_BREAKER:\r\n      return 45;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get cooldown (in turns) for a skill\r\n */\r\nexport function getSkillCooldown(skillId: u8): u8 {\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n      return 3;\r\n    case SKILL_HEAL:\r\n      return 4;\r\n    case SKILL_POISON_STRIKE:\r\n      return 2;\r\n    case SKILL_STUN_STRIKE:\r\n      return 5;\r\n    case SKILL_SHIELD_WALL:\r\n      return 3;\r\n    case SKILL_RAGE_MODE:\r\n      return 4;\r\n    case SKILL_CRITICAL_EYE:\r\n      return 6;\r\n    case SKILL_DODGE_MASTER:\r\n      return 5;\r\n    case SKILL_BURN_AURA:\r\n      return 3;\r\n    case SKILL_COMBO_BREAKER:\r\n      return 4;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get damage multiplier for skill (100 = 1.0x, 150 = 1.5x)\r\n */\r\nexport function getSkillDamageMultiplier(skillId: u8): u8 {\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n      return 150; // 1.5x damage\r\n    case SKILL_POISON_STRIKE:\r\n      return 100; // Normal damage + poison\r\n    case SKILL_STUN_STRIKE:\r\n      return 80;  // Reduced damage + stun\r\n    case SKILL_BURN_AURA:\r\n      return 100; // Normal damage + burn\r\n    case SKILL_COMBO_BREAKER:\r\n      return 120; // 1.2x damage + reset combo\r\n    default:\r\n      return 100; // Skills without damage component\r\n  }\r\n}\r\n\r\n/**\r\n * Get skill name\r\n */\r\nexport function getSkillName(skillId: u8): string {\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n      return 'Power Strike';\r\n    case SKILL_HEAL:\r\n      return 'Heal';\r\n    case SKILL_POISON_STRIKE:\r\n      return 'Poison Strike';\r\n    case SKILL_STUN_STRIKE:\r\n      return 'Stun Strike';\r\n    case SKILL_SHIELD_WALL:\r\n      return 'Shield Wall';\r\n    case SKILL_RAGE_MODE:\r\n      return 'Rage Mode';\r\n    case SKILL_CRITICAL_EYE:\r\n      return 'Critical Eye';\r\n    case SKILL_DODGE_MASTER:\r\n      return 'Dodge Master';\r\n    case SKILL_BURN_AURA:\r\n      return 'Burn Aura';\r\n    case SKILL_COMBO_BREAKER:\r\n      return 'Combo Breaker';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Check if skill is valid\r\n */\r\nexport function isValidSkill(skillId: u8): bool {\r\n  return skillId >= SKILL_POWER_STRIKE && skillId <= SKILL_COMBO_BREAKER;\r\n}\r\n\r\n// ============================================================================\r\n// Skill Learning\r\n// ============================================================================\r\n\r\n/**\r\n * Learn a skill for a character\r\n * @param characterId - Character ID\r\n * @param skillId - Skill ID to learn\r\n */\r\nexport function learnSkill(characterId: string, skillId: u8): void {\r\n  assert(isValidSkill(skillId), 'Invalid skill ID');\r\n\r\n  const character = loadCharacter(characterId);\r\n  assert(character != null, 'Character not found');\r\n  assert(\r\n    character!.owner == Context.caller().toString(),\r\n    'Not character owner'\r\n  );\r\n\r\n  // Check if already learned (bitmask check)\r\n  const skillBit: u16 = u16(1) << (skillId - 1);\r\n  assert(\r\n    (character!.learnedSkills & skillBit) == 0,\r\n    'Skill already learned'\r\n  );\r\n\r\n  // Learn the skill\r\n  character!.learnedSkills |= skillBit;\r\n  saveCharacter(character!);\r\n\r\n  generateEvent(`SKILL_LEARNED:${characterId}:${skillId.toString()}`);\r\n}\r\n\r\n/**\r\n * Check if character has learned a skill\r\n */\r\nexport function hasLearnedSkill(character: Character, skillId: u8): bool {\r\n  if (!isValidSkill(skillId)) return false;\r\n  const skillBit: u16 = u16(1) << (skillId - 1);\r\n  return (character.learnedSkills & skillBit) != 0;\r\n}\r\n\r\n/**\r\n * Get count of learned skills\r\n */\r\nexport function getLearnedSkillCount(character: Character): u8 {\r\n  let count: u8 = 0;\r\n  for (let i: u8 = 1; i <= 10; i++) {\r\n    if (hasLearnedSkill(character, i)) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n// ============================================================================\r\n// Skill Equipping\r\n// ============================================================================\r\n\r\n/**\r\n * Equip a learned skill to a slot\r\n * @param characterId - Character ID\r\n * @param skillId - Skill ID to equip\r\n * @param slot - Slot number (1, 2, or 3)\r\n */\r\nexport function equipSkill(characterId: string, skillId: u8, slot: u8): void {\r\n  assert(slot >= 1 && slot <= 3, 'Invalid skill slot (1-3)');\r\n  assert(skillId == 0 || isValidSkill(skillId), 'Invalid skill ID');\r\n\r\n  const character = loadCharacter(characterId);\r\n  assert(character != null, 'Character not found');\r\n  assert(\r\n    character!.owner == Context.caller().toString(),\r\n    'Not character owner'\r\n  );\r\n\r\n  // If equipping a skill (not removing), check if learned\r\n  if (skillId != 0) {\r\n    assert(hasLearnedSkill(character!, skillId), 'Skill not learned');\r\n  }\r\n\r\n  // Equip to slot\r\n  switch (slot) {\r\n    case 1:\r\n      character!.skillSlot1 = skillId;\r\n      break;\r\n    case 2:\r\n      character!.skillSlot2 = skillId;\r\n      break;\r\n    case 3:\r\n      character!.skillSlot3 = skillId;\r\n      break;\r\n  }\r\n\r\n  saveCharacter(character!);\r\n\r\n  generateEvent(\r\n    `SKILL_EQUIPPED:${characterId}:${skillId.toString()}:${slot.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Get skill ID in a character's slot\r\n */\r\nexport function getEquippedSkill(character: Character, slot: u8): u8 {\r\n  switch (slot) {\r\n    case 1:\r\n      return character.skillSlot1;\r\n    case 2:\r\n      return character.skillSlot2;\r\n    case 3:\r\n      return character.skillSlot3;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Energy Management\r\n// ============================================================================\r\n\r\n/**\r\n * Regenerate energy at turn start\r\n */\r\nexport function regenerateEnergy(player: BattlePlayer): void {\r\n  const newEnergy = player.energy + ENERGY_REGEN;\r\n  player.energy = newEnergy > MAX_ENERGY ? MAX_ENERGY : newEnergy;\r\n}\r\n\r\n/**\r\n * Spend energy for skill use\r\n */\r\nexport function spendEnergy(player: BattlePlayer, amount: u8): bool {\r\n  if (player.energy < amount) {\r\n    return false;\r\n  }\r\n  player.energy -= amount;\r\n  return true;\r\n}\r\n\r\n/**\r\n * Check if player has enough energy for a skill\r\n */\r\nexport function canUseSkill(player: BattlePlayer, skillId: u8): bool {\r\n  return player.energy >= getSkillEnergyCost(skillId);\r\n}\r\n\r\n// ============================================================================\r\n// Cooldown Management\r\n// ============================================================================\r\n\r\n/**\r\n * Get current cooldown for a skill\r\n */\r\nexport function getPlayerCooldown(player: BattlePlayer, skillId: u8): u8 {\r\n  switch (skillId) {\r\n    case 1:\r\n      return player.cooldown1;\r\n    case 2:\r\n      return player.cooldown2;\r\n    case 3:\r\n      return player.cooldown3;\r\n    case 4:\r\n      return player.cooldown4;\r\n    case 5:\r\n      return player.cooldown5;\r\n    case 6:\r\n      return player.cooldown6;\r\n    case 7:\r\n      return player.cooldown7;\r\n    case 8:\r\n      return player.cooldown8;\r\n    case 9:\r\n      return player.cooldown9;\r\n    case 10:\r\n      return player.cooldown10;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Set cooldown for a skill\r\n */\r\nexport function setPlayerCooldown(\r\n  player: BattlePlayer,\r\n  skillId: u8,\r\n  cooldown: u8\r\n): void {\r\n  switch (skillId) {\r\n    case 1:\r\n      player.cooldown1 = cooldown;\r\n      break;\r\n    case 2:\r\n      player.cooldown2 = cooldown;\r\n      break;\r\n    case 3:\r\n      player.cooldown3 = cooldown;\r\n      break;\r\n    case 4:\r\n      player.cooldown4 = cooldown;\r\n      break;\r\n    case 5:\r\n      player.cooldown5 = cooldown;\r\n      break;\r\n    case 6:\r\n      player.cooldown6 = cooldown;\r\n      break;\r\n    case 7:\r\n      player.cooldown7 = cooldown;\r\n      break;\r\n    case 8:\r\n      player.cooldown8 = cooldown;\r\n      break;\r\n    case 9:\r\n      player.cooldown9 = cooldown;\r\n      break;\r\n    case 10:\r\n      player.cooldown10 = cooldown;\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if skill is on cooldown\r\n */\r\nexport function isSkillOnCooldown(player: BattlePlayer, skillId: u8): bool {\r\n  return getPlayerCooldown(player, skillId) > 0;\r\n}\r\n\r\n/**\r\n * Reduce all cooldowns by 1 at turn end\r\n */\r\nexport function reduceCooldowns(player: BattlePlayer): void {\r\n  if (player.cooldown1 > 0) player.cooldown1--;\r\n  if (player.cooldown2 > 0) player.cooldown2--;\r\n  if (player.cooldown3 > 0) player.cooldown3--;\r\n  if (player.cooldown4 > 0) player.cooldown4--;\r\n  if (player.cooldown5 > 0) player.cooldown5--;\r\n  if (player.cooldown6 > 0) player.cooldown6--;\r\n  if (player.cooldown7 > 0) player.cooldown7--;\r\n  if (player.cooldown8 > 0) player.cooldown8--;\r\n  if (player.cooldown9 > 0) player.cooldown9--;\r\n  if (player.cooldown10 > 0) player.cooldown10--;\r\n}\r\n\r\n// ============================================================================\r\n// Skill Effect Application\r\n// ============================================================================\r\n\r\n/**\r\n * Apply skill effect to attacker or defender\r\n * Returns any additional damage from the skill\r\n */\r\nexport function applySkillEffect(\r\n  skillId: u8,\r\n  attacker: BattlePlayer,\r\n  defender: BattlePlayer,\r\n  baseDamage: u16\r\n): u16 {\r\n  let finalDamage = baseDamage;\r\n  const multiplier = getSkillDamageMultiplier(skillId);\r\n\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n      // 150% damage\r\n      finalDamage = u16((u32(baseDamage) * u32(multiplier)) / 100);\r\n      break;\r\n\r\n    case SKILL_HEAL:\r\n      // Restore 30% max HP\r\n      const healAmount = u16(attacker.maxHp * 30 / 100);\r\n      attacker.currentHp = attacker.currentHp + healAmount > attacker.maxHp\r\n        ? attacker.maxHp\r\n        : attacker.currentHp + healAmount;\r\n      finalDamage = 0; // Heal doesn't deal damage\r\n      break;\r\n\r\n    case SKILL_POISON_STRIKE:\r\n      // Apply poison (5% HP/turn for 3 turns)\r\n      defender.statusEffects |= STATUS_POISON;\r\n      defender.poisonTurns = 3;\r\n      break;\r\n\r\n    case SKILL_STUN_STRIKE:\r\n      // Apply stun (skip 1 turn)\r\n      defender.statusEffects |= STATUS_STUN;\r\n      defender.stunTurns = 1;\r\n      finalDamage = u16((u32(baseDamage) * 80) / 100); // 80% damage\r\n      break;\r\n\r\n    case SKILL_SHIELD_WALL:\r\n      // Apply shield (30% damage reduction for 2 turns)\r\n      attacker.statusEffects |= STATUS_SHIELD;\r\n      attacker.shieldTurns = 2;\r\n      finalDamage = 0; // Shield doesn't deal damage\r\n      break;\r\n\r\n    case SKILL_RAGE_MODE:\r\n      // Apply rage (50% damage increase for 2 turns)\r\n      attacker.statusEffects |= STATUS_RAGE;\r\n      attacker.rageTurns = 2;\r\n      finalDamage = 0; // Rage activation doesn't deal damage\r\n      break;\r\n\r\n    case SKILL_CRITICAL_EYE:\r\n      // Guarantee next hit is critical\r\n      attacker.guaranteedCrit = true;\r\n      finalDamage = 0;\r\n      break;\r\n\r\n    case SKILL_DODGE_MASTER:\r\n      // +50% dodge for 2 turns\r\n      attacker.dodgeBoost = 50;\r\n      attacker.dodgeBoostTurns = 2;\r\n      finalDamage = 0;\r\n      break;\r\n\r\n    case SKILL_BURN_AURA:\r\n      // Apply burn (8% HP/turn for 3 turns)\r\n      defender.statusEffects |= STATUS_BURN;\r\n      defender.burnTurns = 3;\r\n      break;\r\n\r\n    case SKILL_COMBO_BREAKER:\r\n      // Reset enemy combo + 120% damage\r\n      defender.comboCount = 0;\r\n      finalDamage = u16((u32(baseDamage) * 120) / 100);\r\n      break;\r\n  }\r\n\r\n  return finalDamage;\r\n}\r\n\r\n/**\r\n * Check if a skill is an offensive skill (deals damage)\r\n */\r\nexport function isOffensiveSkill(skillId: u8): bool {\r\n  switch (skillId) {\r\n    case SKILL_POWER_STRIKE:\r\n    case SKILL_POISON_STRIKE:\r\n    case SKILL_STUN_STRIKE:\r\n    case SKILL_BURN_AURA:\r\n    case SKILL_COMBO_BREAKER:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n\r\n/**\r\n * Check if skill is a self-buff\r\n */\r\nexport function isSelfBuffSkill(skillId: u8): bool {\r\n  switch (skillId) {\r\n    case SKILL_HEAL:\r\n    case SKILL_SHIELD_WALL:\r\n    case SKILL_RAGE_MODE:\r\n    case SKILL_CRITICAL_EYE:\r\n    case SKILL_DODGE_MASTER:\r\n      return true;\r\n    default:\r\n      return false;\r\n  }\r\n}\r\n","/**\r\n * Battle Engine Component\r\n * Handles battle creation, turn execution, damage calculation, and finalization\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  Battle,\r\n  BattlePlayer,\r\n  Character,\r\n  BATTLE_STATE_PENDING,\r\n  BATTLE_STATE_ACTIVE,\r\n  BATTLE_STATE_WILDCARD,\r\n  BATTLE_STATE_COMPLETED,\r\n  STANCE_NEUTRAL,\r\n  STANCE_AGGRESSIVE,\r\n  STANCE_DEFENSIVE,\r\n  WILDCARD_CHANCE,\r\n  WILDCARD_DEADLINE,\r\n} from './types';\r\nimport {\r\n  saveBattle,\r\n  loadBattle,\r\n  battleExists,\r\n  loadCharacter,\r\n} from './storage';\r\nimport { getEffectiveStats } from './character';\r\nimport {\r\n  initializeSeed,\r\n  setSeed,\r\n  getCurrentSeed,\r\n  createBattleSeed,\r\n  rollDamage,\r\n  rollCritical,\r\n  rollDodge,\r\n  rollWildcard,\r\n  randomU8Between,\r\n} from './randomness';\r\nimport {\r\n  getSkillEnergyCost,\r\n  getSkillCooldown,\r\n  isValidSkill,\r\n  isSkillOnCooldown,\r\n  canUseSkill,\r\n  spendEnergy,\r\n  regenerateEnergy,\r\n  reduceCooldowns,\r\n  setPlayerCooldown,\r\n  applySkillEffect,\r\n  isOffensiveSkill,\r\n  isSelfBuffSkill,\r\n  getEquippedSkill,\r\n  hasLearnedSkill,\r\n} from './skills';\r\nimport {\r\n  isStunned,\r\n  hasRage,\r\n  hasShield,\r\n  applyDOTEffects,\r\n  tickStatusDurations,\r\n  getRageDamageMultiplier,\r\n  getShieldDamageReduction,\r\n  getTotalDodgeChance,\r\n  clearAllStatus,\r\n} from './status';\r\n\r\n// ============================================================================\r\n// Battle Creation\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new battle between two characters\r\n * @param battleId - Unique battle ID\r\n * @param char1Id - Player 1's character ID\r\n * @param char2Id - Player 2's character ID\r\n * @param startTs - Battle start timestamp\r\n */\r\nexport function createBattle(\r\n  battleId: string,\r\n  char1Id: string,\r\n  char2Id: string,\r\n  startTs: u64\r\n): Battle {\r\n  // Validate battle doesn't exist\r\n  assert(!battleExists(battleId), 'Battle ID already exists');\r\n\r\n  // Load and validate characters\r\n  const char1 = loadCharacter(char1Id);\r\n  assert(char1 != null, 'Character 1 not found');\r\n\r\n  const char2 = loadCharacter(char2Id);\r\n  assert(char2 != null, 'Character 2 not found');\r\n\r\n  // Get effective stats (with equipment bonuses)\r\n  const effective1 = getEffectiveStats(char1!);\r\n  const effective2 = getEffectiveStats(char2!);\r\n\r\n  // Create battle\r\n  const battle = new Battle(battleId);\r\n  battle.state = BATTLE_STATE_ACTIVE;\r\n  battle.startTimestamp = startTs;\r\n  battle.lastActionTimestamp = startTs;\r\n  battle.turnNumber = 1;\r\n  battle.currentTurn = 1; // Player 1 starts\r\n\r\n  // Initialize player states\r\n  battle.player1 = new BattlePlayer(char1Id, effective1.maxHp, effective1.maxHp);\r\n  battle.player2 = new BattlePlayer(char2Id, effective2.maxHp, effective2.maxHp);\r\n\r\n  // Initialize random seed\r\n  battle.randomSeed = createBattleSeed(battleId, startTs);\r\n\r\n  saveBattle(battle);\r\n\r\n  generateEvent(\r\n    `BATTLE_CREATED:${battleId}:${char1Id}:${char2Id}:${startTs.toString()}`\r\n  );\r\n\r\n  return battle;\r\n}\r\n\r\n// ============================================================================\r\n// Battle State Access\r\n// ============================================================================\r\n\r\n/**\r\n * Load battle and verify it exists\r\n */\r\nexport function getBattle(battleId: string): Battle {\r\n  const battle = loadBattle(battleId);\r\n  assert(battle != null, 'Battle not found');\r\n  return battle!;\r\n}\r\n\r\n/**\r\n * Check if it's a player's turn\r\n */\r\nexport function isPlayerTurn(battle: Battle, characterId: string): bool {\r\n  if (battle.currentTurn == 1) {\r\n    return battle.player1.characterId == characterId;\r\n  } else {\r\n    return battle.player2.characterId == characterId;\r\n  }\r\n}\r\n\r\n/**\r\n * Get the current attacker\r\n */\r\nexport function getCurrentAttacker(battle: Battle): BattlePlayer {\r\n  return battle.currentTurn == 1 ? battle.player1 : battle.player2;\r\n}\r\n\r\n/**\r\n * Get the current defender\r\n */\r\nexport function getCurrentDefender(battle: Battle): BattlePlayer {\r\n  return battle.currentTurn == 1 ? battle.player2 : battle.player1;\r\n}\r\n\r\n// ============================================================================\r\n// Damage Calculation\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate damage for an attack\r\n * Follows the damage formula from design doc\r\n */\r\nexport function calculateDamage(\r\n  attacker: BattlePlayer,\r\n  defender: BattlePlayer,\r\n  attackerChar: Character,\r\n  defenderChar: Character,\r\n  skillId: u8,\r\n  isCrit: bool\r\n): u16 {\r\n  // 1. Base Damage = Random(DamageMin + EquipBonus, DamageMax + EquipBonus)\r\n  const baseDamage = rollDamage(\r\n    u16(attackerChar.damageMin),\r\n    u16(attackerChar.damageMax)\r\n  );\r\n\r\n  // 2. Level Bonus = (Level - 1) * 2\r\n  const levelBonus: u16 = u16((attackerChar.level - 1) * 2);\r\n\r\n  // 3. Status Multiplier = 1.5 if Rage active, else 1.0\r\n  const rageMultiplier = getRageDamageMultiplier(attacker);\r\n\r\n  // 4. Calculate total base with multipliers\r\n  let totalBase: u32 = u32(baseDamage + levelBonus);\r\n  totalBase = (totalBase * u32(rageMultiplier)) / 100;\r\n\r\n  // 5. Critical = Total Base * 2 if crit occurs\r\n  if (isCrit) {\r\n    totalBase = totalBase * 2;\r\n  }\r\n\r\n  // 6. Combo Bonus = *1.2 if combo >= 3\r\n  if (attacker.comboCount >= 3) {\r\n    totalBase = (totalBase * 120) / 100;\r\n  }\r\n\r\n  // 7. Defense Reduction\r\n  let afterDefense: i32 = i32(totalBase) - i32(defenderChar.defense);\r\n  if (afterDefense < 0) afterDefense = 0;\r\n\r\n  // 8. Shield Reduction (0.7x if shield active)\r\n  const shieldReduction = getShieldDamageReduction(defender);\r\n  let finalDamage: u32 = (u32(afterDefense) * u32(shieldReduction)) / 100;\r\n\r\n  return u16(finalDamage);\r\n}\r\n\r\n// ============================================================================\r\n// Turn Execution\r\n// ============================================================================\r\n\r\n/**\r\n * Execute a turn in battle\r\n * @param battleId - Battle ID\r\n * @param attackerCharId - Character taking the action\r\n * @param stance - Combat stance (0=neutral, 1=aggressive, 2=defensive)\r\n * @param useSpecial - Whether to use a skill\r\n * @param skillSlot - Which skill slot to use (1-3)\r\n */\r\nexport function executeTurn(\r\n  battleId: string,\r\n  attackerCharId: string,\r\n  stance: u8,\r\n  useSpecial: bool,\r\n  skillSlot: u8\r\n): void {\r\n  const battle = getBattle(battleId);\r\n\r\n  // Validate battle state\r\n  assert(battle.state == BATTLE_STATE_ACTIVE, 'Battle not active');\r\n  assert(isPlayerTurn(battle, attackerCharId), 'Not your turn');\r\n\r\n  // Restore random seed\r\n  setSeed(battle.randomSeed);\r\n\r\n  // Get attacker and defender\r\n  const isPlayer1 = battle.currentTurn == 1;\r\n  const attacker = isPlayer1 ? battle.player1 : battle.player2;\r\n  const defender = isPlayer1 ? battle.player2 : battle.player1;\r\n\r\n  // Load character data\r\n  const attackerChar = loadCharacter(attacker.characterId);\r\n  const defenderChar = loadCharacter(defender.characterId);\r\n  assert(attackerChar != null && defenderChar != null, 'Character data error');\r\n\r\n  const effectiveAttacker = getEffectiveStats(attackerChar!);\r\n  const effectiveDefender = getEffectiveStats(defenderChar!);\r\n\r\n  // Apply DOT effects at turn start\r\n  const dotDamage = applyDOTEffects(attacker, battleId);\r\n\r\n  // Check if attacker died from DOT\r\n  if (attacker.currentHp == 0) {\r\n    finalizeBattleWithWinner(battle, defender.characterId);\r\n    return;\r\n  }\r\n\r\n  // Check stun - skip turn if stunned\r\n  if (isStunned(attacker)) {\r\n    generateEvent(`TURN_SKIPPED:${battleId}:${attackerCharId}:STUNNED`);\r\n    tickStatusDurations(attacker, battleId);\r\n    reduceCooldowns(attacker);\r\n    switchTurn(battle);\r\n    saveBattle(battle);\r\n    return;\r\n  }\r\n\r\n  // Regenerate energy\r\n  regenerateEnergy(attacker);\r\n\r\n  let skillId: u8 = 0;\r\n  let damageDealt: u16 = 0;\r\n  let dodged: bool = false;\r\n  let isCrit: bool = false;\r\n\r\n  // Handle skill usage\r\n  if (useSpecial && skillSlot >= 1 && skillSlot <= 3) {\r\n    skillId = getEquippedSkill(attackerChar!, skillSlot);\r\n\r\n    if (skillId > 0 && isValidSkill(skillId)) {\r\n      // Check if skill is on cooldown\r\n      if (isSkillOnCooldown(attacker, skillId)) {\r\n        generateEvent(`SKILL_ON_COOLDOWN:${battleId}:${skillId.toString()}`);\r\n        skillId = 0; // Fall back to basic attack\r\n      } else if (!canUseSkill(attacker, skillId)) {\r\n        generateEvent(`INSUFFICIENT_ENERGY:${battleId}:${skillId.toString()}`);\r\n        skillId = 0; // Fall back to basic attack\r\n      } else {\r\n        // Use the skill\r\n        spendEnergy(attacker, getSkillEnergyCost(skillId));\r\n        setPlayerCooldown(attacker, skillId, getSkillCooldown(skillId));\r\n\r\n        generateEvent(\r\n          `SKILL_USED:${battleId}:${attackerCharId}:${skillId.toString()}`\r\n        );\r\n      }\r\n    } else {\r\n      skillId = 0;\r\n    }\r\n  }\r\n\r\n  // Calculate and apply damage\r\n  if (skillId == 0 || isOffensiveSkill(skillId)) {\r\n    // Check for dodge\r\n    const totalDodge = getTotalDodgeChance(defender, effectiveDefender.dodgeChance);\r\n    dodged = rollDodge(totalDodge, 0);\r\n\r\n    if (dodged) {\r\n      generateEvent(`ATTACK_DODGED:${battleId}:${defender.characterId}`);\r\n      attacker.comboCount = 0; // Reset combo on miss\r\n    } else {\r\n      // Check for critical hit\r\n      isCrit = rollCritical(effectiveAttacker.critChance, attacker.guaranteedCrit);\r\n      attacker.guaranteedCrit = false; // Consume guaranteed crit\r\n\r\n      // Calculate base damage\r\n      let baseDamage = calculateDamage(\r\n        attacker,\r\n        defender,\r\n        effectiveAttacker,\r\n        effectiveDefender,\r\n        skillId,\r\n        isCrit\r\n      );\r\n\r\n      // Apply skill effects\r\n      if (skillId > 0) {\r\n        damageDealt = applySkillEffect(skillId, attacker, defender, baseDamage);\r\n      } else {\r\n        damageDealt = baseDamage;\r\n      }\r\n\r\n      // Apply stance modifiers\r\n      damageDealt = applyStanceModifier(damageDealt, stance);\r\n\r\n      // Apply damage\r\n      if (defender.currentHp <= damageDealt) {\r\n        defender.currentHp = 0;\r\n      } else {\r\n        defender.currentHp -= damageDealt;\r\n      }\r\n\r\n      // Increment combo\r\n      attacker.comboCount++;\r\n\r\n      generateEvent(\r\n        `DAMAGE_DEALT:${battleId}:${attackerCharId}:${defender.characterId}:${damageDealt.toString()}:${isCrit ? '1' : '0'}:${attacker.comboCount.toString()}`\r\n      );\r\n    }\r\n  } else if (isSelfBuffSkill(skillId)) {\r\n    // Self-buff skills don't deal damage\r\n    applySkillEffect(skillId, attacker, defender, 0);\r\n  }\r\n\r\n  // Check for wildcard trigger (10% chance)\r\n  if (rollWildcard(WILDCARD_CHANCE)) {\r\n    triggerWildcard(battle);\r\n    return; // Pause for wildcard decisions\r\n  }\r\n\r\n  // Check win condition\r\n  if (defender.currentHp == 0) {\r\n    finalizeBattleWithWinner(battle, attacker.characterId);\r\n    return;\r\n  }\r\n\r\n  // End of turn processing\r\n  tickStatusDurations(attacker, battleId);\r\n  reduceCooldowns(attacker);\r\n\r\n  // Switch turns\r\n  switchTurn(battle);\r\n\r\n  // Update battle state\r\n  battle.lastActionTimestamp = Context.timestamp();\r\n  battle.randomSeed = getCurrentSeed();\r\n\r\n  saveBattle(battle);\r\n\r\n  generateEvent(\r\n    `TURN_COMPLETE:${battleId}:${battle.turnNumber.toString()}:${battle.currentTurn.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Apply stance damage modifier\r\n */\r\nfunction applyStanceModifier(damage: u16, stance: u8): u16 {\r\n  switch (stance) {\r\n    case STANCE_AGGRESSIVE:\r\n      // +20% damage\r\n      return u16((u32(damage) * 120) / 100);\r\n    case STANCE_DEFENSIVE:\r\n      // -20% damage (but would receive -20% too)\r\n      return u16((u32(damage) * 80) / 100);\r\n    default:\r\n      return damage;\r\n  }\r\n}\r\n\r\n/**\r\n * Switch to the other player's turn\r\n */\r\nfunction switchTurn(battle: Battle): void {\r\n  battle.currentTurn = battle.currentTurn == 1 ? 2 : 1;\r\n  battle.turnNumber++;\r\n}\r\n\r\n// ============================================================================\r\n// Wildcard System\r\n// ============================================================================\r\n\r\n/**\r\n * Trigger a wildcard event\r\n */\r\nfunction triggerWildcard(battle: Battle): void {\r\n  battle.state = BATTLE_STATE_WILDCARD;\r\n  battle.wildcardActive = true;\r\n  battle.wildcardType = randomU8Between(1, 5); // 5 types of wildcards\r\n  battle.wildcardDeadline = Context.timestamp() + WILDCARD_DEADLINE;\r\n  battle.player1WildcardDecision = 255;\r\n  battle.player2WildcardDecision = 255;\r\n\r\n  saveBattle(battle);\r\n\r\n  generateEvent(\r\n    `WILDCARD_TRIGGERED:${battle.id}:${battle.wildcardType.toString()}:${battle.wildcardDeadline.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Submit wildcard decision\r\n * @param battleId - Battle ID\r\n * @param accept - Accept or reject the wildcard\r\n * @param playerCharId - Character making the decision\r\n */\r\nexport function decideWildcard(\r\n  battleId: string,\r\n  accept: bool,\r\n  playerCharId: string\r\n): void {\r\n  const battle = getBattle(battleId);\r\n\r\n  assert(battle.state == BATTLE_STATE_WILDCARD, 'No wildcard active');\r\n\r\n  const decision: u8 = accept ? 1 : 0;\r\n\r\n  if (battle.player1.characterId == playerCharId) {\r\n    assert(battle.player1WildcardDecision == 255, 'Already decided');\r\n    battle.player1WildcardDecision = decision;\r\n  } else if (battle.player2.characterId == playerCharId) {\r\n    assert(battle.player2WildcardDecision == 255, 'Already decided');\r\n    battle.player2WildcardDecision = decision;\r\n  } else {\r\n    assert(false, 'Not a participant');\r\n  }\r\n\r\n  generateEvent(\r\n    `WILDCARD_DECISION:${battleId}:${playerCharId}:${accept ? 'ACCEPT' : 'REJECT'}`\r\n  );\r\n\r\n  // Check if both players have decided\r\n  if (\r\n    battle.player1WildcardDecision != 255 &&\r\n    battle.player2WildcardDecision != 255\r\n  ) {\r\n    resolveWildcard(battle);\r\n  } else {\r\n    saveBattle(battle);\r\n  }\r\n}\r\n\r\n/**\r\n * Resolve wildcard based on both players' decisions\r\n */\r\nfunction resolveWildcard(battle: Battle): void {\r\n  const p1Accept = battle.player1WildcardDecision == 1;\r\n  const p2Accept = battle.player2WildcardDecision == 1;\r\n\r\n  // Wildcard effect based on decisions\r\n  // Both accept: Strong effect\r\n  // One accepts: Mild effect\r\n  // Both reject: No effect\r\n\r\n  if (p1Accept && p2Accept) {\r\n    applyWildcardEffect(battle, true);\r\n  } else if (p1Accept || p2Accept) {\r\n    applyWildcardEffect(battle, false);\r\n  }\r\n  // Both reject = no effect\r\n\r\n  // Reset wildcard state and resume battle\r\n  battle.wildcardActive = false;\r\n  battle.state = BATTLE_STATE_ACTIVE;\r\n  battle.player1WildcardDecision = 255;\r\n  battle.player2WildcardDecision = 255;\r\n\r\n  saveBattle(battle);\r\n\r\n  generateEvent(`WILDCARD_RESOLVED:${battle.id}`);\r\n}\r\n\r\n/**\r\n * Apply wildcard effect\r\n */\r\nfunction applyWildcardEffect(battle: Battle, strong: bool): void {\r\n  const multiplier = strong ? 2 : 1;\r\n\r\n  switch (battle.wildcardType) {\r\n    case 1: // Health swap\r\n      if (strong) {\r\n        const temp = battle.player1.currentHp;\r\n        battle.player1.currentHp = battle.player2.currentHp;\r\n        battle.player2.currentHp = temp;\r\n      }\r\n      break;\r\n\r\n    case 2: // Energy boost\r\n      const boost = u8(30 * multiplier);\r\n      battle.player1.energy = battle.player1.energy + boost > 100 ? 100 : battle.player1.energy + boost;\r\n      battle.player2.energy = battle.player2.energy + boost > 100 ? 100 : battle.player2.energy + boost;\r\n      break;\r\n\r\n    case 3: // Heal both\r\n      const heal = u16(20 * multiplier);\r\n      battle.player1.currentHp = battle.player1.currentHp + heal > battle.player1.maxHp\r\n        ? battle.player1.maxHp\r\n        : battle.player1.currentHp + heal;\r\n      battle.player2.currentHp = battle.player2.currentHp + heal > battle.player2.maxHp\r\n        ? battle.player2.maxHp\r\n        : battle.player2.currentHp + heal;\r\n      break;\r\n\r\n    case 4: // Clear all status effects\r\n      clearAllStatus(battle.player1);\r\n      clearAllStatus(battle.player2);\r\n      break;\r\n\r\n    case 5: // Damage both\r\n      const dmg = u16(15 * multiplier);\r\n      battle.player1.currentHp = battle.player1.currentHp > dmg ? battle.player1.currentHp - dmg : 0;\r\n      battle.player2.currentHp = battle.player2.currentHp > dmg ? battle.player2.currentHp - dmg : 0;\r\n      break;\r\n  }\r\n\r\n  generateEvent(\r\n    `WILDCARD_EFFECT:${battle.id}:${battle.wildcardType.toString()}:${strong ? 'STRONG' : 'MILD'}`\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Battle Finalization\r\n// ============================================================================\r\n\r\n/**\r\n * Finalize battle with a winner\r\n */\r\nexport function finalizeBattleWithWinner(battle: Battle, winnerId: string): void {\r\n  battle.state = BATTLE_STATE_COMPLETED;\r\n  battle.winnerId = winnerId;\r\n\r\n  saveBattle(battle);\r\n\r\n  const loserId = battle.player1.characterId == winnerId\r\n    ? battle.player2.characterId\r\n    : battle.player1.characterId;\r\n\r\n  generateEvent(\r\n    `BATTLE_COMPLETED:${battle.id}:${winnerId}:${loserId}:${battle.turnNumber.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Finalize battle (for timeout or other reasons)\r\n */\r\nexport function finalizeBattle(battleId: string): void {\r\n  const battle = getBattle(battleId);\r\n\r\n  assert(\r\n    battle.state == BATTLE_STATE_ACTIVE || battle.state == BATTLE_STATE_WILDCARD,\r\n    'Battle already completed'\r\n  );\r\n\r\n  // Determine winner based on remaining HP\r\n  if (battle.player1.currentHp > battle.player2.currentHp) {\r\n    finalizeBattleWithWinner(battle, battle.player1.characterId);\r\n  } else if (battle.player2.currentHp > battle.player1.currentHp) {\r\n    finalizeBattleWithWinner(battle, battle.player2.characterId);\r\n  } else {\r\n    // Draw - player 1 wins by default (first mover disadvantage compensation)\r\n    finalizeBattleWithWinner(battle, battle.player1.characterId);\r\n  }\r\n}\r\n\r\n/**\r\n * Force timeout on wildcard decision\r\n */\r\nexport function timeoutWildcard(battleId: string): void {\r\n  const battle = getBattle(battleId);\r\n\r\n  assert(battle.state == BATTLE_STATE_WILDCARD, 'No wildcard active');\r\n  assert(\r\n    Context.timestamp() > battle.wildcardDeadline,\r\n    'Deadline not reached'\r\n  );\r\n\r\n  // Players who didn't decide are treated as rejecting\r\n  if (battle.player1WildcardDecision == 255) {\r\n    battle.player1WildcardDecision = 0;\r\n  }\r\n  if (battle.player2WildcardDecision == 255) {\r\n    battle.player2WildcardDecision = 0;\r\n  }\r\n\r\n  resolveWildcard(battle);\r\n}\r\n\r\n// ============================================================================\r\n// Battle Query Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get battle state as string\r\n */\r\nexport function getBattleStateName(state: u8): string {\r\n  switch (state) {\r\n    case BATTLE_STATE_PENDING:\r\n      return 'Pending';\r\n    case BATTLE_STATE_ACTIVE:\r\n      return 'Active';\r\n    case BATTLE_STATE_WILDCARD:\r\n      return 'Wildcard';\r\n    case BATTLE_STATE_COMPLETED:\r\n      return 'Completed';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Check if battle is still active\r\n */\r\nexport function isBattleActive(battleId: string): bool {\r\n  const battle = loadBattle(battleId);\r\n  if (battle == null) return false;\r\n  return battle.state == BATTLE_STATE_ACTIVE || battle.state == BATTLE_STATE_WILDCARD;\r\n}\r\n","/**\n * Converts a StaticArray<u8> to boolean.\n *\n * @remarks\n * The conversion is performed by checking if the first byte of the\n * `StaticArray<u8>` is non-zero (i.e., it represents a `true` value)\n * or zero (i.e., it represents a `false` value).\n *\n * @param arr - the StaticArray<u8> to convert\n *\n * @returns the boolean value\n */\n// @ts-ignore: decorator\n@inline\nexport function byteToBool(arr: StaticArray<u8>): bool {\n  return !!arr[0];\n}\n\n/**\n * Converts a boolean to StaticArray<u8>.\n *\n * @remarks\n * The conversion is performed by creating a StaticArray<u8> of length 1,\n * where the first byte represents the boolean value.\n * If the value is true, the byte is set to 1, otherwise, it is set to 0.\n *\n * @param val - the boolean value to convert\n *\n * @returns the serialized boolean as a byte in a StaticArray<u8> 'byte array'\n */\n// @ts-ignore: decorator\n@inline\nexport function boolToByte(val: bool): StaticArray<u8> {\n  const arr = new StaticArray<u8>(1);\n  arr[0] = u8(val);\n  return arr;\n}\n","/**\r\n * Status Effects Component\r\n * Handles DOT effects, buffs, debuffs, and duration tracking\r\n */\r\n\r\nimport { generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  BattlePlayer,\r\n  STATUS_NONE,\r\n  STATUS_POISON,\r\n  STATUS_STUN,\r\n  STATUS_SHIELD,\r\n  STATUS_RAGE,\r\n  STATUS_BURN,\r\n} from './types';\r\n\r\n// ============================================================================\r\n// Status Effect Checking\r\n// ============================================================================\r\n\r\n/**\r\n * Check if player has a specific status effect\r\n */\r\nexport function hasStatus(player: BattlePlayer, status: u8): bool {\r\n  return (player.statusEffects & status) != 0;\r\n}\r\n\r\n/**\r\n * Check if player is poisoned\r\n */\r\nexport function isPoisoned(player: BattlePlayer): bool {\r\n  return hasStatus(player, STATUS_POISON);\r\n}\r\n\r\n/**\r\n * Check if player is stunned\r\n */\r\nexport function isStunned(player: BattlePlayer): bool {\r\n  return hasStatus(player, STATUS_STUN);\r\n}\r\n\r\n/**\r\n * Check if player has shield\r\n */\r\nexport function hasShield(player: BattlePlayer): bool {\r\n  return hasStatus(player, STATUS_SHIELD);\r\n}\r\n\r\n/**\r\n * Check if player has rage\r\n */\r\nexport function hasRage(player: BattlePlayer): bool {\r\n  return hasStatus(player, STATUS_RAGE);\r\n}\r\n\r\n/**\r\n * Check if player is burning\r\n */\r\nexport function isBurning(player: BattlePlayer): bool {\r\n  return hasStatus(player, STATUS_BURN);\r\n}\r\n\r\n// ============================================================================\r\n// Status Effect Application\r\n// ============================================================================\r\n\r\n/**\r\n * Apply a status effect with duration\r\n */\r\nexport function applyStatus(\r\n  player: BattlePlayer,\r\n  status: u8,\r\n  duration: u8,\r\n  battleId: string\r\n): void {\r\n  player.statusEffects |= status;\r\n\r\n  switch (status) {\r\n    case STATUS_POISON:\r\n      player.poisonTurns = duration;\r\n      generateEvent(`STATUS_APPLIED:${battleId}:${player.characterId}:POISON:${duration.toString()}`);\r\n      break;\r\n    case STATUS_STUN:\r\n      player.stunTurns = duration;\r\n      generateEvent(`STATUS_APPLIED:${battleId}:${player.characterId}:STUN:${duration.toString()}`);\r\n      break;\r\n    case STATUS_SHIELD:\r\n      player.shieldTurns = duration;\r\n      generateEvent(`STATUS_APPLIED:${battleId}:${player.characterId}:SHIELD:${duration.toString()}`);\r\n      break;\r\n    case STATUS_RAGE:\r\n      player.rageTurns = duration;\r\n      generateEvent(`STATUS_APPLIED:${battleId}:${player.characterId}:RAGE:${duration.toString()}`);\r\n      break;\r\n    case STATUS_BURN:\r\n      player.burnTurns = duration;\r\n      generateEvent(`STATUS_APPLIED:${battleId}:${player.characterId}:BURN:${duration.toString()}`);\r\n      break;\r\n  }\r\n}\r\n\r\n/**\r\n * Remove a status effect\r\n */\r\nexport function removeStatus(\r\n  player: BattlePlayer,\r\n  status: u8,\r\n  battleId: string\r\n): void {\r\n  player.statusEffects &= ~status;\r\n\r\n  let statusName = '';\r\n  switch (status) {\r\n    case STATUS_POISON:\r\n      player.poisonTurns = 0;\r\n      statusName = 'POISON';\r\n      break;\r\n    case STATUS_STUN:\r\n      player.stunTurns = 0;\r\n      statusName = 'STUN';\r\n      break;\r\n    case STATUS_SHIELD:\r\n      player.shieldTurns = 0;\r\n      statusName = 'SHIELD';\r\n      break;\r\n    case STATUS_RAGE:\r\n      player.rageTurns = 0;\r\n      statusName = 'RAGE';\r\n      break;\r\n    case STATUS_BURN:\r\n      player.burnTurns = 0;\r\n      statusName = 'BURN';\r\n      break;\r\n  }\r\n\r\n  if (statusName.length > 0) {\r\n    generateEvent(`STATUS_REMOVED:${battleId}:${player.characterId}:${statusName}`);\r\n  }\r\n}\r\n\r\n/**\r\n * Clear all status effects\r\n */\r\nexport function clearAllStatus(player: BattlePlayer): void {\r\n  player.statusEffects = STATUS_NONE;\r\n  player.poisonTurns = 0;\r\n  player.stunTurns = 0;\r\n  player.shieldTurns = 0;\r\n  player.rageTurns = 0;\r\n  player.burnTurns = 0;\r\n}\r\n\r\n// ============================================================================\r\n// DOT (Damage Over Time) Processing\r\n// ============================================================================\r\n\r\n/**\r\n * Calculate and apply poison damage\r\n * Poison deals 5% of max HP per turn\r\n */\r\nexport function applyPoisonDamage(player: BattlePlayer, battleId: string): u16 {\r\n  if (!isPoisoned(player)) return 0;\r\n\r\n  const damage = u16(player.maxHp * 5 / 100);\r\n\r\n  if (player.currentHp <= damage) {\r\n    player.currentHp = 0;\r\n  } else {\r\n    player.currentHp -= damage;\r\n  }\r\n\r\n  generateEvent(\r\n    `POISON_DAMAGE:${battleId}:${player.characterId}:${damage.toString()}`\r\n  );\r\n\r\n  return damage;\r\n}\r\n\r\n/**\r\n * Calculate and apply burn damage\r\n * Burn deals 8% of max HP per turn\r\n */\r\nexport function applyBurnDamage(player: BattlePlayer, battleId: string): u16 {\r\n  if (!isBurning(player)) return 0;\r\n\r\n  const damage = u16(player.maxHp * 8 / 100);\r\n\r\n  if (player.currentHp <= damage) {\r\n    player.currentHp = 0;\r\n  } else {\r\n    player.currentHp -= damage;\r\n  }\r\n\r\n  generateEvent(\r\n    `BURN_DAMAGE:${battleId}:${player.characterId}:${damage.toString()}`\r\n  );\r\n\r\n  return damage;\r\n}\r\n\r\n/**\r\n * Apply all DOT effects at turn start\r\n * Returns total DOT damage dealt\r\n */\r\nexport function applyDOTEffects(player: BattlePlayer, battleId: string): u16 {\r\n  let totalDamage: u16 = 0;\r\n\r\n  totalDamage += applyPoisonDamage(player, battleId);\r\n  totalDamage += applyBurnDamage(player, battleId);\r\n\r\n  return totalDamage;\r\n}\r\n\r\n// ============================================================================\r\n// Duration Tick Processing\r\n// ============================================================================\r\n\r\n/**\r\n * Reduce all status effect durations by 1\r\n * Remove expired effects\r\n */\r\nexport function tickStatusDurations(\r\n  player: BattlePlayer,\r\n  battleId: string\r\n): void {\r\n  // Process poison\r\n  if (player.poisonTurns > 0) {\r\n    player.poisonTurns--;\r\n    if (player.poisonTurns == 0) {\r\n      removeStatus(player, STATUS_POISON, battleId);\r\n    }\r\n  }\r\n\r\n  // Process stun\r\n  if (player.stunTurns > 0) {\r\n    player.stunTurns--;\r\n    if (player.stunTurns == 0) {\r\n      removeStatus(player, STATUS_STUN, battleId);\r\n    }\r\n  }\r\n\r\n  // Process shield\r\n  if (player.shieldTurns > 0) {\r\n    player.shieldTurns--;\r\n    if (player.shieldTurns == 0) {\r\n      removeStatus(player, STATUS_SHIELD, battleId);\r\n    }\r\n  }\r\n\r\n  // Process rage\r\n  if (player.rageTurns > 0) {\r\n    player.rageTurns--;\r\n    if (player.rageTurns == 0) {\r\n      removeStatus(player, STATUS_RAGE, battleId);\r\n    }\r\n  }\r\n\r\n  // Process burn\r\n  if (player.burnTurns > 0) {\r\n    player.burnTurns--;\r\n    if (player.burnTurns == 0) {\r\n      removeStatus(player, STATUS_BURN, battleId);\r\n    }\r\n  }\r\n\r\n  // Process dodge boost\r\n  if (player.dodgeBoostTurns > 0) {\r\n    player.dodgeBoostTurns--;\r\n    if (player.dodgeBoostTurns == 0) {\r\n      player.dodgeBoost = 0;\r\n      generateEvent(`DODGE_BOOST_EXPIRED:${battleId}:${player.characterId}`);\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Combat Modifiers from Status\r\n// ============================================================================\r\n\r\n/**\r\n * Get damage multiplier from rage status\r\n * Returns 150 (1.5x) if rage active, 100 (1.0x) otherwise\r\n */\r\nexport function getRageDamageMultiplier(player: BattlePlayer): u8 {\r\n  return hasRage(player) ? 150 : 100;\r\n}\r\n\r\n/**\r\n * Get damage reduction from shield status\r\n * Returns 70 (0.7x) if shield active, 100 (1.0x) otherwise\r\n */\r\nexport function getShieldDamageReduction(player: BattlePlayer): u8 {\r\n  return hasShield(player) ? 70 : 100;\r\n}\r\n\r\n/**\r\n * Get total dodge chance including boost\r\n */\r\nexport function getTotalDodgeChance(player: BattlePlayer, baseDodge: u8): u8 {\r\n  const total = baseDodge + player.dodgeBoost;\r\n  return total > 100 ? 100 : total;\r\n}\r\n\r\n// ============================================================================\r\n// Status Effect Info\r\n// ============================================================================\r\n\r\n/**\r\n * Get status effect name\r\n */\r\nexport function getStatusName(status: u8): string {\r\n  switch (status) {\r\n    case STATUS_POISON:\r\n      return 'Poison';\r\n    case STATUS_STUN:\r\n      return 'Stun';\r\n    case STATUS_SHIELD:\r\n      return 'Shield';\r\n    case STATUS_RAGE:\r\n      return 'Rage';\r\n    case STATUS_BURN:\r\n      return 'Burn';\r\n    default:\r\n      return 'None';\r\n  }\r\n}\r\n\r\n/**\r\n * Get remaining duration for a status\r\n */\r\nexport function getStatusDuration(player: BattlePlayer, status: u8): u8 {\r\n  switch (status) {\r\n    case STATUS_POISON:\r\n      return player.poisonTurns;\r\n    case STATUS_STUN:\r\n      return player.stunTurns;\r\n    case STATUS_SHIELD:\r\n      return player.shieldTurns;\r\n    case STATUS_RAGE:\r\n      return player.rageTurns;\r\n    case STATUS_BURN:\r\n      return player.burnTurns;\r\n    default:\r\n      return 0;\r\n  }\r\n}\r\n\r\n/**\r\n * Get all active status effects as a string\r\n */\r\nexport function getActiveStatusString(player: BattlePlayer): string {\r\n  const statuses: string[] = [];\r\n\r\n  if (isPoisoned(player)) {\r\n    statuses.push(`Poison(${player.poisonTurns.toString()})`);\r\n  }\r\n  if (isStunned(player)) {\r\n    statuses.push(`Stun(${player.stunTurns.toString()})`);\r\n  }\r\n  if (hasShield(player)) {\r\n    statuses.push(`Shield(${player.shieldTurns.toString()})`);\r\n  }\r\n  if (hasRage(player)) {\r\n    statuses.push(`Rage(${player.rageTurns.toString()})`);\r\n  }\r\n  if (isBurning(player)) {\r\n    statuses.push(`Burn(${player.burnTurns.toString()})`);\r\n  }\r\n  if (player.dodgeBoostTurns > 0) {\r\n    statuses.push(`DodgeBoost(${player.dodgeBoostTurns.toString()})`);\r\n  }\r\n  if (player.guaranteedCrit) {\r\n    statuses.push('CritReady');\r\n  }\r\n\r\n  return statuses.length > 0 ? statuses.join(',') : 'None';\r\n}\r\n","/**\r\n * Tournament System Component\r\n * Handles tournament creation, registration, brackets, and prize distribution\r\n */\r\n\r\nimport { Context, generateEvent, transferCoins, Address } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  Tournament,\r\n  TOURNAMENT_REGISTRATION,\r\n  TOURNAMENT_ACTIVE,\r\n  TOURNAMENT_COMPLETED,\r\n} from './types';\r\nimport {\r\n  saveTournament,\r\n  loadTournament,\r\n  tournamentExists,\r\n  loadCharacter,\r\n  isAdmin,\r\n  addToTreasury,\r\n} from './storage';\r\n\r\n// ============================================================================\r\n// Tournament Creation\r\n// ============================================================================\r\n\r\n/**\r\n * Create a new tournament (admin only)\r\n * @param tournamentId - Unique tournament ID\r\n * @param name - Tournament name\r\n * @param entryFee - Entry fee in nanoMAS\r\n * @param maxParticipants - Maximum participants (must be power of 2: 4, 8, 16, 32)\r\n */\r\nexport function createTournament(\r\n  tournamentId: string,\r\n  name: string,\r\n  entryFee: u64,\r\n  maxParticipants: u8\r\n): Tournament {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can create tournaments');\r\n\r\n  // Validate tournament doesn't exist\r\n  assert(!tournamentExists(tournamentId), 'Tournament ID already exists');\r\n\r\n  // Validate max participants is power of 2\r\n  assert(\r\n    maxParticipants == 4 ||\r\n      maxParticipants == 8 ||\r\n      maxParticipants == 16 ||\r\n      maxParticipants == 32,\r\n    'Max participants must be 4, 8, 16, or 32'\r\n  );\r\n\r\n  const tournament = new Tournament(tournamentId);\r\n  tournament.name = name;\r\n  tournament.entryFee = entryFee;\r\n  tournament.maxParticipants = maxParticipants;\r\n  tournament.state = TOURNAMENT_REGISTRATION;\r\n  tournament.createdAt = Context.timestamp();\r\n\r\n  saveTournament(tournament);\r\n\r\n  generateEvent(\r\n    `TOURNAMENT_CREATED:${tournamentId}:${name}:${entryFee.toString()}:${maxParticipants.toString()}`\r\n  );\r\n\r\n  return tournament;\r\n}\r\n\r\n// ============================================================================\r\n// Registration\r\n// ============================================================================\r\n\r\n/**\r\n * Register a character for a tournament\r\n * @param tournamentId - Tournament ID\r\n * @param characterId - Character to register\r\n */\r\nexport function registerForTournament(\r\n  tournamentId: string,\r\n  characterId: string\r\n): void {\r\n  const caller = Context.caller().toString();\r\n\r\n  const tournament = loadTournament(tournamentId);\r\n  assert(tournament != null, 'Tournament not found');\r\n  assert(\r\n    tournament!.state == TOURNAMENT_REGISTRATION,\r\n    'Tournament not in registration phase'\r\n  );\r\n\r\n  // Verify character ownership\r\n  const character = loadCharacter(characterId);\r\n  assert(character != null, 'Character not found');\r\n  assert(character!.owner == caller, 'Not character owner');\r\n\r\n  // Check entry fee\r\n  const transferredCoins = Context.transferredCoins();\r\n  assert(\r\n    transferredCoins >= tournament!.entryFee,\r\n    'Insufficient entry fee'\r\n  );\r\n\r\n  // Check not already registered\r\n  const participants = getParticipantsList(tournament!);\r\n  for (let i = 0; i < participants.length; i++) {\r\n    assert(participants[i] != characterId, 'Already registered');\r\n  }\r\n\r\n  // Check max participants\r\n  assert(\r\n    participants.length < i32(tournament!.maxParticipants),\r\n    'Tournament full'\r\n  );\r\n\r\n  // Add to participants\r\n  if (tournament!.participants.length > 0) {\r\n    tournament!.participants += ',';\r\n  }\r\n  tournament!.participants += characterId;\r\n\r\n  // Add to prize pool\r\n  tournament!.prizePool += tournament!.entryFee;\r\n\r\n  saveTournament(tournament!);\r\n\r\n  generateEvent(\r\n    `TOURNAMENT_REGISTERED:${tournamentId}:${characterId}:${tournament!.prizePool.toString()}`\r\n  );\r\n\r\n  // Auto-start if full\r\n  if (participants.length + 1 == i32(tournament!.maxParticipants)) {\r\n    startTournament(tournamentId);\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Tournament Progression\r\n// ============================================================================\r\n\r\n/**\r\n * Start the tournament (generates initial bracket)\r\n */\r\nexport function startTournament(tournamentId: string): void {\r\n  const tournament = loadTournament(tournamentId);\r\n  assert(tournament != null, 'Tournament not found');\r\n  assert(\r\n    tournament!.state == TOURNAMENT_REGISTRATION,\r\n    'Tournament not in registration phase'\r\n  );\r\n\r\n  const participants = getParticipantsList(tournament!);\r\n  assert(\r\n    participants.length == i32(tournament!.maxParticipants),\r\n    'Tournament not full'\r\n  );\r\n\r\n  // Generate bracket (simple sequential pairing)\r\n  // In production, could implement seeding based on MMR\r\n  tournament!.bracket = tournament!.participants;\r\n  tournament!.state = TOURNAMENT_ACTIVE;\r\n  tournament!.currentRound = 1;\r\n  tournament!.startedAt = Context.timestamp();\r\n\r\n  saveTournament(tournament!);\r\n\r\n  generateEvent(`TOURNAMENT_STARTED:${tournamentId}`);\r\n}\r\n\r\n/**\r\n * Record a match result and advance winner\r\n * @param tournamentId - Tournament ID\r\n * @param winnerId - Winner's character ID\r\n * @param loserId - Loser's character ID\r\n */\r\nexport function recordTournamentMatch(\r\n  tournamentId: string,\r\n  winnerId: string,\r\n  loserId: string\r\n): void {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can record tournament matches');\r\n\r\n  const tournament = loadTournament(tournamentId);\r\n  assert(tournament != null, 'Tournament not found');\r\n  assert(tournament!.state == TOURNAMENT_ACTIVE, 'Tournament not active');\r\n\r\n  // Get current round participants\r\n  const bracketParts = tournament!.bracket.split('|');\r\n  const currentRoundIndex = i32(tournament!.currentRound - 1);\r\n  assert(\r\n    currentRoundIndex < bracketParts.length,\r\n    'Invalid round'\r\n  );\r\n\r\n  const currentRound = bracketParts[currentRoundIndex].split(',');\r\n\r\n  // Verify both participants are in current round\r\n  let winnerInRound = false;\r\n  let loserInRound = false;\r\n  for (let i = 0; i < currentRound.length; i++) {\r\n    if (currentRound[i] == winnerId) winnerInRound = true;\r\n    if (currentRound[i] == loserId) loserInRound = true;\r\n  }\r\n  assert(winnerInRound && loserInRound, 'Participants not in current round');\r\n\r\n  // Build next round\r\n  const nextRound: string[] = [];\r\n  for (let i = 0; i < currentRound.length; i++) {\r\n    if (currentRound[i] != loserId) {\r\n      nextRound.push(currentRound[i]);\r\n    }\r\n  }\r\n\r\n  // Check if this completes the current round's matches\r\n  const expectedNextRoundSize = currentRound.length / 2;\r\n\r\n  if (nextRound.length == expectedNextRoundSize) {\r\n    // All matches in current round complete\r\n    if (nextRound.length == 1) {\r\n      // Tournament complete\r\n      finalizeTournament(tournament!, winnerId, loserId);\r\n      return;\r\n    } else if (nextRound.length == 2) {\r\n      // Semi-finals complete, track third place\r\n      // The other loser from semis gets 3rd place\r\n      tournament!.thirdPlaceId = loserId;\r\n    }\r\n\r\n    // Add next round to bracket\r\n    tournament!.bracket += '|' + nextRound.join(',');\r\n    tournament!.currentRound++;\r\n  } else {\r\n    // Update current round in bracket\r\n    bracketParts[currentRoundIndex] = nextRound.join(',');\r\n    tournament!.bracket = bracketParts.join('|');\r\n  }\r\n\r\n  saveTournament(tournament!);\r\n\r\n  generateEvent(\r\n    `TOURNAMENT_MATCH:${tournamentId}:${winnerId}:${loserId}:${tournament!.currentRound.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Advance to next round (admin function)\r\n */\r\nexport function advanceTournamentRound(tournamentId: string): void {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can advance tournament');\r\n\r\n  const tournament = loadTournament(tournamentId);\r\n  assert(tournament != null, 'Tournament not found');\r\n  assert(tournament!.state == TOURNAMENT_ACTIVE, 'Tournament not active');\r\n\r\n  tournament!.currentRound++;\r\n  saveTournament(tournament!);\r\n\r\n  generateEvent(\r\n    `TOURNAMENT_ROUND_ADVANCED:${tournamentId}:${tournament!.currentRound.toString()}`\r\n  );\r\n}\r\n\r\n// ============================================================================\r\n// Tournament Finalization\r\n// ============================================================================\r\n\r\n/**\r\n * Finalize tournament and distribute prizes\r\n */\r\nfunction finalizeTournament(\r\n  tournament: Tournament,\r\n  winnerId: string,\r\n  runnerUpId: string\r\n): void {\r\n  tournament.state = TOURNAMENT_COMPLETED;\r\n  tournament.winnerId = winnerId;\r\n  tournament.runnerUpId = runnerUpId;\r\n  tournament.endedAt = Context.timestamp();\r\n\r\n  // Calculate prize distribution\r\n  // 50% to winner, 30% to runner-up, 20% to third place\r\n  // If no third place participant, treasury keeps it\r\n  const winnerPrize = tournament.prizePool * 50 / 100;\r\n  const runnerUpPrize = tournament.prizePool * 30 / 100;\r\n  const thirdPlacePrize = tournament.prizePool * 20 / 100;\r\n\r\n  // Get winner addresses\r\n  const winnerChar = loadCharacter(winnerId);\r\n  const runnerUpChar = loadCharacter(runnerUpId);\r\n\r\n  if (winnerChar != null) {\r\n    transferCoins(new Address(winnerChar.owner), winnerPrize);\r\n  }\r\n\r\n  if (runnerUpChar != null) {\r\n    transferCoins(new Address(runnerUpChar.owner), runnerUpPrize);\r\n  }\r\n\r\n  if (tournament.thirdPlaceId.length > 0) {\r\n    const thirdChar = loadCharacter(tournament.thirdPlaceId);\r\n    if (thirdChar != null) {\r\n      transferCoins(new Address(thirdChar.owner), thirdPlacePrize);\r\n    }\r\n  } else {\r\n    // No third place, add to treasury\r\n    addToTreasury(thirdPlacePrize);\r\n  }\r\n\r\n  saveTournament(tournament);\r\n\r\n  generateEvent(\r\n    `TOURNAMENT_COMPLETED:${tournament.id}:${winnerId}:${runnerUpId}:${tournament.thirdPlaceId}:${winnerPrize.toString()}`\r\n  );\r\n}\r\n\r\n/**\r\n * Force finalize tournament (admin only, for emergencies)\r\n */\r\nexport function forceFinalizeTournament(\r\n  tournamentId: string,\r\n  winnerId: string,\r\n  runnerUpId: string,\r\n  thirdPlaceId: string\r\n): void {\r\n  const caller = Context.caller().toString();\r\n  assert(isAdmin(caller), 'Only admin can force finalize');\r\n\r\n  const tournament = loadTournament(tournamentId);\r\n  assert(tournament != null, 'Tournament not found');\r\n\r\n  tournament!.thirdPlaceId = thirdPlaceId;\r\n  finalizeTournament(tournament!, winnerId, runnerUpId);\r\n}\r\n\r\n// ============================================================================\r\n// Helper Functions\r\n// ============================================================================\r\n\r\n/**\r\n * Get participants as array\r\n */\r\nexport function getParticipantsList(tournament: Tournament): string[] {\r\n  if (tournament.participants.length == 0) {\r\n    return [];\r\n  }\r\n  return tournament.participants.split(',');\r\n}\r\n\r\n/**\r\n * Get current round participants\r\n */\r\nexport function getCurrentRoundParticipants(tournament: Tournament): string[] {\r\n  if (tournament.bracket.length == 0) {\r\n    return [];\r\n  }\r\n\r\n  const rounds = tournament.bracket.split('|');\r\n  const currentRoundIndex = i32(tournament.currentRound - 1);\r\n\r\n  if (currentRoundIndex >= rounds.length) {\r\n    return [];\r\n  }\r\n\r\n  return rounds[currentRoundIndex].split(',');\r\n}\r\n\r\n/**\r\n * Check if character is registered in tournament\r\n */\r\nexport function isRegistered(tournamentId: string, characterId: string): bool {\r\n  const tournament = loadTournament(tournamentId);\r\n  if (tournament == null) return false;\r\n\r\n  const participants = getParticipantsList(tournament!);\r\n  for (let i = 0; i < participants.length; i++) {\r\n    if (participants[i] == characterId) return true;\r\n  }\r\n  return false;\r\n}\r\n\r\n/**\r\n * Get tournament state name\r\n */\r\nexport function getTournamentStateName(state: u8): string {\r\n  switch (state) {\r\n    case TOURNAMENT_REGISTRATION:\r\n      return 'Registration';\r\n    case TOURNAMENT_ACTIVE:\r\n      return 'Active';\r\n    case TOURNAMENT_COMPLETED:\r\n      return 'Completed';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n","/**\r\n * Achievement System Component\r\n * Handles achievement tracking and unlocking\r\n */\r\n\r\nimport { Context, generateEvent } from '@massalabs/massa-as-sdk';\r\nimport {\r\n  AchievementTracker,\r\n  Character,\r\n  ACH_FIRST_WIN,\r\n  ACH_10_WINS,\r\n  ACH_50_WINS,\r\n  ACH_100_WINS,\r\n  ACH_TOURNAMENT_WIN,\r\n  ACH_5_WIN_STREAK,\r\n  ACH_COMBO_MASTER,\r\n  ACH_SKILL_MASTER,\r\n  ACH_LEGENDARY_EQUIP,\r\n  ACH_MAX_LEVEL,\r\n  MAX_LEVEL,\r\n  RARITY_LEGENDARY,\r\n} from './types';\r\nimport {\r\n  saveAchievements,\r\n  loadAchievements,\r\n  getOrCreateAchievements,\r\n  loadCharacter,\r\n  loadEquipment,\r\n  getOwnerCharacters,\r\n  getOwnerEquipment,\r\n} from './storage';\r\nimport { getLearnedSkillCount } from './skills';\r\n\r\n// ============================================================================\r\n// Achievement Checking\r\n// ============================================================================\r\n\r\n/**\r\n * Check if an achievement is unlocked\r\n */\r\nexport function hasAchievement(tracker: AchievementTracker, achievementId: u8): bool {\r\n  const bit: u16 = u16(1) << (achievementId - 1);\r\n  return (tracker.unlockedAchievements & bit) != 0;\r\n}\r\n\r\n/**\r\n * Unlock an achievement\r\n */\r\nfunction unlockAchievement(\r\n  tracker: AchievementTracker,\r\n  achievementId: u8\r\n): bool {\r\n  if (hasAchievement(tracker, achievementId)) {\r\n    return false; // Already unlocked\r\n  }\r\n\r\n  const bit: u16 = u16(1) << (achievementId - 1);\r\n  tracker.unlockedAchievements |= bit;\r\n\r\n  // Add timestamp\r\n  const timestamp = Context.timestamp().toString();\r\n  if (tracker.timestamps.length > 0) {\r\n    tracker.timestamps += ',';\r\n  }\r\n  tracker.timestamps += `${achievementId.toString()}:${timestamp}`;\r\n\r\n  generateEvent(\r\n    `ACHIEVEMENT_UNLOCKED:${tracker.ownerAddress}:${achievementId.toString()}:${getAchievementName(achievementId)}`\r\n  );\r\n\r\n  return true;\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Names\r\n// ============================================================================\r\n\r\n/**\r\n * Get achievement name\r\n */\r\nexport function getAchievementName(achievementId: u8): string {\r\n  switch (achievementId) {\r\n    case ACH_FIRST_WIN:\r\n      return 'First Victory';\r\n    case ACH_10_WINS:\r\n      return 'Rising Champion';\r\n    case ACH_50_WINS:\r\n      return 'Veteran Fighter';\r\n    case ACH_100_WINS:\r\n      return 'Legendary Warrior';\r\n    case ACH_TOURNAMENT_WIN:\r\n      return 'Tournament Champion';\r\n    case ACH_5_WIN_STREAK:\r\n      return 'Unstoppable';\r\n    case ACH_COMBO_MASTER:\r\n      return 'Combo Master';\r\n    case ACH_SKILL_MASTER:\r\n      return 'Skill Master';\r\n    case ACH_LEGENDARY_EQUIP:\r\n      return 'Legendary Collector';\r\n    case ACH_MAX_LEVEL:\r\n      return 'Max Power';\r\n    default:\r\n      return 'Unknown';\r\n  }\r\n}\r\n\r\n/**\r\n * Get achievement description\r\n */\r\nexport function getAchievementDescription(achievementId: u8): string {\r\n  switch (achievementId) {\r\n    case ACH_FIRST_WIN:\r\n      return 'Win your first battle';\r\n    case ACH_10_WINS:\r\n      return 'Win 10 battles';\r\n    case ACH_50_WINS:\r\n      return 'Win 50 battles';\r\n    case ACH_100_WINS:\r\n      return 'Win 100 battles';\r\n    case ACH_TOURNAMENT_WIN:\r\n      return 'Win a tournament';\r\n    case ACH_5_WIN_STREAK:\r\n      return 'Achieve a 5-win streak';\r\n    case ACH_COMBO_MASTER:\r\n      return 'Land a 5+ hit combo in battle';\r\n    case ACH_SKILL_MASTER:\r\n      return 'Learn all 10 skills on one character';\r\n    case ACH_LEGENDARY_EQUIP:\r\n      return 'Obtain a legendary equipment piece';\r\n    case ACH_MAX_LEVEL:\r\n      return 'Reach maximum level (20)';\r\n    default:\r\n      return 'Unknown achievement';\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Progress Checking\r\n// ============================================================================\r\n\r\n/**\r\n * Check and grant win-based achievements\r\n * @param ownerAddress - Player address\r\n * @param totalWins - Total wins across all characters\r\n * @param currentStreak - Current win streak\r\n */\r\nexport function checkWinAchievements(\r\n  ownerAddress: string,\r\n  totalWins: u32,\r\n  currentStreak: u8\r\n): void {\r\n  const tracker = getOrCreateAchievements(ownerAddress);\r\n  let updated = false;\r\n\r\n  // First win\r\n  if (totalWins >= 1) {\r\n    updated = unlockAchievement(tracker, ACH_FIRST_WIN) || updated;\r\n  }\r\n\r\n  // 10 wins\r\n  if (totalWins >= 10) {\r\n    updated = unlockAchievement(tracker, ACH_10_WINS) || updated;\r\n  }\r\n\r\n  // 50 wins\r\n  if (totalWins >= 50) {\r\n    updated = unlockAchievement(tracker, ACH_50_WINS) || updated;\r\n  }\r\n\r\n  // 100 wins\r\n  if (totalWins >= 100) {\r\n    updated = unlockAchievement(tracker, ACH_100_WINS) || updated;\r\n  }\r\n\r\n  // 5 win streak\r\n  if (currentStreak >= 5) {\r\n    updated = unlockAchievement(tracker, ACH_5_WIN_STREAK) || updated;\r\n  }\r\n\r\n  if (updated) {\r\n    saveAchievements(tracker);\r\n  }\r\n}\r\n\r\n/**\r\n * Check and grant tournament win achievement\r\n */\r\nexport function checkTournamentWinAchievement(ownerAddress: string): void {\r\n  const tracker = getOrCreateAchievements(ownerAddress);\r\n  if (unlockAchievement(tracker, ACH_TOURNAMENT_WIN)) {\r\n    saveAchievements(tracker);\r\n  }\r\n}\r\n\r\n/**\r\n * Check and grant combo master achievement\r\n * @param ownerAddress - Player address\r\n * @param comboCount - Combo achieved in battle\r\n */\r\nexport function checkComboAchievement(ownerAddress: string, comboCount: u8): void {\r\n  if (comboCount >= 5) {\r\n    const tracker = getOrCreateAchievements(ownerAddress);\r\n    if (unlockAchievement(tracker, ACH_COMBO_MASTER)) {\r\n      saveAchievements(tracker);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check and grant skill master achievement\r\n * @param ownerAddress - Player address\r\n * @param character - Character that learned skills\r\n */\r\nexport function checkSkillMasterAchievement(\r\n  ownerAddress: string,\r\n  character: Character\r\n): void {\r\n  if (getLearnedSkillCount(character) >= 10) {\r\n    const tracker = getOrCreateAchievements(ownerAddress);\r\n    if (unlockAchievement(tracker, ACH_SKILL_MASTER)) {\r\n      saveAchievements(tracker);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check and grant legendary equipment achievement\r\n * @param ownerAddress - Player address\r\n * @param rarity - Equipment rarity obtained\r\n */\r\nexport function checkLegendaryEquipAchievement(\r\n  ownerAddress: string,\r\n  rarity: u8\r\n): void {\r\n  if (rarity == RARITY_LEGENDARY) {\r\n    const tracker = getOrCreateAchievements(ownerAddress);\r\n    if (unlockAchievement(tracker, ACH_LEGENDARY_EQUIP)) {\r\n      saveAchievements(tracker);\r\n    }\r\n  }\r\n}\r\n\r\n/**\r\n * Check and grant max level achievement\r\n * @param ownerAddress - Player address\r\n * @param level - Character level\r\n */\r\nexport function checkMaxLevelAchievement(ownerAddress: string, level: u8): void {\r\n  if (level >= MAX_LEVEL) {\r\n    const tracker = getOrCreateAchievements(ownerAddress);\r\n    if (unlockAchievement(tracker, ACH_MAX_LEVEL)) {\r\n      saveAchievements(tracker);\r\n    }\r\n  }\r\n}\r\n\r\n// ============================================================================\r\n// Achievement Queries\r\n// ============================================================================\r\n\r\n/**\r\n * Get total achievements unlocked\r\n */\r\nexport function getUnlockedCount(tracker: AchievementTracker): u8 {\r\n  let count: u8 = 0;\r\n  for (let i: u8 = 1; i <= 10; i++) {\r\n    if (hasAchievement(tracker, i)) {\r\n      count++;\r\n    }\r\n  }\r\n  return count;\r\n}\r\n\r\n/**\r\n * Get completion percentage\r\n */\r\nexport function getCompletionPercentage(tracker: AchievementTracker): u8 {\r\n  return u8((u32(getUnlockedCount(tracker)) * 100) / 10);\r\n}\r\n\r\n/**\r\n * Get all unlocked achievements as string\r\n */\r\nexport function getUnlockedAchievementsString(tracker: AchievementTracker): string {\r\n  const achievements: string[] = [];\r\n  for (let i: u8 = 1; i <= 10; i++) {\r\n    if (hasAchievement(tracker, i)) {\r\n      achievements.push(getAchievementName(i));\r\n    }\r\n  }\r\n  return achievements.length > 0 ? achievements.join(',') : 'None';\r\n}\r\n\r\n/**\r\n * Get player achievements\r\n */\r\nexport function getPlayerAchievements(ownerAddress: string): AchievementTracker {\r\n  return getOrCreateAchievements(ownerAddress);\r\n}\r\n\r\n// ============================================================================\r\n// Batch Achievement Check\r\n// ============================================================================\r\n\r\n/**\r\n * Check all achievements for a player (comprehensive check)\r\n */\r\nexport function checkAllAchievements(ownerAddress: string): void {\r\n  const tracker = getOrCreateAchievements(ownerAddress);\r\n  let updated = false;\r\n\r\n  // Get all characters for this owner\r\n  const characterIds = getOwnerCharacters(ownerAddress);\r\n  let totalWins: u32 = 0;\r\n  let maxStreak: u8 = 0;\r\n  let hasMaxLevel = false;\r\n  let hasSkillMaster = false;\r\n\r\n  for (let i = 0; i < characterIds.length; i++) {\r\n    const character = loadCharacter(characterIds[i]);\r\n    if (character != null) {\r\n      totalWins += character.totalWins;\r\n      if (character.winStreak > maxStreak) {\r\n        maxStreak = character.winStreak;\r\n      }\r\n      if (character.level >= MAX_LEVEL) {\r\n        hasMaxLevel = true;\r\n      }\r\n      if (getLearnedSkillCount(character) >= 10) {\r\n        hasSkillMaster = true;\r\n      }\r\n    }\r\n  }\r\n\r\n  // Check win achievements\r\n  if (totalWins >= 1) updated = unlockAchievement(tracker, ACH_FIRST_WIN) || updated;\r\n  if (totalWins >= 10) updated = unlockAchievement(tracker, ACH_10_WINS) || updated;\r\n  if (totalWins >= 50) updated = unlockAchievement(tracker, ACH_50_WINS) || updated;\r\n  if (totalWins >= 100) updated = unlockAchievement(tracker, ACH_100_WINS) || updated;\r\n  if (maxStreak >= 5) updated = unlockAchievement(tracker, ACH_5_WIN_STREAK) || updated;\r\n  if (hasMaxLevel) updated = unlockAchievement(tracker, ACH_MAX_LEVEL) || updated;\r\n  if (hasSkillMaster) updated = unlockAchievement(tracker, ACH_SKILL_MASTER) || updated;\r\n\r\n  // Check equipment achievements\r\n  const equipmentIds = getOwnerEquipment(ownerAddress);\r\n  for (let i = 0; i < equipmentIds.length; i++) {\r\n    const equipment = loadEquipment(equipmentIds[i]);\r\n    if (equipment != null && equipment.rarity == RARITY_LEGENDARY) {\r\n      updated = unlockAchievement(tracker, ACH_LEGENDARY_EQUIP) || updated;\r\n      break;\r\n    }\r\n  }\r\n\r\n  if (updated) {\r\n    saveAchievements(tracker);\r\n  }\r\n}\r\n","import { env } from '../../env';\n\n/**\n * Returns the balance of the current address.\n *\n * @returns - value in the smallest unit.\n *\n */\nexport function balance(): u64 {\n  return env.balance();\n}\n\n/**\n * Returns the balance of the specified address.\n *\n * @param address - The address for which the balance is retrieved.\n *\n * @returns - value in the smallest unit.\n *\n * @throws\n * - if the given address is not a valid address.\n *\n */\nexport function balanceOf(address: string): u64 {\n  return env.balanceOf(address);\n}\n","type auto = i32;\n\n@final export abstract class Function<T> {\n  private _index: u32;\n  private _env: usize;\n\n  // @ts-ignore: this on getter\n  get index(this: T): u32 {\n    return load<u32>(changetype<usize>(this), offsetof<Function<T>>(\"_index\"));\n  }\n\n  // @ts-ignore: this on getter\n  get name(this: T): string {\n    return \"\";\n  }\n\n  // @ts-ignore: this on getter\n  get length(this: T): i32 {\n    // @ts-ignore: T is function\n    return lengthof<T>();\n  }\n\n  // @ts-ignore: T is function\n  @builtin call(thisArg: thisof<T> | null, ...args: auto[]): returnof<T> {\n    return unreachable();\n  }\n\n  toString(this: T): string {\n    return \"function() { [native code] }\";\n  }\n\n  // RT integration\n\n  @unsafe private __visit(cookie: u32): void {\n    // Env is either `null` (nop) or compiler-generated\n    __visit(this._env, cookie);\n  }\n}\n"]}